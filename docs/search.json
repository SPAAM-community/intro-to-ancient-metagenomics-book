[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Ancient Metagenomics",
    "section": "",
    "text": "Introduction\nAncient metagenomics applies cutting-edge metagenomic methods to the degraded DNA content of archaeological and palaeontological specimens. The rapidly growing field is currently uncovering a wealth of novel information for both human and natural history, from identifying the causes of devastating pandemics such as the Black Death, to revealing how past ecosystems changed in response to long-term climatic and anthropogenic change, to reconstructing the microbiomes of extinct human relatives. However, as the field grows, the techniques, methods, and workflows used to analyse such data are rapidly changing and improving.\nIn this book we will go through the main steps of ancient metagenomic bioinformatic workflows, familiarising students with the command line, demonstrating how to process next-generation-sequencing (NGS) data, and showing how to perform de novo metagenomic assembly. Focusing on host-associated ancient metagenomics, the book consists of a combination of theory and hands-on exercises, allowing readers to become familiar with the types of questions and data researchers work with.\nBy the end of the textbook, readers will have an understanding of how to effectively carry out the major bioinformatic components of an ancient metagenomic project in an open and transparent manner.\n\n\n\n\n\n\nNote\n\n\n\nIf you export the PDF or ePub versions of this book, some sections maybe excluded (such as videos, and embedded slide decks). Always refer to this website in doubt.\n\n\nAll material was originally developed for the SPAAM Summer School: Introduction to Ancient Metagenomics"
  },
  {
    "objectID": "citing-this-book.html",
    "href": "citing-this-book.html",
    "title": "Citing this book",
    "section": "",
    "text": "The source material for this book is located on GitHub:\nhttps://github.com/SPAAM-community/intro-to-ancient-metagenomics-book.\nIf you wish to cite this book, please use the following bibliographic information\n\nFellows Yates, J. A., Warinner, C., Hiß, A., Kocher, A., Schmid, C., Velsko, I., Borry, M., Michel, M., Oskolkov, N., Duchene, S., Lamnidis, T., Valtueña Andrades, A., & Herbig, A. (2023). Introduction to Ancient Metagenomics. Zenodo. https://doi.org/10.5281/ZENODO.8027281\n\n\nThis work is licensed under a Creative Commons Attribution 4.0 International License."
  },
  {
    "objectID": "authors.html",
    "href": "authors.html",
    "title": "Authors",
    "section": "",
    "text": "The creation of this text book was developed through a series of …\n\n\n\n\n\n\n\n\n2022\n\n🇬🇧 James Fellows Yates is an archaeology-trained biomolecular archaeologist and convert to palaeogenomics, and is recently pivoting to bioinformatics. He specialises in ancient metagenomics analysis, generating tools and high-throughput approaches and high-quality pipelines for validating and analysing ancient (oral) microbiomes and palaeogenomic data.\n\n\n2022\n\n🇺🇸 Christina Warinner is Group Leader of Microbiome Sciences at the Max Planck Institute for Evolutionary Anthropology in Leipzig, Germany, and Associate Professor of Anthropology at Harvard University. She serves on the Leadership Team of the Max Planck-Harvard Research Center for the Archaeoscience of the Ancient Mediterranean (MHAAM), and is a Professor in the Faculty of Biological Sciences at Friedrich Schiller University in Jena, Germany. Her research focuses on the use of metagenomics and paleoproteomics to better understand past human diet, health, and the evolution of the human microbiome.\n\n\n2022\n\n🇪🇸 Aida Andrades Valtueña is a geneticist interested in pathogen evolution, with particular interest in prehistoric pathogens. She has been exploring new methods to analyse ancient pathogen data to understand their past function and ecology to inform models of pathogen emergence.\n\n\n2022\n\n🇩🇪 Alexander Herbig is a bioinformatician and group leader for Computational Pathogenomics at the Max Planck Institute for Evolutionary Anthropology. His main interest is in studying the evolution of human pathogens and in methods development for pathogen detection and bacterial genomics.\n\n\n2022\n\n🇩🇪 Alex Hübner is a computational biologist, who originally studied biotechnology, before switching to evolutionary biology during his PhD. For his postdoc in the Warinner lab, he focuses on investigating whether new methods in the field of modern metagenomics can be directly applied to ancient DNA data. Here, he is particularly interested in the de novo assembly of ancient metagenomic sequencing data and the subsequent analysis of its results.\n\n\n2022\n\n🇩🇪 Alina Hiss is a PhD student in the Computational Pathogenomics group at the Max Planck Institute for Evolutionary Anthropology. She is interested in the evolution of human pathogens and working on material from the Carpathian basin to gain insights about the presence and spread of pathogens in the region during the Early Medieval period.\n\n\n2022\n\n🇫🇷 Arthur Kocher initially trained as a veterinarian. He then pursued a PhD in the field of disease ecology, during which he studied the impact of biodiversity changes on the transmission of zoonotic diseases using molecular tools such as DNA metabarcoding. During his Post-Docs, he extended his research focus to evolutionary aspects of pathogens, which he currently investigates using ancient genomic data and Bayesian phylogenetics.\n\n\n2022\n\n🇩🇪 Clemens Schmid is a computational archaeologist pursuing a PhD in the group of Stephan Schiffels at the department of Archaeogenetics at the Max Planck Institute for Evolutionary Anthropology. He is trained both in archaeology and computer science and currently develops computational methods for the spatiotemporal co-analysis of archaeological and ancient genomic data. He worked in research projects on the European Neolithic, Copper and Bronze age and maintains research software in R, C++ and Haskell.\n\n\n2022\n\n🇺🇸 Irina Velsko is a postdoc in the Microbiome group of the department of Archaeogenetics at the Max Planck Institute for Evolutionary Anthropology. She did her PhD work on oral microbiology and immunology of the living, and now works on oral microbiomes of the living and the dead. Her work focuses on the evolution and ecology of dental plaque biofilms, both modern and ancient, and the complex interplay between microbiomes and their hosts.\n\n\n2022\n\n🇫🇷 Maxime Borry is a doctoral researcher in bioinformatics at the Max Planck Institute for Evolutionary Anthropology in Germany. After an undergraduate in life sciences and a master in Ecology, followed by a master in bioinformatics, he is now working on the completion of his PhD, focused on developing new tools and data analysis of ancient metagenomic samples.\n\n\n2022\n\n🇺🇸 Megan Michel is a PhD student jointly affiliated with the Archaeogenetics Department at the Max Planck Institute for Evolutionary Anthropology and the Human Evolutionary Biology Department at Harvard University. Her research focuses on using computational genomic analyses to understand how pathogens have co-evolved with their hosts over the course of human history.\n\n\n2022\n\n🇷🇺 Nikolay Oskolkov is a bioinformatician at Lund University and the bioinformatics platform of SciLifeLab, Sweden. He defended his PhD in theoretical physics in 2007, and switched to life sciences in 2012. His research interests include mathematical statistics and machine learning applied to genetics and genomics, single cell and ancient metagenomics data analysis.\n\n\n2022\n\n🇦🇺 Sebastian Duchene is an Australian Research Council Fellow at the Doherty Institute for Infection and Immunity at the University of Melbourne, Australia. Prior to joining the University of Melbourne he obtained his PhD and conducted postdoctoral work at the University of Sydney. His research is in molecular evolution and epidemiology of infectious pathogens, notably viruses and bacteria, and developing Bayesian phylodynamic methods.\n\n\n2022\n\n🇬🇷 Thiseas Lamnidis is a human population geneticist interested in European population history after the Bronze Age. To gain the required resolution to differentiate between Iron Age European populations, he is developing analytical methods based on the sharing of rare variation between individuals. He has also contributed to pipelines that streamline the processing and analysis of genetic data in a reproducible manner, while also facilitating dissemination of information among interdisciplinary colleagues."
  },
  {
    "objectID": "acknowledgements.html#financial-support",
    "href": "acknowledgements.html#financial-support",
    "title": "Acknowledgements",
    "section": "Financial Support",
    "text": "Financial Support\n\nThe content of this textbook was developed from the SPAAM Summer School: Introduction to Ancient Metagenomics summer school series, sponsored by the Werner Siemens-Stiftung (Grant: Paleobiotechnology, awarded to Pierre Stallforth, Hans-Knöll Institute, and Christina Warinner, Max Planck Institute for Evolutionary Anthropology)"
  },
  {
    "objectID": "acknowledgements.html#institutional-support",
    "href": "acknowledgements.html#institutional-support",
    "title": "Acknowledgements",
    "section": "Institutional Support",
    "text": "Institutional Support"
  },
  {
    "objectID": "acknowledgements.html#infrastructural-support",
    "href": "acknowledgements.html#infrastructural-support",
    "title": "Acknowledgements",
    "section": "Infrastructural Support",
    "text": "Infrastructural Support\n\nThe practical sessions of the summers schools work was supported by the BMBF-funded de.NBI Cloud within the German Network for Bioinformatics Infrastructure (de.NBI) (031A532B, 031A533A, 031A533B, 031A534A, 031A535A, 031A537A, 031A537B, 031A537C, 031A537D, 031A538A). z"
  },
  {
    "objectID": "before-you-start.html#creating-a-conda-environment",
    "href": "before-you-start.html#creating-a-conda-environment",
    "title": "Before you Start",
    "section": "Creating a conda environment",
    "text": "Creating a conda environment\nOnce conda is installed and bioconda configured, at the beginning of each chapter, to create the conda environment from the yml file, you will need to run the following:\n\nDownload the conda env on\nWithin the resulting directory run the following conda command to install the software into it’s dedicated environment\nconda env create -f &lt;env_file&gt;.yml\n::: {.callout-note} Note: you only have to run the environment creation once. :::\nFollow the instructions as prompted. Once created, you can see a list of environments with\nconda env list\nTo load the relevant environment, you can run\nconda activate &lt;name_of_envonment&gt;.yml\nOnce finished with the chapter, you can deactivate the environment with\nconda deactivate\n\nTo reuse the environment, just run step 4 and 5 as necessary.\n\n\n\n\n\n\nTip\n\n\n\nTo delete a conda software environment, just get the path listed on conda env list and delete the folder with rm -rf &lt;path&gt;."
  },
  {
    "objectID": "before-you-start.html#additional-software",
    "href": "before-you-start.html#additional-software",
    "title": "Before you Start",
    "section": "Additional Software",
    "text": "Additional Software\nFor some chapters you may need the following software/and or data manually installed, which are not available on bioconda:\n\nDe novo assembly\n\nMetaWrap\n\nconda create -n metawrap-env python=2.7\nconda activate metawrap-env\nconda install biopython bwa maxbin2 metabat2 samtools=1.9\ncd ~/bin/\ngit clone https://github.com/bxlab/metaWRAP.git\necho \"export PATH=$PATH:~/bin/metaWRAP/bin\" &gt;&gt; ~/.bashrc\nFunctional Profiling\n\nHUMAnN3 UniRef database (where the functional providing conda environment is already activated - see the Functional Profiling chapter for more details)\nhumann3_databases --download uniref uniref90_ec_filtered_diamond /vol/volume/5c-functional-genomics/humann3_db\n\nPhylogenomics\n\nTempest (v1.5.3)\nIt is also recommended to assign the following bash variable so you can access the tool without the full path\nexport tempest='bash /home/ubuntu/bin/TempEst_v1.5.3/bin/tempest'\nMEGAX (v11.0.11)"
  },
  {
    "objectID": "section-theory.html#lectures",
    "href": "section-theory.html#lectures",
    "title": "Theory",
    "section": "Lectures",
    "text": "Lectures\n\nIntroduction to NGS Sequencing\nIn this chapter, we will introduce how we are able to convert DNA molecules to human readable sequences of A, C, T, and Gs, which we can subsequently can computationally analyse.\nThe field of Ancient DNA was revolutionised by the development of ‘Next Generation Sequencing’ (NGS), which relies on sequencing of millions of short fragments of DNA in parallel. The global leading DNA sequencing company is Illumina, and the technology used by Illumina is also most popular by palaeogeneticists. Therefore we will go through the various technologies behind Illumina next-generation sequencing machines.\nWe will also look at some important differences in the way different models of Illumina sequences work, and how this can influence ancient DNA research. Finally we will cover the structure of ‘FASTQ’ files, the most popular file format for representing the DNA sequence output of NGS sequencing machines.\n\n\nIntroduction to Ancient DNA\nThis chapter introduces you to ancient DNA and the enormous technological changes that have taken place since the field’s origins in 1984. Starting with the quagga and proceeding to microbes, we discuss where ancient microbial DNA can be found in the archaeological record and examine how ancient DNA is defined by its condition, not by a fixed age.\nWe next cover genome basics and take an in-depth look at the way DNA degrades over time. We detail the fundamentals of DNA damage, including the specific chemical processes that lead to DNA fragmentation and C-&gt;T miscoding lesions. We then demystify the DNA damage “smiley plot” and explain the how the plot’s symmetry or asymmetry is related to the specific enzymes used to repair DNA during library construction. We discuss how DNA damage is and is not clock-like, how to interpret and troubleshoot DNA damage plots, and how DNA damage patters can be used to authenticate ancient samples, specific taxa, and even sequences. We cover laboratory strategies for removing or reducing damage for greater accuracy for genotype calling, and we discuss the pros and cons of single-stranded library protocols. We then take a closer look at proofreading and non-proofreading polymerases and note key steps in NGS library preparation during which enzyme selection is critical in ancient DNA studies.\nFinally, we examine the big picture of why DNA damage matters in ancient microbial studies, and its effects on taxonomic identification of sequences, accurate genome mapping, and metagenomic assembly.\n\n\nIntroduction to Metagenomics\nThis chapter introduces you to the basics of metagenomics, with an emphasis on tools and approaches that are used to study ancient metagenomes. We begin by covering the basic terminology used in metagenomics and microbiome research and discuss how the field has changed over time. We examine the species concept for microbes and challenges that arise in classifying microbial species with respect to taxonomy and phylogeny. We then proceed to taxonomic profiling and discuss the pros and cons of different taxonomic profilers.\nAfterwards, we explain how to estimate preservation in ancient metagenomic samples and how to clean up your datasets and remove contaminants. Finally, we discuss strategies for exploring and comparing the ecological diversity in your samples, including different strategies for data normalization, distance calculation, and ordination.\n\n\nIntroduction to Microbial Genomics\nThe field of microbial genomics aims at the reconstruction and comparative analyses of genomes for gaining insights into the genetic foundation and evolution of various functional aspects such as virulence mechanisms in pathogens.\nIncluding data from ancient samples into this comparative assessment allows for studying these evolutionary changes through time. This, for example, provides insights into the emergence of human pathogens and their development in conjunction with human cultural transitions.\nIn this chapter we will look examples for how to utilise data from ancient genomes in comparative studies of human pathogens and today’s practical sessions will highlight methodologies for the reconstruction of microbial genomes.\n\n\nIntroduction to Evolutionary Biology\nPathogen genome data are an invaluable source of information about the evolution and spread of these organisms. This chapter will focus on molecular phylogenetic methods and the insight that they can reveal from improving our understanding of ancient evolution to the epidemiological dynamics of current outbreaks.\nThe first section will introduce phylognenetic trees and a set of core terms and concepts for their interpretation. Next, it will focus on some of the most popular approaches to inferring phylogenetic trees; those based on genetic distance, maximum likelihood, and Bayesian inference. These methods carry important considerations regarding the process that generated the data, computational capability, and data quality, all of which will be discussed here. Finally, we will direct our attention to examples of analyses of ancient and modern pathogens (e.g. Yersinia pestis, Hepatitis B virus, SARS-CoV-2) and critically assess appropriate choice of models and methods."
  },
  {
    "objectID": "introduction-to-ngs-sequencing.html#lecture",
    "href": "introduction-to-ngs-sequencing.html#lecture",
    "title": "1  Introduction to NGS Sequencing",
    "section": "1.1 Lecture",
    "text": "1.1 Lecture\nLecture slides and video from the 2022 edition of the summer school.\n\n\nPDF version of the slide lectures can be downloaded from here."
  },
  {
    "objectID": "introduction-to-ngs-sequencing.html#readings",
    "href": "introduction-to-ngs-sequencing.html#readings",
    "title": "1  Introduction to NGS Sequencing",
    "section": "1.2 Readings",
    "text": "1.2 Readings\n\nReviews\n(Schuster 2008)\n(Shendure and Ji 2008)\n(Slatko, Gardner, and Ausubel 2018)\n(Dijk et al. 2014)\n\n\nSequencing Library Construction\n(Kircher, Sawyer, and Meyer 2012)\n(Meyer and Kircher 2010)\n\n\nErrors and Considerations\n(Ma et al. 2019)\n(Sinha et al. 2017)\n(Valk et al. 2019)"
  },
  {
    "objectID": "introduction-to-ngs-sequencing.html#questions-to-think-about",
    "href": "introduction-to-ngs-sequencing.html#questions-to-think-about",
    "title": "1  Introduction to NGS Sequencing",
    "section": "1.3 Questions to think about",
    "text": "1.3 Questions to think about\n\nWhy is Illumina sequencing technologies useful for aDNA?\nWhat problems can the 2-colour chemistry technology of NextSeq and NovaSeqs cause in downstream analysis?\nWhy is ‘Index-Hopping’ a problem?\nWhat is good software to evaluate the quality of your sequencing runs?\n\n\n\n\n\nDijk, Erwin L van, Hélène Auger, Yan Jaszczyszyn, and Claude Thermes. 2014. “Ten Years of Next-Generation Sequencing Technology.” Trends in Genetics 30 (9): 418–26. https://doi.org/10.1016/j.tig.2014.07.001.\n\n\nKircher, Martin, Susanna Sawyer, and Matthias Meyer. 2012. “Double Indexing Overcomes Inaccuracies in Multiplex Sequencing on the Illumina Platform.” Nucleic Acids Research 40 (1): e3. https://doi.org/10.1093/nar/gkr771.\n\n\nMa, Xiaotu, Ying Shao, Liqing Tian, Diane A Flasch, Heather L Mulder, Michael N Edmonson, Yu Liu, et al. 2019. “Analysis of Error Profiles in Deep Next-Generation Sequencing Data.” Genome Biology 20 (1): 50. https://doi.org/10.1186/s13059-019-1659-6.\n\n\nMeyer, Matthias, and Martin Kircher. 2010. “Illumina Sequencing Library Preparation for Highly Multiplexed Target Capture and Sequencing.” Cold Spring Harbor Protocols 2010 (6): db.prot5448. https://doi.org/10.1101/pdb.prot5448.\n\n\nSchuster, Stephan C. 2008. “Next-Generation Sequencing Transforms Today’s Biology.” Nature Methods 5 (1): 16–18. https://doi.org/10.1038/nmeth1156.\n\n\nShendure, Jay, and Hanlee Ji. 2008. “Next-Generation DNA Sequencing.” Nature Biotechnology 26 (10): 1135–45. https://doi.org/10.1038/nbt1486.\n\n\nSinha, Rahul, Geoff Stanley, Gunsagar Singh Gulati, Camille Ezran, Kyle Joseph Travaglini, Eric Wei, Charles Kwok Fai Chan, et al. 2017. “Index Switching Causes ‘Spreading-of-Signal’ Among Multiplexed Samples in Illumina HiSeq 4000 DNA Sequencing.” bioRxiv. https://doi.org/10.1101/125724.\n\n\nSlatko, Barton E, Andrew F Gardner, and Frederick M Ausubel. 2018. “Overview of Next-Generation Sequencing Technologies.” Current Protocols in Molecular Biology / Edited by Frederick M. Ausubel ... [Et Al.] 122 (1): e59. https://doi.org/10.1002/cpmb.59.\n\n\nValk, Tom van der, Francesco Vezzi, Mattias Ormestad, Love Dalén, and Katerina Guschanski. 2019. “Index Hopping on the Illumina HiseqX Platform and Its Consequences for Ancient DNA Studies.” Molecular Ecology Resources, March. https://doi.org/10.1111/1755-0998.13009."
  },
  {
    "objectID": "introduction-to-ancient-dna.html#lecture",
    "href": "introduction-to-ancient-dna.html#lecture",
    "title": "2  Introduction to Ancient DNA",
    "section": "2.1 Lecture",
    "text": "2.1 Lecture\nLecture slides and video from the 2022 edition of the summer school.\n\n\nPDF version of these slides can be downloaded from here."
  },
  {
    "objectID": "introduction-to-ancient-dna.html#questions-to-think-about",
    "href": "introduction-to-ancient-dna.html#questions-to-think-about",
    "title": "2  Introduction to Ancient DNA",
    "section": "2.2 Questions to think about",
    "text": "2.2 Questions to think about\n\nWhat is ancient DNA?\nWhere do we find ancient DNA from microbes?\nHow does DNA degrade?\nHow do I interpret a DNA damage plot?\nHow is DNA damage used to authenticate ancient genomes and samples?\nWhat methods are available for managing DNA damage?\nHow does DNA damage matter for my analyses?"
  },
  {
    "objectID": "introduction-to-metagenomics.html#introduction",
    "href": "introduction-to-metagenomics.html#introduction",
    "title": "3  Introduction to Metagenomics",
    "section": "3.1 Introduction",
    "text": "3.1 Introduction"
  },
  {
    "objectID": "introduction-to-metagenomics.html#lecture",
    "href": "introduction-to-metagenomics.html#lecture",
    "title": "3  Introduction to Metagenomics",
    "section": "3.2 Lecture",
    "text": "3.2 Lecture\nLecture slides and video from the 2022 edition of the summer school.\n\n\nPDF version of these slides can be downloaded from here."
  },
  {
    "objectID": "introduction-to-metagenomics.html#questions-to-think-about",
    "href": "introduction-to-metagenomics.html#questions-to-think-about",
    "title": "3  Introduction to Metagenomics",
    "section": "3.3 Questions to think about",
    "text": "3.3 Questions to think about\n\nWhat is a metagenome? a microbiota? a microbiome?\nWhat is ancient metagenomics?\nWhat challenges do DNA degradation and sample decay pose for ancient metagenomics\nHow do you find out “who’s there” in your samples?\nHow do alignment based and k-mer based taxonomic profilers differ? What are the advantages and disadvantages of each?\nWhy does database selection matter?\nHow do you estimate the preservation and integrity of your ancient metagenome?\nWhat are tools you can use to identify poorly preserved samples and remove contaminant taxa?\nWhat aspects of diversity are important in investigating microbial communities?\nWhich distance metrics are commonly used to compare the beta-diversity of microbial communities and why? What are some advantages and disadvantages to these different approaches?"
  },
  {
    "objectID": "introduction-to-microbial-genomics.html#lecture",
    "href": "introduction-to-microbial-genomics.html#lecture",
    "title": "4  Introduction to Microbial Genomics",
    "section": "4.1 Lecture",
    "text": "4.1 Lecture\nLecture slides and video from the 2022 edition of the summer school.\n\n\n\n\n\n\nWarning\n\n\n\nSlides and videos are from previous version of summer school and may not match text\n\n\n\n\nPDF version of these slides can be downloaded from here."
  },
  {
    "objectID": "introduction-to-microbial-genomics.html#introduction",
    "href": "introduction-to-microbial-genomics.html#introduction",
    "title": "4  Introduction to Microbial Genomics",
    "section": "4.2 Introduction",
    "text": "4.2 Introduction\nMicrobial genomics is the identification and study of microbial genomes, their structure and composition. Microbial species come from diverse groups of organisms but are generally defined as organisms which are not visible to the naked eye. Most prominent amongst them are bacteria, which are single-celled prokaryotes with either circular and linear dsDNA genomes (up to ~14 Mbp). Archaea are mostly mutualistic or commensal single-celled prokaryotes with circular dsDNA genomes (~0.5 to ~5.8 Mbp). The often references group of protozoa, is a not phylogenetically defined grouping (often used in databases). They are a wide variety of free-feeding single-celled eukaryotes from the protists group with larger genomes (~2.9 to ~160 Mbp). \nFinally, viruses are understood as microbial organisms, even though they are not technically considered as “organisms”. Viruses lack the ability to live or replicate independently of host cells. They are mostly defined as infectious agents and have smaller linear or circular ssDNA, dsDNA & RNA genomes (2 kb to over 1 Mb). Finally, another category of viruses are retroviruses. These will usually be RNA viruses which can integrate into the host genome by converting to DNA. But there are also DNA viruses, which integrate into the human genome. There the virus can either be latent and be later triggered to activate, continuously produce virions or lose the ability to produce virions and become part of the host genome. An integrated genome is called a provirus and vertically inherited proviral sequences are called endogenous retroviruses (ERVs).\nThere are several types of microbial organisms found within ancient DNA samples of animal hosts. \n\nPathogens: infectious microorganisms or agents which cause disease in the infected host. Usually specialized organisms which\nCommensals: non-infectious microorganisms or agents which live within a host/environment without causing harm and can be beneficial.\nEnvironmental microorganisms: Environmental microbial organisms not endogenous to the host ante-mortem, which e.g. stem from the depositional environment, the storage environment or the lab.\n\nHowever, it should be noted that not all cases are quite as clear-cut as there are wide varieties of microbial lifestyles. Some organisms can be considered pathogenic in one sampling location and commensal in the next (pathobionts). Some organisms can also be considered harmful, when they are represented in very large amounts or in combination with other organisms. The sampling location can therefore be important information when studying the health of hosts."
  },
  {
    "objectID": "introduction-to-microbial-genomics.html#larger-genomic-elements",
    "href": "introduction-to-microbial-genomics.html#larger-genomic-elements",
    "title": "4  Introduction to Microbial Genomics",
    "section": "4.3 Larger Genomic Elements",
    "text": "4.3 Larger Genomic Elements\nWhen using reference sequences from public depositories such as NCBI you will often be confronted with multiple intervals which represent the chromosome(s) and additional extrachromosomal sequences associated with a species or strain. A chromosome is understood as the main genetic element. It contains the core genome with all essential genetic elements, which usually remain the same across a species.\nPlasmids, on the other hand, are extrachromosomal DNA replicons. They are replicating and acquiring/losing genetic material independently of the chromosome and can be present in high copy numbers. Plasmids can be vertically or horizontally transferred. The number of plasmids of a bacterium varies a lot (0 to 30+), and can vary within a species. They can carry virulence genes and genes which can give selective advantages. Plasmids generally have much smaller circular genomes (1 to over 400 Kbp). It should be noted that they are under-represented in databases, meaning that they are often ignored during the assembly/sequencing process and thus not present in all reference sequences, even if they could otherwise have been there.\nBesides plasmids, bacteriophages (or phages) are also important extrachromosomal (and sometimes chromosomally integrated) genetic material associated with bacterial genomes. Although they are not considered as part of the genome, and therefore part of reference sequences, if they are not integrated in host cell genome. Bacteriophages are dsDNA viruses of small size that infect bacteria. As phages have mostly dsDNA genomes, they are also well suited for the recovery using standard aDNA techniques. They can be found everywhere and carry gene sets of diverse size and composition. They enter the cytoplasm of bacteria, where they can then replicate. There are a huge number of phages, and some are specific to certain bacterial genera or species, which can be useful for identifying taxa or phylogenetic clades. When bacteriophage genomes integrate into the host cell chromosomal genome (e.g. through horizontal gene transfer) or exist as a plasmid within the bacterial cell, they are called prophages."
  },
  {
    "objectID": "introduction-to-microbial-genomics.html#sampling-sequencing",
    "href": "introduction-to-microbial-genomics.html#sampling-sequencing",
    "title": "4  Introduction to Microbial Genomics",
    "section": "4.4 Sampling & Sequencing",
    "text": "4.4 Sampling & Sequencing\nFor ancient DNA samples, screenings for organisms of interest is usually performed on “shotgun” sequencing data, which can then be either further gnomically analysed following species identification or the library will be enriched for organisms identified during screening. Prior to sequencing laboratory workflows, and particularly library building setups, can have a major impact on your final output (e.g. if you are interested in RNA/ssDNA viruses but have dsDNA libraries).\nEach pathogen is subject to tissue tropism, meaning that each species will have a range of cells or tissue types it will preferentially or exclusively proliferate and replicate in. This phenomenon is called tissue tropism. In some instances, the pathogen can also become latent within said tissues, meaning it will remain within the host tissue without causing disease. Organisms which cause bacteremia or viremia, meaning they are present in the bloodstream, will not be as restricted and are generally considered easier to detect. Although this can be limited by the disease phenotype or the stage of infection (e.g. Haemophilus influenzae).\nAccordingly, what organism you can find is highly dependent on the sample and where it was taken from. For example, if the organism of interest enters the bloodstream, teeth, which are vascularized and are excellent DNA archives, will probably be a good choice for sampling. Some pathogens (e.g. Mycobacterium leprae) are present in higher quantities within lesions caused by their infections, making those lesions better suited for sampling. In the case of infections, which are unlikely to be retrievable from hard tissue, calcified nodules can be an interesting type of sample. Bone will generally be less well suited, with some exceptions. Integrated viruses and retroviruses will be likelier to be found in samples types with higher host DNA, such as the petrous bone or the ossicles. And early childhood infection can also be found within low remodelling cortical bone. \n\n\n\n\n\n\nSome Myths to Dispel…\n\n\n\n\nMicrobial content and pathogen content is NOT directly correlated to human DNA content. Human DNA content is not a measure for overall sample preservation. You can have really bad samples for human DNA but get a full microbial genome from the same sample!\nYou can also find microbial signatures in petrous bones etc. it will just be a different range of organisms. Everything is worth getting screened!\n\n\n\nThe typical number of sequences recovered for an organism will depend on a range of factors which can only rarely be predicted even in samples for which osteology/historical record show a clear association with a pathogen. Major factors are: overall sample preservation, depth of Sequencing, abundance of the organism peri-mortem, disease phenotype, genome size & composition, “noise” from other organism, etc.\nOverall, it is considered a good result if your target organism makes out around 0.1% of shotgun datasets, but in many cases it will be way less. However, depending on the organism, the amount of data you need to confidently classify it will be very different, mostly due to sequence conservation and genome size and complexity. While a bacterium is generally easier to detect, their large genome size and sequence conservation, makes them harder to verify. On the other hand, viruses, having much smaller genomes, are harder to detect, especially at low sequencing depth, but generally easier to verify within a margin of uncertainty.\nFor some applications in microbial genomics, unselective/biased sequencing can be key, and this shotgun sequencing is a powerful tool at our disposal since it allows for the indiscriminate sequencing of all DNA found within the sample. Particularly in cases of organisms with large pangenomes, where you might be interested in looking for a large variety of intervals, which would be very costly to do using target enrichment. Or in cases where novel insights and genomes become relevant following the design of a target enrichment kit. Additionally, it allows for the simultaneous analysis of both microbial and host DNA. Understanding the composition of the microbial community of your sample can also be highly relevant with regard to identifying co-infectants, reconstructing disease histories and excluding gene intervals which could also stem from organisms found commensally or contaminants.\n\n\n\n\n\n\nShotgun sequencing for microbial genomics:\n\n\n\nPro(s):\n\nNon-targeted taxa can be found.\nAllows the analysis of both microbial organisms and host simultaneously\nAllows you to detect untargeted co-infections.\nAllows you to understand the composition of the microbial community (can be relevant for genomic analysis).\nNo knowledge of the taxon genomic diversity is needed beforehand\nEnables the long time use of the data with ever growing databases.\n\nCon(s):\n\nCan be much more expensive (depending on the sample).\nOverall less effective at generating adequate/high coverage data.\n\n\n\nHowever, microbial species make up only very small fractions of a genomic libraries. So small that it can either be impossible or very expensive to try to assemble a genome using only shotgun data in most circumstances. In most cases the baits needed for capture are custom designed for each study. The design of such kits necessities appropriate knowledge of the genetic diversity to be expected during analysis. In most cases a mixture of shotgun and target enrichment can be most effective, especially with regards to authentication if enrichment is performed on UDG/Half-UDG genomic libraries.\n\n\n\n\n\n\nTarget enrichment for microbial genomics:\n\n\n\nPro(s):\n\nMuch cheaper per genome, especially in samples with bad preservation.\nEffective at generating high coverage genomes.\nAllows for the generation of large number of genomes effectively.\nGreat for core-genome reconstructions.\n\nCon(s):\n\nNecessitates knowledge of the genetic diversity relevant to your research questions during the design phase.\nAny sequence not included, within a margin of variation, will not be captured.\nWill not generate any data with regards to the host or the rest of the microbial community ( in fact that is the point).\nFor some species capturing the pangenome would be extremely expensive provided it doesn’t fully exceeds kit sizes."
  },
  {
    "objectID": "introduction-to-microbial-genomics.html#validating-the-presence-of-organisms-of-interest",
    "href": "introduction-to-microbial-genomics.html#validating-the-presence-of-organisms-of-interest",
    "title": "4  Introduction to Microbial Genomics",
    "section": "4.5 Validating the Presence of Organisms of Interest",
    "text": "4.5 Validating the Presence of Organisms of Interest\nFollowing analysis of your data using appropriate databases and taxonomic classifiers, it is time to validate your hit. The results of a classifier should not be your end result. Properly validating the presence of a species is key to any genomic analysis! An identification by classifiers is not a sufficient validation on its own, as it can be very tricky to work around false-positive hits and missing database entries. Databases are biased towards pathogenic species, as they represent the bulk of research. Closely non-pathogenic species will either be represented less or not at all, which leads to high read assignments to the LCA (Lowest Common Ancestor) and pathogenic taxa. You should also consider whether it makes biological sense for the species you found to be detected in the samples tissue and based on your laboratory workflow.\nFor ancient DNA, the validation will often consist of three steps:\n\nAuthentication of the data as aDNA using deamination signatures.\nComparative or competitive mappings to relevant reference sequences (target organism and closely related environmental/commensal species).\nIdentification of intervals specific to the target species or sub-species.\n\n\n\n\n\n\n\nTip\n\n\n\nIt can also be a good idea in some cases to double check the modern data you are using during your analysis. There are cases in which the metadata doesn’t match reality.\n\n\nIncreased coverage in selected intervals in an alignment is often cause by sequence conservation. Meaning that you could have the same number of reads mapping to a genome but in the first case all reads are mapping to 5% of the genome with high depth of coverage, whether in the other one you will see low coverage across the whole sequence. The first one is likely to be a false positive, and your detection is based on intervals from either a commensal or an environmental organism which have very high sequence similarity to the ones in your reference genome. This can be further worsened by low complexity intervals. These peaks will usually also reflect in the edit distance, as such tiling will also result in more sequence mismatches. While this can be reduced with higher mapping stringency, this in turn will probably decrease your coverage significantly and in some cases this can cause a reference bias. However, in most cases, these intervals will not pass the mapping quality filter.\n\n\n\n\n\n\nDefinition\n\n\n\nConserved Intervals: Regions of genomes common to organisms from the same taxonomic units (can affect all taxonomic ranks and child taxa and can affect very distantly related organisms). They will show high sequence similarity and cause noise/contamination within the analysis, particularly for ancient DNA.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn many cases, running a range comparative and/or competitive mappings to closely related species is advised in order to exclude a misidentification and the presence of multiple species with similar sets of genes in your dataset (e.g. Neisseria meningitidis). It can also be useful to use multiple reference sequences per species if it has multiple phylogenetically strongly delimited clades (e.g. H. influenzae)\n\n\nViruses are less affected, as they do not carry house-keeping genes, and only have a very small usually highly specialized set of genes, which makes them easier to validate. However, viral sequencing of non-pathogenic species has only recently started to become more popular due to metagenomic studies, i.e. non-pathogenic taxa are even more under-represented, and many viral genomes have low complexity repeats over large portions of their sequence.\nFinally, intervals or mutations specific to the target organism should be identified and investigated. This can range from plasmids, genes, phages to specific mutations. Often a combination of these factors is required to confidently validate the presence of the organism. This step should not be overlook as this will not always be clearly visible in a phylogeny, depending on the composition of the alignment used."
  },
  {
    "objectID": "introduction-to-microbial-genomics.html#genomes",
    "href": "introduction-to-microbial-genomics.html#genomes",
    "title": "4  Introduction to Microbial Genomics",
    "section": "4.6 Genomes",
    "text": "4.6 Genomes\n\n\n\n\n\n\nStrains VS Genomes\n\n\n\n\nA strain is a genetic variant or subtype of a species or sub-species. They usually exhibit significant genetic differences to other strains of the same taxonomic unit. The level of change required for significance can vary.\nA genome can be the exact copy of an already sequenced strain.\n\nThe case of aDNA: Since our samples are so old, most of our genome constitute new strains. However, caution is advised. Particularly with clonal species (e.g. Black Death genomes).\n\n\nThat are many different microbial species and they all have very different evolutionary dynamics and genomes. This means that depending on which species you are working on, you mig\nMapping is an important tool in ancient DNA to investigate the presence and absence of genomic intervals. However, mapping can be impeded by the reference sequence itself. Gene duplication, low complexity sequences and GC Skew (over- or under-abundance of GC in intervals) can impact the mappability (and mapping evenness) of sequencing reads to the reference sequence and their mapping quality score. Which in turn might be problematic during analysis. This can be expressed in mappability estimates, which estimate how likely it is for short reads to map to a sequence interval based on its composition and uniqueness.\n\n\n\n\n\n\nDefinition\n\n\n\nSequence Complexity: Defined as the observed vocabulary usage for word size. Meaning, how complex is the sequence of nucleotides within an interval. Often given as values calculated using either entropy or DUST algorithms.\n\n\n\n\n\n\n\n\nDefinition\n\n\n\nGC Content: Is usually given as a percentage of guanine and cytosine bases within the sequence. Can impact DNA stability, amplification, sequencing and capture if the GC content is too high or too low. Too high or too low GC-content will also lead to a loss in sequence complexity."
  },
  {
    "objectID": "introduction-to-microbial-genomics.html#recombination",
    "href": "introduction-to-microbial-genomics.html#recombination",
    "title": "4  Introduction to Microbial Genomics",
    "section": "4.7 Recombination",
    "text": "4.7 Recombination\nBacteria and viruses are haploid and have small genome, making some things much easier, but… They like to mix and match! Microbial organisms will exchange genetic material using a range of biological mechanisms (conjugation, transduction, and/or transformation) this leads to increased genetic diversity via horizontal gene transfer. Some parts of the genome will be more heavily affected by this exchange than others. This constant exchange of genetic material can happen while maintaining genome size, meaning that while genes are gained, others are lost. How much recombination a genome will undergo, is highly dependent on the species. These dynamics cause recombination breakpoints in reference based alignments where SNP counts will increase, which can impede phylogenetic analysis (e.g.: by causing elongated branches).\nHowever, some species do not recombine at all or do so only very rarely. These species have clonal genomes, meaning they transfer their entire genome vertically, most the of time, without significant changes to their pangenome or the sequence itself. Actually, many of the species which have been extensively studied using aDNA, fall within this group (e.g. Y. pestis, M. leprae).\nMost microbial organisms change their genomes via recombination and gene loss/gain, while maintaining genome size and retaining their core genome. Virulence is then often defined by gaining or losing virulence factors. However, some increase their virulence by reducing their genome and becoming highly specialized (e.g. Borrelia recurrentis) in what is called reductive evolution. In these cases, it is of interest to include closely related phylogenetically “basal” species (pathogenic or not), which might inform you on genes/plasmids the modern genomes have lost, but the ancestral genomes might have still retained."
  },
  {
    "objectID": "introduction-to-microbial-genomics.html#pangenomes",
    "href": "introduction-to-microbial-genomics.html#pangenomes",
    "title": "4  Introduction to Microbial Genomics",
    "section": "4.8 Pangenomes",
    "text": "4.8 Pangenomes\nAs mentioned microbial organisms can be very plastic and exchange genomic material. This can lead to a wide variety of genes being represented within a single species. Pangenomes represent the sum of all genomic intervals represented within the genomes of one species.\nPangenomes are made up of three groups:\n\nCore Genes: a set of essential genes common to all strains of a species.\nAccessory/Shell Genes: a set of genes common amongst some strains of a species which encode for supplementary or modified biochemical functions.\nSingleton/Unique/Cloud Genes: genes, which are specific to single strains of a species. Unlikely to be recovered and identified using ancient DNA.\n\nWe also differentiate between open and closed pangenomes. In open pangenomes, the gene set available to the bacterium constantly expands by acquisition and loss of genes via horizontal gene transfer from its environment, for the purpose of adaptation (e.g. environmental adaptation, metabolism, virulence and antibiotic resistance). All while maintaining genome size and vertical transmission of the core genome. Closed pangenome have limited exchanges of genetic material. This is often the case in highly specialized organisms."
  },
  {
    "objectID": "introduction-to-microbial-genomics.html#snp-effects",
    "href": "introduction-to-microbial-genomics.html#snp-effects",
    "title": "4  Introduction to Microbial Genomics",
    "section": "4.9 SNP Effects",
    "text": "4.9 SNP Effects\nSingle nucleotide polymorphisms can heavily impact the function genes and the phenotype of an organism when they happen to affect and change the amino acid sequence of coding elements of a genome.\n\n\n\n\n\n\nDefinitions\n\n\n\nNon-synonymous (missense) mutation: SNPs that alters the amino acid sequence of a protein by changing one base of a triplet group.\nFrameshift: Changes in the amino acid sequence caused by insertions or deletions of nucleotides in coding sequences.\nStart/Stop Codon: Nucleotide triplet which signals the beginning and end of translation.\nStop-gain mutation: Mutation which leads to a change in the amino acid sequence and leads to a premature stop of translation. \nStart-loss mutation: Mutation which leads to a change in the amino acid sequence and leads to the loss of a start codon. Leads to the reduction or elimination of protein production.\n\n\nThe impact of such changes is predicted by tracking changes in the translation of coding sequences using a reference sequence and SNP/MNP/Indel calls. The problem when using ancient DNA, is that genome coverage is often uneven, and it isn’t rare to lack full coverage of intervals of interest or lack resolution to correctly call indels across the reference. Larger genomic insertion/ recombination are also not accounted for when a genome is reconstructed solely using a reference based approach. This means that while SNP effects can indeed be very interesting and potentially highly significant, they should be understood as prediction based on the available coverage. It is therefore important to report coverage over the entire coding and promoter intervals, when discussing SNP effect.\nImportant exception are known and heavily conserved mutations, which for example are involved in pseudogenization. Pseudogenization is the process through which genes lose their function due to mutations but remain in the genome without being expressed. It is a mechanism underlying gene loss. They are important in aDNA research because we can capture “active” versions of pseudogenes and potentially date their loss of function. It is an important part of the genome reduction process of highly specialised bacteria.\n\n4.9.1 Virulence Associated Intervals\nOne of the question ancient DNA research is interested in is the evolution of virulence in pathogenic species. The location and nature of virulence factors can vary. An increase in virulence can be caused by gene gain (on chromosomes or plasmids), plasmids, mutations or changes to complex gene mechanisms (e.g. immune evasion).\n\n\n\n\n\n\nTip\n\n\n\n\nAre there loci associated with increased virulence known to the literature?\nAre there phylogenetic groups associated with increased virulence?\n\n\n\nNot all species have evolutionary dynamics which allow us to detect a temporal signal or recognise geographic structure within their phylogenies. However, phylogenetic clades can also inform us on other aspects of their evolution (virulence, ecological niche etc.). When investigating virulence, you should be checking for the presence of chromosomal Virulence factors (genes, mutations), either as a Presence/Absence matrix or a cluster analysis. As well as investigating the presence/absence of plasmids and plasmid mediated virulence factors and functional mechanisms.\nBeyond virulence, some genes and gene combinations can also inform us on changes in disease phenotype and microbial adaptation to host or ecological niche."
  },
  {
    "objectID": "introduction-to-microbial-genomics.html#resources",
    "href": "introduction-to-microbial-genomics.html#resources",
    "title": "4  Introduction to Microbial Genomics",
    "section": "4.10 Resources",
    "text": "4.10 Resources\nSome useful websites:\n\nGenBank NCBI Database: https://www.ncbi.nlm.nih.gov/genbank/\nThe European Nucleotide Archive (ENA): https://www.ebi.ac.uk/ena/browser/home\nThe virulence factor database (VFDB): http://www.mgc.ac.cn/VFs/main.htm\nViral Neighbour Genomes In The Assembly Resource (NCBI): https://www.ncbi.nlm.nih.gov/genome/viruses/about/assemblies/\nNCBI Taxonomic Browser: https://www.ncbi.nlm.nih.gov/taxonomy\nBacDiv: https://bacdive.dsmz.de/\nBacterial And Viral Bioinformatics Resource Center: https://www.bv-brc.org/"
  },
  {
    "objectID": "introduction-to-microbial-genomics.html#questions-to-think-about",
    "href": "introduction-to-microbial-genomics.html#questions-to-think-about",
    "title": "4  Introduction to Microbial Genomics",
    "section": "4.11 Questions to think about",
    "text": "4.11 Questions to think about\nGet to know your genome!\n\nIs the genome circular or linear?\nDoes the species carry any plasmids?\nHow genomically diverse are the genomes of the species?\nDoes the species share large portions of its genome with closely related environmental or commensal microbial organisms? If yes could they also be present in the data?\n\nGet to know your species!\n\nIs the species clonal or heavily recombinant? Overall? Within clades?\nIs the pangenome open or closed? How large is it?\nHas the genome undergone a reductive evolution?\nIs the genome plastic but maintains genome size?\nAre there significant genomic/phenotypic differences across clades?\nIs your samples grouping within modern diversity or basal too it?\n\nDepending on the organism, available data and databases will be very different…\n\nWhat data is available?\nWhat type of data is available?\nWhat metadata is available?"
  },
  {
    "objectID": "introduction-to-evolutionary-biology.html",
    "href": "introduction-to-evolutionary-biology.html",
    "title": "5  Introduction to Evolutionary Biology",
    "section": "",
    "text": "5.0.1 Lecture\nLecture slides and video from the 2022 edition of the summer school.\n\n\nPDF version of these slides can be downloaded from here."
  },
  {
    "objectID": "section-useful-skills.html#introduction-to-the-command-line-bare-bones-bash",
    "href": "section-useful-skills.html#introduction-to-the-command-line-bare-bones-bash",
    "title": "Useful Skills",
    "section": "Introduction to the Command Line (Bare Bones Bash)",
    "text": "Introduction to the Command Line (Bare Bones Bash)\nComputational work in metagenomics often involves connecting to remote servers to run analyses via the use of command line tools. Bash is a programming language that is used as the main command line interface of most UNIX systems, and hence most remote servers a user will encounter. By learning bash, users can work more efficiently and reproducibly on these remote servers.\nIn this chapter we will introduce the basic concepts of bash and the command line. Students will learn how to move around the filesystem and interact with files, how to chain multiple commands together using “pipes”, and how to use loops and regular expressions to simplify the running of repetitive tasks.\nFinally, readers will learn how to create a bash script of their own, that can run a set of commands in sequence. This session requires no prior knowledge of bash or the command line and is meant to serve as an entry-level introduction to basic programming concepts that can be applicable in other programming languages too."
  },
  {
    "objectID": "section-useful-skills.html#introduction-to-r",
    "href": "section-useful-skills.html#introduction-to-r",
    "title": "Useful Skills",
    "section": "Introduction to R",
    "text": "Introduction to R\nR is an interpreted programming language with a particular focus on data manipulation and analysis. It is very well established for scientific computing and supported by an active community developing and maintaining a huge ecosystem of software packages for both general and highly derived applications.\nIn this chapter we will explore how to use R for a simple, standard data science workflow. We will import, clean, and visualise context and summary data for and from our ancient metagenomics analysis workflow. On the way we will learn about the RStudio integrated development environment, dip into the basic logic and syntax of R and finally write some first useful code within the tidyverse framework for tidy, readable and reproducible data analysis.\nThis chapter will be targeted at beginners without much previous experience with R or programming and will kickstart your journey to master this powerful tool."
  },
  {
    "objectID": "section-useful-skills.html#introduction-to-python",
    "href": "section-useful-skills.html#introduction-to-python",
    "title": "Useful Skills",
    "section": "Introduction to Python",
    "text": "Introduction to Python\nWhile R has traditionally been the language of choice for statistical programming for many years, Python has taken away some of the hegemony thanks to its numerous available libraries for machine and deep learning. With its ever increasing collection of libraries for statistics and bioinformatics, Python has now become one the most used language in the bioinformatics community.\nIn this tutorial, mirroring to the R session, we will learn how to use the Python libraries Pandas for importing, cleaning, and manipulating data tables, and producing simple plots with the Python sister library of ggplot2, plotnine.\nWe will also get ourselves familiar with the Jupyter notebook environment, often used by many high performance computing clusters as an interactive scripting interface.\nThis chapter is meant for participants with a basic experience in R/tidyverse, but assumes no prior knowledge of Python/Jupyter."
  },
  {
    "objectID": "section-useful-skills.html#introduction-to-git-and-github",
    "href": "section-useful-skills.html#introduction-to-git-and-github",
    "title": "Useful Skills",
    "section": "Introduction to Git and GitHub",
    "text": "Introduction to Git and GitHub\nAs the size and complexity of metagenomic analyses continues to expand, effectively organizing and tracking changes to scripts, code, and even data, continues to be a critical part of ancient metagenomic analyses. Furthermore, this complexity is leading to ever more collaborative projects, with input from multiple researchers.\nIn this chapter, we will introduce ‘Git’, an extremely popular version control system used in bioinformatics and software development to store, track changes, and collaborate on scripts and code. We will also introduce, GitHub, a cloud-based service for Git repositories for sharing data and code, and where many bioinformatic tools are stored. We will learn how to access and navigate course materials stored on GitHub through the web interface as well as the command line, and we will create our own repositories to store and share the output of upcoming sessions."
  },
  {
    "objectID": "bare-bones-bash.html#lecture",
    "href": "bare-bones-bash.html#lecture",
    "title": "6  Introduction to the Command Line",
    "section": "6.1 Lecture",
    "text": "6.1 Lecture\nLecture slides and video from the 2022 edition of the summer school.\n\n6.1.1 Session 1\nThis is the Brief version of a more Broad two-part session that we gave in 2022, which can be found here.\nThe teaching material for the Boundless Bare Bones Bash (Basic + Boosted) can be found in the Bare Bones Bash website.\n\n\n\nBareBonesBash Logo\n\n\nThe original Bare Bones Bash material was created by Aida Andrades Valtueña, James Fellows Yates, and Thiseas C. Lamnidis.\n\n\n  \n\nThe author portraits were designed by Zandra Fagernäs.\n\n\n\n\n\nAll material is provided under a Creative Commons Attribution-ShareAlike 4.0 International License.\n\n\n6.1.2 tl;dr\n\nBelow is a quick reference guide to the commands discussed in this tutorial. To understand actually what each command does, carry on reading below! For a complete run of all these commands AND MORE(!!), consider following the full Bare Bones Bash walkthroughs here.\n\n\n\ncommand\ndescription\nexample\ncommon flags or arguments\n\n\n\n\npwd\nprint working directory\npwd\n\n\n\nls\nlist contents of directory\nls\n-l (long info)\n\n\nmkdir\nmake directory\nmkdir pen\n\n\n\ncd\nchange directory\ncd ~/pen\n~ (home dir), - (previous dir)\n\n\nssh\nlog into a remote server\nssh @.com\n-Y (allows graphical windows)\n\n\nmv\nmove something to a new location (& rename if needed)\nmv pen pineapple\n\n\n\nrmdir\nremove a directory\nrmdir pineapple\n\n\n\nwget\ndownload something from an URL\nwget www.pineapple.com/pen.txt\n-i (use input file)\n\n\ncat\nprint contents of a file to screen\ncat pen.txt\n\n\n\ngzip\na tool for dealing with gzip files\ngzip pen.txt\n-l (show info)\n\n\nzcat\nprint contents of a gzipped file to screen\nzcat pen.txt.gz\n\n\n\nwhatis\nget a short description of a program\nwhatis zcat\n\n\n\nman\nprint the man(ual) page of a command\nman zcat\n\n\n\nhead\nprint first X number of lines of a file to screen\nhead -n 20 pineapple.txt\n-n (number of lines to show)\n\n\n|\npipe, a way to pass output of one command to another\ncat pineapple.txt | head\n\n\n\ntail\nprint last X number of lines of a file to screen\ntail -n 20 pineapple.txt\n-n (number of lines to show)\n\n\nless\nprint file to screen, but allow scrolling\nless pineapple.txt\n\n\n\nwc\ntool to count words, lines or bytes of a files\nwc -l pineapple.txt\n-l (number of lines not words)\n\n\ngrep\nprint to screen lines in a file matching a pattern\ngrep pineapple.txt | grep pen\n\n\n\nln\nmake a (sym)link between a file and a new location\nln -s pineapple.txt pineapple_pen.txt\n-s (make symbolic link)\n\n\nnano\nuser-friendly terminal-based text editor\nnano pineapple_pen.txt\n\n\n\nrm\nmore general ‘remove’ command, including files\nrm pineapple_pen.txt\n-r (to remove directories)\n\n\n$VAR\nDollar sign + text indicates the name of a variable\n$PPAP\n\n\n\necho\nprints string to screen\necho “$PPAP”\n\n\n\nfor\nbegins ‘for’ loop, requires ‘in’, ‘do’ and ‘done’\nfor p in apple pineapple; do  echo “$p$PPAP”; done  applePen pineapplePen\n\n\n\nfind\nsearch for files or directories\nfind -name ‘pen’\n-type f (search only for files) -name ’*JPG’ (search for file names matching the pattern)\n\n\n“$var”\nuse double quotes to use contents of variable\npen=apple && echo “$pen”\n\n\n\n&lt;&gt;2&gt;\nredirects the standard input/output/error stream respectively into a file\ncat &lt;file.txt &gt;file_copy.txt 2&gt;cat_file.err\n\n\n\n\n\n\n\n6.1.3 Introduction\nThe aim of this tutorial is to make you familiar with using bash everyday… for the rest of your life! More specifically, we want to do this in the context of bioinformatics. We will start with how to navigate around a filesystem in the terminal, download sequencing files, and then to manipulate these. Within these sections we will also show you simple tips and tricks to make your life generally easier.\nThis tutorial is designed so you follow along on any machine with a UNIX terminal (no warranty provided).\n\n\n6.1.4 The 5 commandments of Bare Bones Bash\nThe Bare Bones Bash philosophy of learning to code follows five simple commandments:\n\n\n\n\n\n\n\n1) Be lazy!\nDesire for shortcuts motivates you to explore more!\n\n\n2) Google The Hive-Mind knows everything!\n99% of the time, someone else has already had the same issue.\n\n\n3) Document everything you do!\nMake future you happy!\n\n\n4) There will ALWAYS be a typo!\nDon’t get disheartened, even best programmers make mistakes!\n\n\n5) Don’t be afraid of you freedom!\nExplore! Try out things!\n\n\n\n\n\n\n\n\n\nPro Tip\n\n\n\nRemember: No one writes code that works first time, or without looking at StackOverflow sooner or later.\n\n\n\n\n6.1.5 What is a terminal?\nA terminal is simply a fancy window that allows you to access the command-line interface of a computer or server.\nThe command-line itself is how you can work on the computer with just text.\nbash (bourne again shell) is one of the most popular languages used in the terminal.\n\n\n6.1.6 Understanding the command prompt\n\n\n\nAn example command prompt\n\n\nAfter opening the terminal what you will normally see is a blank screen with a ‘command prompt’, like the one shown above. This typically consists of your username, the device name, a colon, a directory path and ends with a dollar symbol. Like so:\n&lt;username&gt;@&lt;device_name&gt;:~$\nThe commmand prompt is never involved in any command, it is just there to ensure you know who and where you are. When copying a command you should NOT copy the command prompt.\nOften times, when looking for commands online, the commands ran will pe prefaced with a $. This is a stand-in for the command prompt. When adding multi-line commands, it is also common to preface the additional lines with a &gt;. When copying such commands it is therefore important to remove these characters from the start of each line (if present).\nFinally, in this tutorial, the symbols&lt;&gt; are used to show things that will/should be replaced by another value. For example, in Thiseas’ command prompt &lt;username&gt; will be replaced by lamnidis, as that is his username.\nNow back to your prompt: It tells you that you are in the directory ~. The directory ~, stands for your home directory. Note that this shorthand will point to a different place, depending on the machine and the user.\nIf you want to know what the shorthand means, (here comes your first command!) you can type in pwd, which stands for “print working directory”. Your “working directory” is whichever directory you are currently in.\npwd\n/home/ubuntu\nThis prints the entire “filepath” of the directory i.e. the route from the “root” (the deepest directory of the machine), through every subdirectory, leading to your particular working directory.\n\n\n6.1.7 Absolute vs Relavtive paths\nFilepaths (a.k.a. “paths”), come in two flavours. Let’s talk a bit about them!\n\nAn absolute path will start with the deepest directory in the machine shown as a /. Paths starting with ~ are also absolute paths, since ~ translates to an absolute path of your specific home directory. That is the directory path you see in the output of the pwd command you just ran.\nAlternatively a relative path always begins from your working directory (i.e. your current directory). Often this type of path will begin with one (./) or two (../) dots followed by a forward slash, but not always. In the syntax of relative pathways . means “the current directory” and .. means “the parent directory” (or the ‘one above’).\n\n\n6.1.7.1 A real life analogy for paths\nYou have just arrived to Leipzig for a summer school that is taking place at MPI-EVA. After some questionable navigation, you find yourself at the Bayerische Bahnhof. Tired and disheartened, you decide to ask for help.\nYou see a friendly-looking metalhead, and decide to ask them for directions!\n\n\n\nA friendly-looking metalhead.\n\n\n\nHappy to help, but I only give directions in absolute paths!\nFrom Leipzig Main Station, you should take Querstraße southward.\nContinue straight and take Nürnberger Str. southward until you reach Str. des 18 Oktober.\nFinally take Str. des 18 Oktober. moving southeast until you reach MPI-EVA!\n\n\n\n\n\n\n\nAbsolute paths\n\n\n\nThe directions above are equivalent to an absolute path, because they will ALWAYS take you to MPI-EVA, but you can only apply these directions if you start from Leipzig Main Station!\nExamples of absolute paths:\n/home/ubuntu\n/Leipzig_Main_Station/Querstraße/Nürnberger_Str/Str_18_Oktober/Deutscher_Platz/MPI-EVA\n\n\nNot sure how to get back to Leipzig Main Station to apply those directions, you decide to ask someone else for directions…\nLucky for you, a friendly looking local is passing by!\n\n\n\nA friendly-looking local.\n\n\n\nYou’re currently on Str. des 18 Oktober. Walk straight that way, past the tram tracks, and you will find Deutscher Platz. You will see MPI-EVA to your right!\n\n\n\n\n\n\n\nRelative paths\n\n\n\nThese directions are equivalent to a relative path! They are easy to follow, but only work when you happen to start at the position you were in when you first got the directions!\nExamples of relative paths:\n./my_directory/my_file.txt\n../Str_18_Oktober/Deutscher_Platz/MPI-EVA\n\n\n\n\n\n6.1.8 Basic commands\nWe will now explore some basic commands that you will use to explore folders and interact with files:\n\nlist directory contents:\n\nls\nOutput should look like:\nDesktop    Downloads  Pictures  Templates  bin    snap\nDocuments  Music      Public    Videos     cache  thinclient_drives\n\n\n\n\n\n\nNote\n\n\n\nWe will use this format to show you commands and their corresponding output in the terminal (if any) for the rest of this chapter.\n\n\n\nmake a directory:\n\nmkdir barebonesbash\n\nmove (or rename) files and directories\n\nmv barebonesbash BareBonesBash\n\nchange directories\n\ncd BareBonesBash\n\nDownload (www get) a remote file to your computer\n\nwget git.io/Boosted-BBB-meta\n\ncopy a file or directory to a new location\n\ncp Boosted-BBB-meta Boosted-BBB-meta.tsv\n\nremove (delete) files\n\nrm Boosted-BBB-meta\n\nConcatenate file contents to screen\n\ncat Boosted-BBB-meta.tsv\n\nSee only the first/last 10 lines of a file\n\nhead -n 10 Boosted-BBB-meta.tsv\ntail -n 10 Boosted-BBB-meta.tsv\n\n\n\n\n\n\nNote\n\n\n\nThis is because the start of a cat is its head and the end of the cat is its tail (The great humor of computer scientists)\n\n\n\nLook at the contents of a file interactively (less than the complete file, press q to quit)\n\nless Boosted-BBB-meta.tsv\n\nword count the number of lines (-l) in a file\n\nwc -l Boosted-BBB-meta.tsv\n15 Boosted-BBB-meta.tsv\n\n\n6.1.9 Datastreams, piping, and redirects\nEach of the commands you learned above is a small program with a very specialised functionality. Programs come in many forms and can be written in various programming languages, but most of them share some features. Specifically, most programs take some data in and spit some data out! Here’s how that works, conceptually:\n\n6.1.9.1 Datastreams\nComputer programs can take in and spit out data from different streams. By default there are 3 such data streams.\n\nstdin : the standard input\nstdout: the standard output\nstderr: the standard error\n\n\n\n\n\n\n\n\n\n\n\n\nPro Tip\n\n\n\nEach programme also has an ‘exit code’, which can tell you if execution completed with/without errors. You will rarely see these in the wild.\n\n\nTypically, the stdin is where the input data comes in.\nThe stdout is the actual output of the command. In some cases this gets printed to the screen, but most often this is the information that needs to be saved in an output file.\nThe stderr is the datastream where errors and warnings go. This gets printed to your terminal to let you know when something is not going according to plan!\n\n\n\nThis program takes no input, and prints one line to the stdout and one line to the stderr.\n\n\n\n\n6.1.9.2 Piping\nA “pipe” (|) is a really useful feature of bash that lets you chain together multiple commands! When two commands are chained together with a pipe, the stdout of the first command becomes the stdin of the second! The stderr is still printed on your screen, so you can always know when things fail.\n\n\n\n\n\nExample:\nhead -n 10 Boosted-BBB-meta.tsv | tail -n1\nnetsukeJapan    C       Artwork\nThe above command will only show the 10th line of Boosted-BBB-meta.tsv. The way it works is that head will take the first 10 lines of the file. These lines are then passed on to tail which will keep only the last of those lines.\n\n\n6.1.9.3 Redirects\nMuch like streams of water in the real world, datastreams can be redirected.\nThis way you can save the stdout of a program (or even the stderr) into a file for later!\n\nstdin can be redirected with &lt;.\n\nAn arrow pointing TO your program name!\n\nstdout can be redirected with &gt;.\n\nAn arrow pointing AWAY your program name!\n\nstderr can be redirected with 2&gt;.\n\nBecause it is the secondary output stream.\n\n\n\n\n\n\n\n\nPro Tip\n\n\n\nIt is also possible to combine streams, but we won’t get into that here.\n\n\nExample:\nhead -n 10 Boosted-BBB-meta.tsv | tail -n1 &gt; line10.txt\nThis will create a new file called line10.txt within your work directory. Using cat on this file will BLOW YOUR MIND - (GONE WRONG)!\n\n(Don’t forget to like and subscribe!)\n\ncat line10.txt\nnetsukeJapan    C       Artwork\n\n\n\nHere you can see an example of redirecting the output of the datastreams_demo.sh program from before. Redirecting the stdout with &gt; only prints the stderr to the screen, and saves the stdout into output.txt. Additionally, we can redirect the stderr with 2&gt; into runtime.log, and then nothing is printed onto the screen.\n\n\n\n\n\n6.1.10 Helptext\nYou don’t always have to google for documentation! Many programs come with in-built helptext, or access to online manuals right from your terminal!\n\nYou can get a one sentence summary of what a tool does with whatis\n\nwhatis cat\ncat(1)  - concatenate files and print on the standard \n          output\n\nWhile man gives you access to online manuals for each tool (exit with q)\n\nman cat\n\n\n6.1.11 Variables\nVariables are a central concept of all programming. In short, a variable is a named container whose contents you can expand at will or change.\nYou can assign variables (tell the computer what do you want it to contain) with = and pull their contents with $\nThe easiest way to see the contents of a varable is using echo!\necho \"This is my home directory: $HOME\"\nThis is my home directory: /home/ubuntu\n$HOME is a varible of the type called environment variables, which are set the moment you open your terminal or log into a server, they ensure the system works as intended and should not be change unless you are very sure of why.\n\n\n\n\n\n\nEnvironment Variables\n\n\n\nEnvironment variables in bash are typically named in all capital letters. It is a good idea to avoid using only capital letters for your variable names, so you avoid accidentally overwriting any environment variables.\n\n\nBut as mentioned, you can store in a variable anything you want, so let’s see a few examples:\nFirst let’s try to store a number:\nGreekFood=4            #Here, 'GreekFood' is a number.\necho \"Greek food is $GreekFood people who want to know what heaven tastes like.\"\nGreek food is 4 people who want to know what heaven tastes like.\n\n\n\n\n\n\nNote\n\n\n\nThe # is used to add comments to your code. Comments are annotations that you write in your code to understand what it is doing but that the computer does not run. Very useful for when your future self or another person looks at your code\n\n\nNow let’s store a word (“string”):\nGreekFood=delicious   #We overwrite that number with a word (i.e. a 'string').\necho \"Everyone says that Greek food is $GreekFood.\"\nEveryone says that Greek food is delicious.\nYou can also store more than a single word (that is still a “string”):\nGreekFood=\"Greek wine\" #We can overwrite 'GreekFood' again, \n## but when there is a space in our string, we need quotations.\necho \"The only thing better than Greek food is $GreekFood!\"\nThe only thing better than Greek food is Greek wine!\nSince variables can be reset to whatever you want, you can also store a number again:\nGreekFood=7 #And, of course, we can overwrite with a number again too.\necho \"I have been to Greece $GreekFood times already this year, for the food and wine!\"\nI have been to Greece 7 times already this year, for the food and wine!\n\n\n\n\n\n\nOverwriting variables\n\n\n\nIn this examples you have seen how the same variable has been overwritten, this means that you can only access the last content that you stored in the variable. All the previous contents that a variable may have had are innaccessible as soon as the same variable is given a new value.\n\n\n\n\n6.1.12 Quotes matter!\nIn bash, there is a big difference between a single quote ' and a double quote \"!\n\nThe contents of single quotes, are passed on as they are.\nInside double quotes, contents are interpreted!\n\nIn some cases the difference doesn’t matter:\necho \"I like Greek Food\"\necho 'I like Greek Food'\nI like Greek Food\nI like Greek Food\nIn other cases it makes all the difference:\nArr=\"Banana\"\necho 'Pirates say $Arr'\necho \"Minions say $Arr\"\nPirates say $Arr\nMinions say Banana\nWhy does it make a difference in the second example?\nThis is because in the second example we are using a variable. We have assigned Banana to the variable $Arr. As mentioned above, when single (') quotes are used the computer just prints what it receives without caring that $Arr is a variable.\nIn the echo with the double (\") quotes we are telling the computer to extract the value from the variable $Arr and that is why we see the store value (Banana) in the printed output in the terminal.\n\n\n6.1.13 Find\nYou can also ask your computer where you have put your files, in case you forgot. To do this you can use find! The find command has the following syntax:\n\nfind /your/folder/ -type f -name 'your_file.txt'\n\nFirst part of the find command: the place to look from\n\ne.g. . to indicate ‘here’\nCould also use ~/\nCould use absolute path e.g. /home/james/\n\nSecond part of the find command: what type of things to look for?\n\nUse -type to define the filetype:\n\nfile\ndirectory\n\n\nThird part of the find command: what to look in?\n\nUse -name to say ‘look in names of things’\n\nFinally after -name we give the the ‘strings’ to search for\n\nUse wildcards (*) for maximum laziness!\n\n\nNow let’s put into practise what you have learnt about find.\nFor that you will download a messy folder from a collaborator, remember to check you are in the BareBonesBash folder!:\nwget git.io/Boosted-BBB-images -O Boosted-BBB.zip\nWe realise that this is a compressed file, and more precisely is a zip file (extension .zip). In order to access to its content we will need to “unzip” it first. For that we can use the command unzip:\nunzip Boosted-BBB.zip\nWe know that our collaborator has shared with us some pictures from animals that we need to use for our research, and according to your collaborator they are marked with JPG. We first try to check the contents of the directory to find them quickly.\nls Boosted-BBB\nAnd        Digging       Friday     Leave      Only     Where    Young\nAnybody    Everything    Getting    Looking    Ooh      With     Youre\nDancing    Feel          Having     Night      Watch    You\nWow, what a mess! How would you retrieve all the files? Thanks to your wonderful teachers you have learnt how to use find and can simply run:\nfind Boosted-BBB -type f -name '*JPG*' \nBoosted-BBB/Having/the/time/of/your/life/bubobubo.JPG.MP3.TXT\nBoosted-BBB/With/a/bit/of/rock/music/exhibitRoyal.JPG.MP3.TXT\nBoosted-BBB/Friday/night/and/the/lights/are/low/fanta.JPG.MP3.TXT\nBoosted-BBB/Everything/is/fine/nomnom.JPG.MP3.TXT\nBoosted-BBB/Getting/in/the/swing/giacomo.JPG.MP3.TXT\nBoosted-BBB/Youre/in/the/mood/for/a/dance/snore.JPG.MP3.TXT\nBoosted-BBB/Digging/the/dancing/queen/excited.JPG.MP3.TXT\nBoosted-BBB/Anybody/could/be/that/guy/alopochenaegyptiacaArnhem.JPG.MP3.TXT\nBoosted-BBB/And/when/you/get/the/chance/stretch.JPG.MP3.TXT\nBoosted-BBB/Looking/out/for/angry.JPG.MP3.TXT\nBoosted-BBB/Feel/the/beat/from/the/tambourine/oh/yeah/netsukeJapan.JPG.MP3.TXT\nBoosted-BBB/Watch/that/scene/licorne.JPG.MP3.TXT\nBoosted-BBB/You/can/weimanarer.JPG.MP3.TXT\nBoosted-BBB/Night/is/young/and/the/musics/high/bydgoszczForest.JPG.MP3.TXT\nBoosted-BBB/Ooh/see/that/girl/pompeii.JPG.MP3.TXT\nAfter -name we have written '*JPG*', this tells to find to search for any file that contains JPG in any part of its name, indicated by the *. The * are what are known as wildcards. To learn more on how to use them, please refer to the more complete material for this tutorial.\nNow you have all the paths of the files that you will need!\n\n\n6.1.14 For loops\nUntil now we have seen how to run single commands on a file. But, what about when you need to repeat a command multiple times on a list of things, for example a list of files?\nTo repeat an action (command) for a set of things (list, e.g. files) one needs to employ the concept of a loop. One of the most commonly used loops, is the for loop.\nA for loop allows us to go through a list of things and perform some actions. Let’s see an example:\nVariable=Yes\nfor i in Greece Spain Britain; do\n  echo \"Does $i have lovely food? $Variable\"\ndone\nDoes Greece have lovely food? Yes\nDoes Spain have lovely food? Yes\nDoes Britain have lovely food? Yes\nThe for loop went through the list Greece Spain Britain and printed a statement with each item in the list. What happens if we change the order of the list to Britain Greece Spain?\nVariable=Yes\nfor i in Britain Greece Spain; do\n  echo \"Does $i have lovely food? $Variable\"\ndone\nDoes Britain have lovely food? Yes\nDoes Greece have lovely food? Yes\nDoes Spain have lovely food? Yes\nWe see that changing the order of the list will affect the output, this is because the for loop will go through the list in a sequencial manner.\nWe can also add more elements to the list, and the for loop will continue until it reaches the end of the list.\n\n\n6.1.15 How to Google like a pro\nOne of the most important skills you develop when coding and/or using the command line is how to phrase your questions so you can get relevant answers out of your search engine.\nAs Deep Thought put it in the Hitchhiker’s Guide to the Galaxy:\n\nOnly when you know the question will you know what the answer means.\n\nHere are some quick tips to get you started:\n\nALWAYS include the name of the language in your query.\n\nBAD: “How to cat”\nGOOD: “How to cat bash”\n\nBROADEN your question!\n\nBAD: “How to set X to 4 in bash?”\nGOOD: “How to set a variable to an integer in bash?” \n\nWhen you are more familiar, use fancy programmer lingo to make google think you know what you are talking about.\n\n\n\n\n\n\n\nAll the cool hackers say:\n\n\n\n\nstring and not text.\n\nfloat and not decimal.\n\nNote: some of these terms can be language specific.\n\n\n\n \n\n\n\n6.1.16 (optional) Cleanup\nIt is extremely important to ALWAYS keep your directories clean from random clutter. This lowers the chances you will get lost in your directories, but also ensures you can stay lazy, since TAB completion will not keep finding similarly named files. So let’s clean up your home directory by removing all the clutter we downloaded and worked with today. The command below will remove the ~/BareBonesBash directory as well as all of its contents.\ncd ~     ## We shouldn't delete a directory while we are still in it. (It is possible though).\nrm -r ~/BareBonesBash\n\n\n\n\n\n\nPro Tip\n\n\n\nAlways be VERY careful when using rm -r. Check 3x that the path you are specifying is exactly what you want to delete and nothing more before pressing ENTER!\n\n\n\n\n6.1.17 Conclusion\nYou should now know the basics of working on the command line, like:\n\nWhat a command prompt is\nHow to navigate around the filesystem via the command line\nHow to view the contents of a file\nHow to remove files and directories\nWhat a datastream is, and how they can be redirected\nHow to chain commands together\nWhat a variable is, how to assign them and how to unpack them\nHow to construct a simple for loop\nHow to google more efficiently!\n\nIf you would like to know more about the magic of bash, you can fin more commands as well as and more advanced bash concepts in the BareBonesBash website."
  },
  {
    "objectID": "r-tidyverse.html#lecture",
    "href": "r-tidyverse.html#lecture",
    "title": "7  Introduction to R and the Tidyverse",
    "section": "7.1 Lecture",
    "text": "7.1 Lecture\nLecture slides and video from the 2022 edition of the summer school.\n\n\nPDF version of these slides can be downloaded from here."
  },
  {
    "objectID": "r-tidyverse.html#the-working-environment",
    "href": "r-tidyverse.html#the-working-environment",
    "title": "7  Introduction to R and the Tidyverse",
    "section": "7.2 The working environment",
    "text": "7.2 The working environment\n\n7.2.1 R, RStudio and the tidyverse\n\nR is a fully featured programming language, but it excels as an environment for (statistical) data analysis (https://www.r-project.org)\nRStudio is an integrated development environment (IDE) for R (and other languages): (https://www.rstudio.com/products/rstudio)\nThe tidyverse is a collection of R packages with well-designed and consistent interfaces for the main steps of data analysis: loading, transforming and plotting data (https://www.tidyverse.org)\n\nThis introduction works with tidyverse ~v1.3.0\nWe will learn about readr, tibble, ggplot2, dplyr, magrittr and tidyr\nforcats will be briefly mentioned\npurrr and stringr are left out"
  },
  {
    "objectID": "r-tidyverse.html#loading-data-into-tibbles",
    "href": "r-tidyverse.html#loading-data-into-tibbles",
    "title": "7  Introduction to R and the Tidyverse",
    "section": "7.3 Loading data into tibbles",
    "text": "7.3 Loading data into tibbles\n\n7.3.1 Reading data with readr\n\nWith R we usually operate on data in our computer’s memory\nThe tidyverse provides the package readr to read data from text files into the memory\nreadr can read from our file system or the internet\nIt provides functions to read data in almost any (text) format:\nreadr::read_csv()   # .csv files\nreadr::read_tsv()   # .tsv files\nreadr::read_delim() # tabular files with an arbitrary separator\nreadr::read_fwf()   # fixed width files\nreadr::read_lines() # read linewise to parse yourself\nreadr automatically detects column types – but you can also define them manually\n\n\n\n7.3.2 How does the interface of read_csv work\n\nWe can learn more about a function with ?. To open a help file: ?readr::read_csv\nreadr::read_csv has many options to specify how to read a text file\nread_csv(\nfile,                      # The path to the file we want to read\ncol_names = TRUE,          # Are there column names?\ncol_types = NULL,          # Which types do the columns have? NULL -&gt; auto\nlocale = default_locale(), # How is information encoded in this file?\nna = c(\"\", \"NA\"),          # Which values mean \"no data\"\ntrim_ws = TRUE,            # Should superfluous white-spaces be removed?\nskip = 0,                  # Skip X lines at the beginning of the file\nn_max = Inf,               # Only read X lines\nskip_empty_rows = TRUE,    # Should empty lines be ignored?\ncomment = \"\",              # Should comment lines be ignored?\nname_repair = \"unique\",    # How should \"broken\" column names be fixed\n...\n)\n\n\n\n7.3.3 What does readr produce? The tibble\nsample_table_path &lt;- \"/vol/volume/r-tidyverse/ancientmetagenome-hostassociated_samples.tsv\"\nsample_table_url &lt;-\n\"https://raw.githubusercontent.com/SPAAM-community/AncientMetagenomeDir/b187df6ebd23dfeb42935fd5020cb615ead3f164/\nancientmetagenome-hostassociated/samples/ancientmetagenome-hostassociated_samples.tsv\"\nsamples &lt;- readr::read_tsv(sample_table_url)\n\nThe tibble is a “data frame”, a tabular data structure with rows and columns\nUnlike a simple array, each column can have another data type\n\nprint(samples, n = 3)\n\n\n7.3.4 How to look at a tibble\nsamples          # Typing the name of an object will print it to the console\nstr(samples)     # A structural overview of an object\nsummary(samples) # A human-readable summary of an object\nView(samples)    # RStudio's interactive data browser\n\nR provides a very flexible indexing operation for data.frames and tibbles\nsamples[1,1]                         # Access the first row and column\nsamples[1,]                          # Access the first row\nsamples[,1]                          # Access the first column\nsamples[c(1,2,3),c(2,3,4)]           # Access values from rows and columns\nsamples[,-c(1,2)]                    # Remove the first two columns\nsamples[,c(\"site_name\", \"material\")] # Columns can be selected by name\ntibbles are mutable data structures, so their content can be overwritten\nsamples[1,1] &lt;- \"Cheesecake2015\"     # replace the first value in the first column"
  },
  {
    "objectID": "r-tidyverse.html#plotting-data-in-tibbles",
    "href": "r-tidyverse.html#plotting-data-in-tibbles",
    "title": "7  Introduction to R and the Tidyverse",
    "section": "7.4 Plotting data in tibbles",
    "text": "7.4 Plotting data in tibbles\n\n7.4.1 ggplot2 and the “grammar of graphics”\n\nggplot2 offers an unusual, but powerful and logical interface\nThe following example describes a stacked bar chart\nlibrary(ggplot2) # Loading a library to use its functions without ::\n\nggplot(          # Every plot starts with a call to the ggplot() function\ndata = samples # This function can also take the input tibble\n) +              # The plot consists of functions linked with +\ngeom_bar(        # \"geoms\" define the plot layers we want to draw\nmapping = aes( # The aes() function maps variables to visual properties\n    x = publication_year, # publication_year -&gt; x-axis\n    fill = community_type # community_type -&gt; fill color\n)\n)\ngeom_*: data + geometry (bars) + statistical transformation (sum)\n\n\n\n7.4.2 ggplot2 and the “grammar of graphics”\n\nThis is the plot described above: number of samples per community type through time\nggplot(samples) +\ngeom_bar(aes(x = publication_year, fill = community_type))\n\n\n\n7.4.3 ggplot2 features many geoms\n(){width=55%}\n\nRStudio shares helpful cheatsheets for the tidyverse and beyond: https://www.rstudio.com/resources/cheatsheets\n\n\n\n7.4.4 scales control the behaviour of visual elements\n\nAnother plot: Boxplots of sample age through time\nggplot(samples) +\ngeom_boxplot(aes(x = as.factor(publication_year), y = sample_age))\nThis is not well readable, because extreme outliers dictate the scale\n\n\n\n7.4.5 scales control the behaviour of visual elements\n\nWe can change the scale of different visual elements - e.g. the y-axis\nggplot(samples) +\ngeom_boxplot(aes(x = as.factor(publication_year), y = sample_age)) +\nscale_y_log10()\nThe log-scale improves readability\n\n\n\n7.4.6 scales control the behaviour of visual elements\n\n(Fill) color is a visual element of the plot and its scaling can be adjusted\nggplot(samples) +\ngeom_boxplot(aes(x = as.factor(publication_year), y = sample_age,\n                fill = as.factor(publication_year))) +\nscale_y_log10() + scale_fill_viridis_d(option = \"C\")\n\n\n\n7.4.7 Defining plot matrices via facets\n\nSplitting up the plot by categories into facets is another way to visualize more variables at once\nggplot(samples) +\ngeom_count(aes(x = as.factor(publication_year), y = material)) +\nfacet_wrap(~archive)\nUnfortunately the x-axis became unreadable\n\n\n\n7.4.8 Setting purely aesthetic settings with theme\n\nAesthetic changes like this can be applied as part of the theme\nggplot(samples) +\ngeom_count(aes(x = as.factor(publication_year), y = material)) +\nfacet_wrap(~archive) +\ntheme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))\n\n\n\n7.4.9 Exercise 1\n\nLook at the mtcars dataset and read up on the meaning of its variables\n\nVisualize the relationship between Gross horsepower and 1/4 mile time\n\nIntegrate the Number of cylinders into your plot\n\n\n\n\n7.4.10 Possible solutions 1\n\nLook at the mtcars dataset and read up on the meaning of its variables\n?mtcars\nVisualize the relationship between Gross horsepower and 1/4 mile time\nggplot(mtcars) + geom_point(aes(x = hp, y = qsec))\nIntegrate the Number of cylinders into your plot\nggplot(mtcars) + geom_point(aes(x = hp, y = qsec, color = as.factor(cyl)))"
  },
  {
    "objectID": "r-tidyverse.html#conditional-queries-on-tibbles",
    "href": "r-tidyverse.html#conditional-queries-on-tibbles",
    "title": "7  Introduction to R and the Tidyverse",
    "section": "7.5 Conditional queries on tibbles",
    "text": "7.5 Conditional queries on tibbles\n\n7.5.1 Selecting columns and filtering rows with select and filter\n\nThe dplyr package includes powerful functions to subset data in tibbles based on conditions\ndplyr::select allows to select columns\ndplyr::select(samples, project_name, sample_age)   # reduce to two columns\ndplyr::select(samples, -project_name, -sample_age) # remove two columns\ndplyr::filter allows for conditional filtering of rows\ndplyr::filter(samples, publication_year == 2014)  # samples published in 2014\ndplyr::filter(samples, publication_year == 2014 |\n                    publication_year == 2018)  # samples from 2015 OR 2018\ndplyr::filter(samples, publication_year %in% c(2014, 2018)) # match operator: %in%\ndplyr::filter(samples, sample_host == \"Homo sapiens\" &\n                    community_type == \"oral\")  # oral samples from modern humans\n\n\n\n7.5.2 Chaining functions together with the pipe %&gt;%\n\nThe pipe %&gt;% in the magrittr package is a clever infix operator to chain data and operations\nlibrary(magrittr)\nsamples %&gt;% dplyr::filter(publication_year == 2014)\nIt forwards the LHS as the first argument of the function appearing on the RHS\nThat allows for sequences of functions (“tidyverse style”)\nsamples %&gt;%\ndplyr::select(sample_host, community_type) %&gt;%\ndplyr::filter(sample_host == \"Homo sapiens\" & community_type == \"oral\") %&gt;%\nnrow() # count the rows\nmagrittr also offers some more operators, among which the extraction %$% is particularly useful\nsamples %&gt;%\ndplyr::filter(material == \"tooth\") %$%\nsample_age %&gt;% # extract the sample_age column as a vector\nmax()          # get the maximum of said vector\n\n\n\n7.5.3 Summary statistics in base R\n\nSummarising and counting data is indispensable and R offers all operations you would expect in its base package\nnrow(samples)              # number of rows in a tibble\nlength(samples$site_name)  # length/size of a vector\nunique(samples$material)   # unique elements of a vector\nmin(samples$sample_age)    # minimum\nmax(samples$sample_age)    # maximum\nmean(samples$sample_age)   # mean\nmedian(samples$sample_age) # median\nvar(samples$sample_age)    # variance\nsd(samples$sample_age)     # standard deviation\nquantile(samples$sample_age, probs = 0.75) # sample quantiles for the given probs\nmany of these functions can ignore missing values with an option na.rm = TRUE\n\n\n\n7.5.4 Group-wise summaries with group_by and summarise\n\nThese summary statistics are particular useful when applied to conditional subsets of a dataset\ndplyr allows such summary operations with a combination of group_by and summarise\nsamples %&gt;%\ndplyr::group_by(material) %&gt;%  # group the tibble by the material column\ndplyr::summarise(\n    min_age = min(sample_age),   # a new column: min age for each group\n    median_age = median(sample_age), # a new column: median age for each group\n    max_age = max(sample_age)    # a new column: max age for each group\n)\ngrouping can be applied across multiple columns\nsamples %&gt;%\ndplyr::group_by(material, sample_host) %&gt;% # group by material and host\ndplyr::summarise(\n    n = dplyr::n(),  # a new column: number of samples for each group\n    .groups = \"drop\" # drop the grouping after this summary operation\n)\n\n\n\n7.5.5 Sorting and slicing tibbles with arrange and slice\n\ndplyr allows to arrange tibbles by one or multiple columns\nsamples %&gt;% dplyr::arrange(publication_year)        # sort by publication year\nsamples %&gt;% dplyr::arrange(publication_year,\n                        sample_age)              # ... and sample age\nsamples %&gt;% dplyr::arrange(dplyr::desc(sample_age)) # sort descending on sample age\nSorting also works within groups and can be paired with slice to extract extreme values per group\nsamples %&gt;%\ndplyr::group_by(publication_year) %&gt;%       # group by publication year\ndplyr::arrange(dplyr::desc(sample_age)) %&gt;% # sort by age within (!) groups\ndplyr::slice_head(n = 2) %&gt;%                # keep the first two samples per group\ndplyr::ungroup()                            # remove the still lingering grouping\nSlicing is also the relevant operation to take random samples from the observations in a tibble\nsamples %&gt;% dplyr::slice_sample(n = 20)\n\n\n\n7.5.6 Exercise 2\n\nDetermine the number of cars with four forward gears (gear) in the mtcars dataset\n\nDetermine the mean 1/4 mile time (qsec) per Number of cylinders (cyl) group\n\nIdentify the least efficient cars for both transmission types (am)\n\n\n\n\n7.5.7 Possible solutions 2\n\nDetermine the number of cars with four forward gears (gear) in the mtcars dataset\nmtcars %&gt;% dplyr::filter(gear == 4) %&gt;% nrow()\nDetermine the mean 1/4 mile time (qsec) per Number of cylinders (cyl) group\nmtcars %&gt;% dplyr::group_by(cyl) %&gt;% dplyr::summarise(qsec_mean = mean(qsec))\nIdentify the least efficient cars for both transmission types (am)\n#mtcars3 &lt;- tibble::rownames_to_column(mtcars, var = \"car\") %&gt;% tibble::as_tibble()\nmtcars %&gt;% dplyr::group_by(am) %&gt;% dplyr::arrange(mpg) %&gt;% dplyr::slice_head()"
  },
  {
    "objectID": "r-tidyverse.html#transforming-and-manipulating-tibbles",
    "href": "r-tidyverse.html#transforming-and-manipulating-tibbles",
    "title": "7  Introduction to R and the Tidyverse",
    "section": "7.6 Transforming and manipulating tibbles",
    "text": "7.6 Transforming and manipulating tibbles\n\n7.6.1 Renaming and reordering columns and values with rename, relocate and recode\n\nColumns in tibbles can be renamed with dplyr::rename and reordered with dplyr::relocate\nsamples %&gt;% dplyr::rename(country = geo_loc_name) # rename a column\nsamples %&gt;% dplyr::relocate(site_name, .before = project_name) # reorder columns\nValues in columns can also be changed with dplyr::recode\nsamples$sample_host %&gt;% dplyr::recode(`Homo sapiens` = \"modern human\")\nR supports explicitly ordinal data with factors, which can be reordered as well\nfactors can be handeld more easily with the forcats package\nggplot(samples) + geom_bar(aes(x = community_type)) # bars are alphabetically ordered\nsa2 &lt;- samples\nsa2$cto &lt;- forcats::fct_reorder(sa2$community_type, sa2$community_type, length)\n# fct_reorder: reorder the input factor by a summary statistic on an other vector\nggplot(sa2) + geom_bar(aes(x = community_type)) # bars are ordered by size\n\n\n\n7.6.2 Adding columns to tibbles with mutate and transmute\n\nA common application of data manipulation is adding derived columns. dplyr offers that with mutate\nsamples %&gt;%\ndplyr::mutate(                                               # add a column that\n    archive_summary = paste0(archive, \": \", archive_accession) # combines two other\n) %$% archive_summary                                        # columns\ndplyr::transmute removes all columns but the newly created ones\nsamples %&gt;%\ndplyr::transmute(\n    sample_name = tolower(sample_name), # overwrite this columns\n    publication_doi                     # select this column\n)\ntibble::add_column behaves as dplyr::mutate, but gives more control over column position\nsamples %&gt;% tibble::add_column(., id = 1:nrow(.), .before = \"project_name\")\n\n\n\n7.6.3 Conditional operations with ifelse and case_when\n\nifelse allows to implement conditional mutate operations, that consider information from other columns, but that gets cumbersome easily\nsamples %&gt;% dplyr::mutate(hemi = ifelse(latitude &gt;= 0, \"North\", \"South\")) %$% hemi\n\nsamples %&gt;% dplyr::mutate(\nhemi = ifelse(is.na(latitude), \"unknown\", ifelse(latitude &gt;= 0, \"North\", \"South\"))\n) %$% hemi\ndplyr::case_when is a much more readable solution for this application\nsamples %&gt;% dplyr::mutate(\nhemi = dplyr::case_when(\n    latitude &gt;= 0 ~ \"North\",\n    latitude &lt; 0  ~ \"South\",\n    TRUE          ~ \"unknown\" # TRUE catches all remaining cases\n)\n) %$% hemi\n\n\n\n7.6.4 Long and wide data formats\n\nFor different applications or to simplify certain analysis or plotting operations data often has to be transformed from a wide to a long format or vice versa\n\n\n\nA table in wide format has N key columns and N value columns\nA table in long format has N key columns, one descriptor column and one value column\n\n\n\n7.6.5 A wide dataset\ncarsales &lt;- tibble::tribble(\n  ~brand, ~`2014`, ~`2015`, ~`2016`, ~`2017`,\n  \"BMW\",  20,      25,      30,      45,\n  \"VW\",   67,      40,     120,      55\n)\n\ncarsales\n\nWide format becomes a problem, when the columns are semantically identical. This dataset is in wide format and we can not easily plot it\nWe generally prefer data in long format, although it is more verbose with more duplication. “Long” format data is more “tidy”\n\n\n\n7.6.6 Making a wide dataset long with pivot_longer\ncarsales_long &lt;- carsales %&gt;% tidyr::pivot_longer(\n  cols = tidyselect::num_range(\"\", range = 2014:2017), # set of columns to transform\n  names_to = \"year\",            # the name of the descriptor column we want\n  names_transform = as.integer, # a transformation function to apply to the names\n  values_to = \"sales\"           # the name of the value column we want\n)\n\ncarsales_long\n\n\n7.6.7 Making a long dataset wide with pivot_wider\ncarsales_wide &lt;- carsales_long %&gt;% tidyr::pivot_wider(\n  id_cols = \"brand\",  # the set of id columns that should not be changed\n  names_from = year,  # the descriptor column with the names of the new columns\n  values_from = sales # the value column from which the values should be extracted\n)\n\ncarsales_wide\n\nApplications of wide datasets are adjacency matrices to represent graphs, covariance matrices or other pairwise statistics\nWhen data gets big, then wide formats can be significantly more efficient (e.g. for spatial data)\n\n\n\n7.6.8 Exercise 3\n\nMove the column gear to the first position of the mtcars dataset\n\nMake a new dataset mtcars2 with the column mpg and an additional column am_v, which encodes the transmission type (am) as either \"manual\" or \"automatic\"\n\nCount the number of cars per transmission type (am_v) and number of gears (gear). Then transform the result to a wide format, with one column per transmission type.\n\n\n\n\n7.6.9 Possible solutions 3\n\nMove the column gear to the first position of the mtcars dataset\nmtcars %&gt;% dplyr::relocate(gear, .before = mpg)\nMake a new dataset mtcars2 with the column gear and an additional column am_v, which encodes the transmission type (am) as either \"manual\" or \"automatic\"\nmtcars2 &lt;- mtcars %&gt;% dplyr::mutate(\ngear, am_v = dplyr::case_when(am == 0 ~ \"automatic\", am == 1 ~ \"manual\")\n)\nCount the number of cars in mtcars2 per transmission type (am_v) and number of gears (gear). Then transform the result to a wide format, with one column per transmission type.\nmtcars2 %&gt;% dplyr::group_by(am_v, gear) %&gt;% dplyr::tally() %&gt;%\ntidyr::pivot_wider(names_from = am_v, values_from = n)"
  },
  {
    "objectID": "r-tidyverse.html#combining-tibbles-with-join-operations",
    "href": "r-tidyverse.html#combining-tibbles-with-join-operations",
    "title": "7  Introduction to R and the Tidyverse",
    "section": "7.7 Combining tibbles with join operations",
    "text": "7.7 Combining tibbles with join operations\n\n7.7.1 Types of joins\nJoins combine two datasets x and y based on key columns\n\nMutating joins add columns from one dataset to the other\n\nLeft join: Take observations from x and add fitting information from y\nRight join: Take observations from y and add fitting information from x\nInner join: Join the overlapping observations from x and y\nFull join: Join all observations from x and y, even if information is missing\n\nFiltering joins remove observations from x based on their presence in y\n\nSemi join: Keep every observation in x that is in y\nAnti join: Keep every observation in x that is not in y\n\n\n\n\n7.7.2 A second dataset\nlibrary_table_path &lt;- \"/vol/volume/r-tidyverse/ancientmetagenome-hostassociated_libraries.tsv\"\nlibrary_table_url &lt;-\n\"https://raw.githubusercontent.com/SPAAM-community/AncientMetagenomeDir/b187df6ebd23dfeb42935fd5020cb615ead3f164/\nancientmetagenome-hostassociated/libraries/ancientmetagenome-hostassociated_libraries.tsv\"\n\nlibraries &lt;- readr::read_tsv(library_table_url)\nprint(libraries, n = 3)\n\n\n7.7.3 Meaningful subsets\nsamsub &lt;- samples %&gt;% dplyr::select(project_name, sample_name, sample_age)\nlibsub &lt;- libraries %&gt;% dplyr::select(project_name, sample_name, library_name, read_count)\nprint(samsub, n = 3)\nprint(libsub, n = 3)\n\n\n7.7.4 Left join\nTake observations from x and add fitting information from y\n\nleft &lt;- dplyr::left_join(\nx = samsub,                           # 1060 observations\ny = libsub,                           # 1657 observations\nby = c(\"project_name\", \"sample_name\") # the key columns by which to join\n)\n\nprint(left, n = 1)\n\nLeft joins are the most common join operation: Add information from another dataset\n\n\n\n7.7.5 Right join\nTake observations from y and add fitting information from x\n\nright &lt;- dplyr::right_join(\n  x = samsub,                           # 1060 observations\n  y = libsub,                           # 1657 observations\n  by = c(\"project_name\", \"sample_name\")\n)\n\nprint(right, n = 1)\n\nRight joins are almost identical to left joins – only x and y have reversed roles\n\n\n\n7.7.6 Inner join\nJoin the overlapping observations from x and y\n\ninner &lt;- dplyr::inner_join(\nx = samsub,                           # 1060 observations\ny = libsub,                           # 1657 observations\nby = c(\"project_name\", \"sample_name\")\n)\n\nprint(inner, n = 1)\n\nInner joins are a fast and easy way to check, to which degree two dataset overlap\n\n\n\n7.7.7 Full join\nJoin all observations from x and y, even if information is missing\n\nfull &lt;- dplyr::full_join(\n  x = samsub,                           # 1060 observations\n  y = libsub,                           # 1657 observations\n  by = c(\"project_name\", \"sample_name\")\n)\n\nprint(full, n = 1)\n\nFull joins allow to preserve every bit of information\n\n\n\n7.7.8 Semi join\nKeep every observation in x that is in y\n\nsemi &lt;- dplyr::semi_join(\n  x = samsub,                           # 1060 observations\n  y = libsub,                           # 1657 observations\n  by = c(\"project_name\", \"sample_name\")\n)\nprint(semi, n = 1)\n\nSemi joins are underused operations to filter datasets\n\n\n\n7.7.9 Anti join\nKeep every observation in x that is not in y\n\nanti &lt;- dplyr::anti_join(\n  x = samsub,                           # 1060 observations\n  y = libsub,                           # 1657 observations\n  by = c(\"project_name\", \"sample_name\")\n)\nprint(anti, n = 1)\n\nAnti joins allow to quickly specify incomplete datasets and missing information\n\n\n\n7.7.10 Exercise 4\nConsider the following additional dataset:\ngear_opinions &lt;- tibble::tibble(gear = c(3, 5), opinion = c(\"boring\", \"wow\"))\n\nAdd my opinions about gears to the mtcars dataset\n\nRemove all cars from the dataset for which I don’t have an opinion\n\n\n\n\n7.7.11 Possible Solutions 4\n\nAdd my opinions about gears to the mtcars dataset\ndplyr::left_join(mtcars, gear_opinions, by = \"gear\")\nRemove all cars from the dataset for which I don’t have an opinion\ndplyr::anti_join(mtcars, gear_opinions, by = \"gear\")"
  },
  {
    "objectID": "python-pandas.html#introduction-to-data-manipulation-in-python-with-pandas-and-visulization",
    "href": "python-pandas.html#introduction-to-data-manipulation-in-python-with-pandas-and-visulization",
    "title": "8  Introduction to Python and Pandas",
    "section": "8.1 Introduction to data manipulation in Python with Pandas and visulization",
    "text": "8.1 Introduction to data manipulation in Python with Pandas and visulization\nSPAAM Summer School 2023\nOver the last few years, Python has gained popularity thanks to the numerous libraries (packages with prewritten functions) in the field of machine learning, statistical data analysis, and bioinformatics. While a few years ago, it was often necessary to go to R for performing routine data manipulation and analysis tasks, nowadays Python has a vast ecosystem of libraries. Libraries exist for many different file formats that you might encounter in metagenomics, such as fasta, fastq, sam, bam, etc.\nThis tutorial/walkthrough will provide a short introduction to the most popular libraries for data analysis pandas. This library has functions for reading and manipulating tabular data similar to the data.frame() in R together with some basic data plotting codes.\nThe aim of this walkthrough is to first: get familiar with the Phyton code syntax and use Jupiter Notebook for executing codes and secondly get a kickstart to utilising the endless possibilities of data analysis in Python that can be applied to your data."
  },
  {
    "objectID": "python-pandas.html#table-of-content",
    "href": "python-pandas.html#table-of-content",
    "title": "8  Introduction to Python and Pandas",
    "section": "8.2 Table of content:",
    "text": "8.2 Table of content:\n\n8.3 Working in a jupyter environment\n8.4 Pandas\n8.5 Reading data with Pandas\n8.6 Data exploration\n8.7 Describing a DataFrame\n8.8 Dealing with missing data\n8.9 Combining data\n8.10 Data visualization\n8.11 Plotnine\n8.12 Lecture from 2022"
  },
  {
    "objectID": "python-pandas.html#working-in-a-jupyter-environment",
    "href": "python-pandas.html#working-in-a-jupyter-environment",
    "title": "8  Introduction to Python and Pandas",
    "section": "8.3 Working in a jupyter environment",
    "text": "8.3 Working in a jupyter environment\nThis tutorial run-through is using a Jupyter Notebook for writing & executing Python code and for annotating.\nJupyter notebooks are convenient and have two types of cells: Markdown and Code. The markup cell syntax is very similar to R markdown. The markdown cells are used for annotating, which is important for sharing code with collaborators, reproducibility, and documentation.\nA few examples are shown below. For a full list of possible syntax click here for a Jupyter Notebook cheatsheet.\nlist of markdown cell examples:\n\n\n\n\n\n\nNote\n\n\n\nIn many cases, there are multiple possible syntaxes which give the same result. We present only one way in this run-through.\n\n\nText\n\n**bold** : bold\n*italics* : italics\n\nCode\n\n`inline code` : inline code\n\nLaTeX math\n\n$ x = \\frac{\\pi}{42} $ : \\[ x = \\frac{\\pi}{42} \\]\n\nurl links\n\n[link](https://www.python.org/)link\n\nImages\n\n![](https://www.spaam-community.org/assets/media/SPAAM-Logo-Full-Colour_ShortName.svg) : \n\n\nThe code cells can interpret many different coding languages including Python and Bash. The syntax of the code cells is the same as the syntax of the coding languages, in our case python.\nBelow are some examples of Python code cells with some useful basic python functions:\n\n\n\n\n\n\nPython function\n\n\n\nprint() is a python fuction for printing lines in the terminal print() == echo in bash\n\n\nprint(\"Hello World from Python!\")\nout - Hello World from Python!\nBut it can also, for example, run bash commands by adding a ! at the start of the line.\n! echo \"Hello World from bash!\"\nout - Hello World from bash!\nStings or numbers can be stored as a variable by using the = sign\ni = 0\nOnes a variable is set in one code cell they are stored and can be accessed in other downstream code celles.\nprint(i)\nYou can also print multiple things together in one print statement such as a number and a string:\nprint(\"The number is\", i, \"Wow!\")\nout - The number is 0 Wow!"
  },
  {
    "objectID": "python-pandas.html#pandas",
    "href": "python-pandas.html#pandas",
    "title": "8  Introduction to Python and Pandas",
    "section": "8.4 Pandas",
    "text": "8.4 Pandas\n\n8.4.1 Getting started\nPandas is a Python library used for data manipulation and analysis.\nWe can import the library like this:\nimport pandas as pd\n\n\n\n\n\n\nNote\n\n\n\nWe set “pandas” to the alias “pd” because we are lazy and don’t want to write the full word too many times.\n\n\nNow, we can print the current version:\npd.__version__\nout - '2.0.1'\n\n\n8.4.2 Pandas data structures\nThe primary data structures in Pandas are Series and DataFrame.\nA DataFrame is a table with columns and rows.\nEach column has a column name and each row has an index.\n\nA single row or column (1 dimensional data) is a Series.\n\n\n\n\n\n\n\nNote\n\n\n\nFor a more in detail pandas getting started tutorial click here"
  },
  {
    "objectID": "python-pandas.html#lecture-from-2022",
    "href": "python-pandas.html#lecture-from-2022",
    "title": "8  Introduction to Python and Pandas",
    "section": "8.12 Lecture from 2022",
    "text": "8.12 Lecture from 2022\n\n\n\n\n\n\nNote\n\n\n\nHere are the lecture from the previous course, as well as the links to the material from which the current practical was derived.\n\n\nLecture slides and video from the 2022 edition of the summer school.\nPDF version of these slides can be downloaded from here.\nThis session is run using a Jupyter notebook. This can be found here. However, it will already be installed on compute nodes during the summer school.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nWe highly recommend viewing this walkthrough via the Jupyter notebook above! The output of commands on the website for this walkthrough are displayed in their own code blocks - be wary of what you copy-paste!"
  },
  {
    "objectID": "git-github.html#introduction",
    "href": "git-github.html#introduction",
    "title": "9  Introduction to Git(Hub)",
    "section": "9.1 Introduction",
    "text": "9.1 Introduction\nIn this walkthrough, we will introduce the version control system Git as well as Github, a remote hosting service for version controlled repositories. Git and Github are increasingly popular tools for tracking data, collaborating on research projects, and sharing data and code, and learning to use them will help in many aspects of your own research. For more information on the benefits of using version control systems, see the slides.\n\n\n\n\n\n\nTip\n\n\n\nFor this chapter’s exercises, if not already performed, you will need to create the conda environment from the yml file in the following link (right click and save as to download), and once created, activate the environment with:\nconda activate git-github"
  },
  {
    "objectID": "git-github.html#lecture",
    "href": "git-github.html#lecture",
    "title": "9  Introduction to Git(Hub)",
    "section": "9.2 Lecture",
    "text": "9.2 Lecture\nLecture slides and video from the 2022 edition of the summer school.\n\n\nPDF version of these slides can be downloaded from here."
  },
  {
    "objectID": "git-github.html#ssh-setup",
    "href": "git-github.html#ssh-setup",
    "title": "9  Introduction to Git(Hub)",
    "section": "9.3 SSH setup",
    "text": "9.3 SSH setup\nTo begin, you will set up an SSH key to facilitate easier authentication when transferring data between local and remote repositories. In other words, follow this section of the tutorial so that you never have to type in your github password again! Begin by activating the conda environment for this section (see Preparation above).\nconda activate git-eager\nNext, generate your own ssh key, replacing the email below with your own address.\nssh-keygen -t ed25519 -C \"your_email@example.com\"\nI recommend saving the file to the default location and skipping passphrase setup. To do this, simply press enter without typing anything.\nYou should now (hopefully!) have generated an ssh key. To check that it worked, run the following commands to list the files containing your public and private keys and check that the ssh program is running.\ncd ~/.ssh/\nls id*\neval \"$(ssh-agent -s)\"\nNow you need to give ssh your key to record:\nssh-add ~/.ssh/id_ed15519\nNext, open your webbrowser and navigate to your github account. Go to settings -&gt; SSH & GPG Keys -&gt; New SSH Key. Give you key a title and paste the public key that you just generated on your local machine.\ncat ~/.ssh/id_ed15519\nFinally, press Add SSH key. To check that it worked, run the following command on your local machine. You should see a message telling you that you’ve successfully authenticated.\nssh -T git@github.com\nFor more information about setting up the SSH key, including instructions for different operating systems, check out github’s documentation: https://docs.github.com/es/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent."
  },
  {
    "objectID": "git-github.html#the-only-6-commands-you-really-need-to-know",
    "href": "git-github.html#the-only-6-commands-you-really-need-to-know",
    "title": "9  Introduction to Git(Hub)",
    "section": "9.4 The only 6 commands you really need to know",
    "text": "9.4 The only 6 commands you really need to know\nNow that you have set up your own SSH key, we can begin working on some version controlled data! Navigate to your github homepage and create a new repository. You can choose any name for your new repo (including the default). Add a README file, then select Create Repository.\n  \n\n\n\n\n\n\nNote\n\n\n\nFor the remainder of the session, replace the name of my repository (vigilant-octo-journey) with your own repo name.\n\n\n\n\nChange into the directory where you would like to work, and let’s get started! First, we will learn to clone a remote repository onto your local machine. Navigate to your new repo, select the Code dropdown menu, select SSH, and copy the address as shown below.\n\nBack at your command line, clone the repo as follows:\ngit clone git@github.com:meganemichel/vigilant-octo-journey.git\nNext, let’s add a new or modified file to our ‘staging area’ on our local machine.\ncd vigilant-octo-journey\necho \"test_file\" &gt; file_A.txt\necho \"Just an example repo\" &gt;&gt; README.md\ngit add file_A.txt\nNow we can check what files have been locally changed, staged, etc. with status.\ngit status\nYou should see that file_A.txt is staged to be committed, but README.md is NOT. Try adding README.md and check the status again.\nNow we need to package or save the changes into a commit with a message describing the changes we’ve made. Each commit comes with a unique hash ID and will be stored forever in git history.\ngit commit -m \"Add example file\"\nFinally, let’s push our local commit back to our remote repository.\ngit push\nWhat if we want to download new commits from our remote to our local repository?\ngit pull\nYou should see that your repository is already up-to-date, since we have not made new changes to the remote repo. Let’s try making a change to the remote repository’s README file (as below). Then, back on the command line, pull the repository again."
  },
  {
    "objectID": "git-github.html#working-collaboratively",
    "href": "git-github.html#working-collaboratively",
    "title": "9  Introduction to Git(Hub)",
    "section": "9.5 Working collaboratively",
    "text": "9.5 Working collaboratively\nGithub facilitates simultaneous work by small teams through branching, which generates a copy of the main repository within the repository. This can be edited without breaking the ‘master’ version. First, back on github, make a new branch of your repository.\n\nFrom the command line, you can create a new branch as follows:\ngit switch -c new_branch\nTo switch back to the main branch, use\ngit switch main\nNote that you must commit changes for them to be saved to the desired branch!"
  },
  {
    "objectID": "git-github.html#pull-requests",
    "href": "git-github.html#pull-requests",
    "title": "9  Introduction to Git(Hub)",
    "section": "9.6 Pull requests",
    "text": "9.6 Pull requests\nA Pull request (aka PR) is used to propose changes to a branch from another branch. Others can comment and make suggestinos before your changes are merged into the main branch. For more information on creating a pull request, see github’s documentation: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request."
  },
  {
    "objectID": "git-github.html#questions-to-think-about",
    "href": "git-github.html#questions-to-think-about",
    "title": "9  Introduction to Git(Hub)",
    "section": "9.7 Questions to think about",
    "text": "9.7 Questions to think about\n\nWhy is using a version control software for tracking data and code important?\nHow can using Git(Hub) help me to collaborate on group projects?"
  },
  {
    "objectID": "section-ancient-metagenomics.html#taxonomic-profiling",
    "href": "section-ancient-metagenomics.html#taxonomic-profiling",
    "title": "Ancient Metagenomics",
    "section": "Taxonomic Profiling",
    "text": "Taxonomic Profiling\n\nTBC"
  },
  {
    "objectID": "section-ancient-metagenomics.html#functional-profiling",
    "href": "section-ancient-metagenomics.html#functional-profiling",
    "title": "Ancient Metagenomics",
    "section": "Functional Profiling",
    "text": "Functional Profiling\nThe value of microbial taxonomy lies in the implied biochemical properties of a given taxon. Historically taxonomy was determined by growth characteristics and cell properties, and more recently through genomic and genetic similarity.\nThe genomic content of microbial taxa, specifically the presence or absence of genes, determine how those taxa interact with their environment, including all the biochemical processes they participate in, both internally and externally. Strains within any microbial species may have different genetic content and therefore may behave strikingly differently in the same environment, which cannot be determined through taxonomic profiling. Functionally profiling a microbial community, or determining all of the genes present independent of the species they are derived from, reveals the biochemical reactions and metabolic products the community may perform and produce, respectively.\nThis approach may provide insights to community activity and environmental interactions that are hidden when using taxonomic approaches alone. In this chapter we will perform functional profiling of metagenomic communities to assess their genetic content and inferred metabolic pathways."
  },
  {
    "objectID": "section-ancient-metagenomics.html#de-novo-assembly",
    "href": "section-ancient-metagenomics.html#de-novo-assembly",
    "title": "Ancient Metagenomics",
    "section": "De novo Assembly",
    "text": "De novo Assembly\nDe novo assembly of ancient metagenomic samples enables the recovery of the genetic information of organisms without requiring any prior knowledge about their genomes. Therefore, this approach is very well suited to study the biological diversity of species that have not been studied well or are simply not known yet.\nIn this chapter, we will show you how to prepare your sequencing data and subsequently de novo assemble them. Furthermore, we will then learn how we can actually evaluate what organisms we might have assembled and whether we obtained enough data to reconstruct a whole metagenome-assembled genome. We will particularly focus on the quality assessment of these reconstructed genomes and how we can ensure that we obtained high-quality genomes."
  },
  {
    "objectID": "taxonomic-profiling.html#lecture",
    "href": "taxonomic-profiling.html#lecture",
    "title": "10  Taxonomic Profiling, OTU Tables and Visualisation",
    "section": "10.1 Lecture",
    "text": "10.1 Lecture\nLecture slides and video from the 2022 edition of the summer school.\n\n\nPDF version of these slides can be downloaded from here.\nThis session is run using a Jupyter notebook. This can be found here. However, it will already be installed on compute nodes during the summer school.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nWe highly recommend viewing this walkthrough via the Jupyter notebook above! The output of commands on the website for this walkthrough are displayed in their own code blocks - be wary of what you copy-paste!"
  },
  {
    "objectID": "taxonomic-profiling.html#download-and-subsample",
    "href": "taxonomic-profiling.html#download-and-subsample",
    "title": "10  Taxonomic Profiling, OTU Tables and Visualisation",
    "section": "10.2 Download and Subsample",
    "text": "10.2 Download and Subsample\nimport subprocess\nimport glob\nfrom pathlib import Path\nFor this tutorial, we will be using the ERR5766177 library from the sample 2612 published by Maixner et al. 2021\n\n`\n\n10.2.1 Subsampling the sequencing files to make the analysis quicker for this tutorial\ndef subsample(filename, outdir, depth=1000000):\n    basename = Path(filename).stem\n    cmd = f\"seqtk sample -s42 {filename} {depth} &gt; {outdir}/{basename}_subsample_{depth}.fastq\"\n    print(cmd)\n    subprocess.check_output(cmd, shell=True)\nfor f in glob.glob(\"../data/raw/*\"):\n    outdir = \"../data/subsampled\"\n    subsample(f, outdir)\nseqtk sample -s42 ../data/raw/ERR5766177_PE.mapped.hostremoved.fwd.fq.gz 1000000 &gt;\n../data/subsampled/ERR5766177_PE.mapped.hostremoved.fwd.fq_subsample_1000000.fastq\nseqtk sample -s42 ../data/raw/ERR5766177_PE.mapped.hostremoved.rev.fq.gz 1000000 &gt;\n../data/subsampled/ERR5766177_PE.mapped.hostremoved.rev.fq_subsample_1000000.fastq\n! gzip -f ../data/subsampled/*.fastq"
  },
  {
    "objectID": "taxonomic-profiling.html#hands-on-introduction-to-ancient-microbiome-analysis",
    "href": "taxonomic-profiling.html#hands-on-introduction-to-ancient-microbiome-analysis",
    "title": "10  Taxonomic Profiling, OTU Tables and Visualisation",
    "section": "10.3 Hands on introduction to ancient microbiome analysis",
    "text": "10.3 Hands on introduction to ancient microbiome analysis\nAuthor: Maxime Borry\nDate: 12/08/2021\nIn this tutorial, we’re going to go through the steps necessary to:\n\ngenerate a taxonomic profile table with metaphlan v3.0\nhave a look at metaphlan results with Pavian and generate a Krona plot\nCompare the diversity of our samples vs the diversity of modern human gut samples\nCompare the composition of our samples vs modern gut samples, and see where they fit in a lower dimensional space\n\n\n10.3.1 0. Quick intro to Jupyter Notebooks\nThis a markdown cell\nprint(\"This is a python cell\")\nThis is a python cell\n! echo \"This is how to run a single line bash command\"\nThis is how to run a single line bash command\n%%bash\necho \"This how to run a multi\"\necho \"lines bash command\"\nThis how to run a multi\nlines bash command\n\n\n10.3.2 1. Data pre-processing\nBefore starting to analyze our data, we will need to pre-process them to remove reads mapping to the host genome, here, Homo sapiens\nTo do so, I’ve used nf-core/eager\nI’ve already pre-processed the data, and the resulting cleaned files are available in the data/eager_cleaned, but the basic eager command to do so is:\nnextflow run nf-core/eager -profile &lt;docker/singularity/podman/conda/institute&gt; --input '*_R{1,2}.fastq.gz' \\\n--fasta 'human_genome.fasta' --hostremoval_input_fastq\n\n\n10.3.3 2. Adapter sequence trimming and low-quality bases trimming\nSequencing adapters are small DNA sequences adding prior to DNA sequencing to allow the DNA fragments to attach to the sequencing flow cells. Because these adapters could interfere with downtstream analyses, we need to remove them before proceeding any further. Furthermore, because the quality of the sequencing is not always optimal, we need to remove bases of lower sequencing quality to might lead to spurious results in downstream analyses.\nTo perform both of these tasks, we’ll use the program fastp.\n! fastp -h\noption needs value: --html\nusage: fastp [options] ...\noptions:\n  -i, --in1                            read1 input file name (string [=])\n  -o, --out1                           read1 output file name (string [=])\n  -I, --in2                            read2 input file name (string [=])\n  -O, --out2                           read2 output file name (string [=])\n      --unpaired1                      for PE input, if read1 passed QC but read2 not, it will be written to unpaired1.\n                                       Default is to discard it. (string [=])\n      --unpaired2                      for PE input, if read2 passed QC but read1 not, it will be written to unpaired2.\n                                       If --unpaired2 is same as --unpaired1 (default mode), both unpaired reads will be\n                                       written to this same file. (string [=])\n      --overlapped_out                 for each read pair, output the overlapped region if it has no any mismatched\n                                       base. (string [=])\n      --failed_out                     specify the file to store reads that cannot pass the filters. (string [=])\n  -m, --merge                          for paired-end input, merge each pair of reads into a single read if they are\n                                       overlapped. The merged reads will be written\n                                       to the file given by --merged_out, the unmerged reads will be written to the\n                                       files specified by --out1 and --out2. The merging mode is disabled by default.\n      --merged_out                     in the merging mode, specify the file name to store merged output, or specify\n                                       --stdout to stream the merged output (string [=])\n      --include_unmerged               in the merging mode, write the unmerged or unpaired reads to the file specified\n                                       by --merge. Disabled by default.\n  -6, --phred64                        indicate the input is using phred64 scoring (it'll be converted to phred33,\n                                       so the output will still be phred33)\n  -z, --compression                    compression level for gzip output (1 ~ 9). 1 is fastest, 9 is smallest, default is 4. (int [=4])\n      --stdin                          input from STDIN. If the STDIN is interleaved paired-end FASTQ, please also add --interleaved_in.\n      --stdout                         stream passing-filters reads to STDOUT. This option will result in interleaved\n                                       FASTQ output for paired-end output. Disabled by default.\n      --interleaved_in                 indicate that &lt;in1&gt; is an interleaved FASTQ which contains both read1 and read2.\n                                       Disabled by default.\n      --reads_to_process               specify how many reads/pairs to be processed. Default 0 means process all reads. (int [=0])\n      --dont_overwrite                 don't overwrite existing files. Overwritting is allowed by default.\n      --fix_mgi_id                     the MGI FASTQ ID format is not compatible with many BAM operation tools, enable this option to fix it.\n  -V, --verbose                        output verbose log information (i.e. when every 1M reads are processed).\n  -A, --disable_adapter_trimming       adapter trimming is enabled by default. If this option is specified, adapter trimming is disabled\n  -a, --adapter_sequence               the adapter for read1. For SE data, if not specified, the adapter will be auto-detected.\n                                       For PE data, this is used if R1/R2 are found not overlapped. (string [=auto])\n      --adapter_sequence_r2            the adapter for read2 (PE data only). This is used if R1/R2 are found not overlapped.\n                                       If not specified, it will be the same as &lt;adapter_sequence&gt; (string [=auto])\n      --adapter_fasta                  specify a FASTA file to trim both read1 and read2 (if PE) by all the sequences in this FASTA file (string [=])\n      --detect_adapter_for_pe          by default, the auto-detection for adapter is for SE data input only, turn on this\n                                    option to enable it for PE data.\n  -f, --trim_front1                    trimming how many bases in front for read1, default is 0 (int [=0])\n  -t, --trim_tail1                     trimming how many bases in tail for read1, default is 0 (int [=0])\n  -b, --max_len1                       if read1 is longer than max_len1, then trim read1 at its tail to make it as\n                                       long as max_len1. Default 0 means no limitation (int [=0])\n  -F, --trim_front2                    trimming how many bases in front for read2. If it's not specified, it will follow read1's settings (int [=0])\n  -T, --trim_tail2                     trimming how many bases in tail for read2. If it's not specified, it will follow read1's settings (int [=0])\n  -B, --max_len2                       if read2 is longer than max_len2, then trim read2 at its tail to make it as long as max_len2.\n                                       Default 0 means no limitation. If it's not specified, it will follow read1's settings (int [=0])\n  -D, --dedup                          enable deduplication to drop the duplicated reads/pairs\n      --dup_calc_accuracy              accuracy level to calculate duplication (1~6), higher level uses more memory (1G, 2G, 4G, 8G, 16G, 24G).\n                                       Default 1 for no-dedup mode, and 3 for dedup mode. (int [=0])\n      --dont_eval_duplication          don't evaluate duplication rate to save time and use less memory.\n  -g, --trim_poly_g                    force polyG tail trimming, by default trimming is automatically enabled for Illumina NextSeq/NovaSeq data\n      --poly_g_min_len                 the minimum length to detect polyG in the read tail. 10 by default. (int [=10])\n  -G, --disable_trim_poly_g            disable polyG tail trimming, by default trimming is automatically enabled for Illumina NextSeq/NovaSeq data\n  -x, --trim_poly_x                    enable polyX trimming in 3' ends.\n      --poly_x_min_len                 the minimum length to detect polyX in the read tail. 10 by default. (int [=10])\n  -5, --cut_front                      move a sliding window from front (5') to tail, drop the bases in the window if\n                                       its mean quality &lt; threshold, stop otherwise.\n  -3, --cut_tail                       move a sliding window from tail (3') to front, drop the bases in the window if\n                                       its mean quality &lt; threshold, stop otherwise.\n  -r, --cut_right                      move a sliding window from front to tail, if meet one window with mean quality\n                                       &lt; threshold, drop the bases in the window and the right part, and then stop.\n  -W, --cut_window_size                the window size option shared by cut_front, cut_tail or cut_sliding. Range: 1~1000, default: 4 (int [=4])\n  -M, --cut_mean_quality               the mean quality requirement option shared by cut_front, cut_tail or cut_sliding.\n                                       Range: 1~36 default: 20 (Q20) (int [=20])\n      --cut_front_window_size          the window size option of cut_front, default to cut_window_size if not specified (int [=4])\n      --cut_front_mean_quality         the mean quality requirement option for cut_front, default to cut_mean_quality if not specified (int [=20])\n      --cut_tail_window_size           the window size option of cut_tail, default to cut_window_size if not specified (int [=4])\n      --cut_tail_mean_quality          the mean quality requirement option for cut_tail, default to cut_mean_quality if not specified (int [=20])\n      --cut_right_window_size          the window size option of cut_right, default to cut_window_size if not specified (int [=4])\n      --cut_right_mean_quality         the mean quality requirement option for cut_right, default to cut_mean_quality if not specified (int [=20])\n  -Q, --disable_quality_filtering      quality filtering is enabled by default. If this option is specified, quality filtering is disabled\n  -q, --qualified_quality_phred        the quality value that a base is qualified. Default 15 means phred quality &gt;=Q15 is qualified. (int [=15])\n  -u, --unqualified_percent_limit      how many percents of bases are allowed to be unqualified (0~100). Default 40 means 40% (int [=40])\n  -n, --n_base_limit                   if one read's number of N base is &gt;n_base_limit, then this read/pair is discarded. Default is 5 (int [=5])\n  -e, --average_qual                   if one read's average quality score &lt;avg_qual, then this read/pair is discarded.\n                                       Default 0 means no requirement (int [=0])\n  -L, --disable_length_filtering       length filtering is enabled by default. If this option is specified, length filtering is disabled\n  -l, --length_required                reads shorter than length_required will be discarded, default is 15. (int [=15])\n      --length_limit                   reads longer than length_limit will be discarded, default 0 means no limitation. (int [=0])\n  -y, --low_complexity_filter          enable low complexity filter. The complexity is defined as the percentage of base\n                                       that is different from its next base (base[i] != base[i+1]).\n  -Y, --complexity_threshold           the threshold for low complexity filter (0~100). Default is 30, which means 30% complexity is required. (int [=30])\n      --filter_by_index1               specify a file contains a list of barcodes of index1 to be filtered out, one barcode per line (string [=])\n      --filter_by_index2               specify a file contains a list of barcodes of index2 to be filtered out, one barcode per line (string [=])\n      --filter_by_index_threshold      the allowed difference of index barcode for index filtering, default 0 means completely identical. (int [=0])\n  -c, --correction                     enable base correction in overlapped regions (only for PE data), default is disabled\n      --overlap_len_require            the minimum length to detect overlapped region of PE reads. This will affect overlap analysis based PE merge,\n                                       adapter trimming and correction. 30 by default. (int [=30])\n      --overlap_diff_limit             the maximum number of mismatched bases to detect overlapped region of PE reads.\n                                       This will affect overlap analysis based PE merge, adapter trimming and correction. 5 by default. (int [=5])\n      --overlap_diff_percent_limit     the maximum percentage of mismatched bases to detect overlapped region of PE reads.\n                                       This will affect overlap analysis based PE merge, adapter trimming and correction. Default 20 means 20%. (int [=20])\n  -U, --umi                            enable unique molecular identifier (UMI) preprocessing\n      --umi_loc                        specify the location of UMI, can be (index1/index2/read1/read2/per_index/per_read, default is none (string [=])\n      --umi_len                        if the UMI is in read1/read2, its length should be provided (int [=0])\n      --umi_prefix                     if specified, an underline will be used to connect prefix and UMI (i.e.\n                                       prefix=UMI, UMI=AATTCG, final=UMI_AATTCG). No prefix by default (string [=])\n      --umi_skip                       if the UMI is in read1/read2, fastp can skip several bases following UMI, default is 0 (int [=0])\n  -p, --overrepresentation_analysis    enable overrepresented sequence analysis.\n  -P, --overrepresentation_sampling    one in (--overrepresentation_sampling) reads will be computed for overrepresentation\n                                       analysis (1~10000), smaller is slower, default is 20. (int [=20])\n  -j, --json                           the json format report file name (string [=fastp.json])\n  -h, --html                           the html format report file name (string [=fastp.html])\n  -R, --report_title                   should be quoted with ' or \", default is \"fastp report\" (string [=fastp report])\n  -w, --thread                         worker thread number, default is 3 (int [=3])\n  -s, --split                          split output by limiting total split file number with this option (2~999), a sequential number prefix\n                                       will be added to output name ( 0001.out.fq, 0002.out.fq...), disabled by default (int [=0])\n  -S, --split_by_lines                 split output by limiting lines of each file with this option(&gt;=1000), a sequential number prefix will be\n                                       added to output name ( 0001.out.fq, 0002.out.fq...), disabled by default (long [=0])\n  -d, --split_prefix_digits            the digits for the sequential number padding (1~10), default is 4, so the filename will be padded as\n                                       0001.xxx, 0 to disable padding (int [=4])\n      --cut_by_quality5                DEPRECATED, use --cut_front instead.\n      --cut_by_quality3                DEPRECATED, use --cut_tail instead.\n      --cut_by_quality_aggressive      DEPRECATED, use --cut_right instead.\n      --discard_unmerged               DEPRECATED, no effect now, see the introduction for merging.\n  -?, --help                           print this message\n%%bash\nfastp \\\n    --in1 ../data/subsampled/ERR5766177_PE.mapped.hostremoved.fwd.fq_subsample_1000000.fastq.gz \\\n    --in2 ../data/subsampled/ERR5766177_PE.mapped.hostremoved.fwd.fq_subsample_1000000.fastq.gz \\\n    --merge \\\n    --merged_out ../results/fastp/ERR5766177.merged.fastq.gz \\\n    --include_unmerged \\\n    --dedup \\\n    --json ../results/fastp/ERR5766177.fastp.json \\\n    --html ../results/fastp/ERR5766177.fastp.html \\\nRead1 before filtering:\ntotal reads: 1000000\ntotal bases: 101000000\nQ20 bases: 99440729(98.4562%)\nQ30 bases: 94683150(93.7457%)\n\nRead2 before filtering:\ntotal reads: 1000000\ntotal bases: 101000000\nQ20 bases: 99440729(98.4562%)\nQ30 bases: 94683150(93.7457%)\n\nMerged and filtered:\ntotal reads: 1994070\ntotal bases: 201397311\nQ20 bases: 198330392(98.4772%)\nQ30 bases: 188843169(93.7665%)\n\nFiltering result:\nreads passed filter: 1999252\nreads failed due to low quality: 728\nreads failed due to too many N: 20\nreads failed due to too short: 0\nreads with adapter trimmed: 282\nbases trimmed due to adapters: 18654\nreads corrected by overlap analysis: 0\nbases corrected by overlap analysis: 0\n\nDuplication rate: 0.2479%\n\nInsert size peak (evaluated by paired-end reads): 31\n\nRead pairs merged: 228\n% of original read pairs: 0.0228%\n% in reads after filtering: 0.0114339%\n\n\nJSON report: ../results/fastp/ERR5766177.fastp.json\nHTML report: ../results/fastp/ERR5766177.fastp.html\n\nfastp --in1 ../data/subsampled/ERR5766177_PE.mapped.hostremoved.fwd.fq_subsample_1000000.fastq.gz \\\n--in2 ../data/subsampled/ERR5766177_PE.mapped.hostremoved.fwd.fq_subsample_1000000.fastq.gz --merge \\\n--merged_out ../results/fastp/ERR5766177.merged.fastq.gz --include_unmerged --dedup \\\n--json ../results/fastp/ERR5766177.fastp.json --html ../results/fastp/ERR5766177.fastp.html\nfastp v0.23.2, time used: 11 seconds\n\n10.3.3.0.1 3. Taxonomic profiling with Metaphlan\n! metaphlan  --help\nusage: metaphlan --input_type {fastq,fasta,bowtie2out,sam} [--force]\n                 [--bowtie2db METAPHLAN_BOWTIE2_DB] [-x INDEX]\n                 [--bt2_ps BowTie2 presets] [--bowtie2_exe BOWTIE2_EXE]\n                 [--bowtie2_build BOWTIE2_BUILD] [--bowtie2out FILE_NAME]\n                 [--min_mapq_val MIN_MAPQ_VAL] [--no_map] [--tmp_dir]\n                 [--tax_lev TAXONOMIC_LEVEL] [--min_cu_len]\n                 [--min_alignment_len] [--add_viruses] [--ignore_eukaryotes]\n                 [--ignore_bacteria] [--ignore_archaea] [--stat_q]\n                 [--perc_nonzero] [--ignore_markers IGNORE_MARKERS]\n                 [--avoid_disqm] [--stat] [-t ANALYSIS TYPE]\n                 [--nreads NUMBER_OF_READS] [--pres_th PRESENCE_THRESHOLD]\n                 [--clade] [--min_ab] [-o output file] [--sample_id_key name]\n                 [--use_group_representative] [--sample_id value]\n                 [-s sam_output_file] [--legacy-output] [--CAMI_format_output]\n                 [--unknown_estimation] [--biom biom_output] [--mdelim mdelim]\n                 [--nproc N] [--install] [--force_download]\n                 [--read_min_len READ_MIN_LEN] [-v] [-h]\n                 [INPUT_FILE] [OUTPUT_FILE]\n\nDESCRIPTION\n MetaPhlAn version 3.1.0 (25 Jul 2022):\n METAgenomic PHyLogenetic ANalysis for metagenomic taxonomic profiling.\n\nAUTHORS: Francesco Beghini (francesco.beghini@unitn.it),Nicola Segata (nicola.segata@unitn.it), Duy Tin Truong,\nFrancesco Asnicar (f.asnicar@unitn.it), Aitor Blanco Miguez (aitor.blancomiguez@unitn.it)\n\nCOMMON COMMANDS\n\n We assume here that MetaPhlAn is installed using the several options available (pip, conda, PyPi)\n Also BowTie2 should be in the system path with execution and read permissions, and Perl should be installed)\n\n========== MetaPhlAn clade-abundance estimation =================\n\nThe basic usage of MetaPhlAn consists in the identification of the clades (from phyla to species )\npresent in the metagenome obtained from a microbiome sample and their\nrelative abundance. This correspond to the default analysis type (-t rel_ab).\n\n*  Profiling a metagenome from raw reads:\n$ metaphlan metagenome.fastq --input_type fastq -o profiled_metagenome.txt\n\n*  You can take advantage of multiple CPUs and save the intermediate BowTie2 output for re-running\n   MetaPhlAn extremely quickly:\n$ metaphlan metagenome.fastq --bowtie2out metagenome.bowtie2.bz2 --nproc 5 --input_type fastq -o profiled_metagenome.txt\n\n*  If you already mapped your metagenome against the marker DB (using a previous MetaPhlAn run), you\n   can obtain the results in few seconds by using the previously saved --bowtie2out file and\n   specifying the input (--input_type bowtie2out):\n$ metaphlan metagenome.bowtie2.bz2 --nproc 5 --input_type bowtie2out -o profiled_metagenome.txt\n\n*  bowtie2out files generated with MetaPhlAn versions below 3 are not compatibile.\n   Starting from MetaPhlAn 3.0, the BowTie2 ouput now includes the size of the profiled metagenome and the average read length.\n   If you want to re-run MetaPhlAn using these file you should provide the metagenome size via --nreads:\n$ metaphlan metagenome.bowtie2.bz2 --nproc 5 --input_type bowtie2out --nreads 520000 -o profiled_metagenome.txt\n\n*  You can also provide an externally BowTie2-mapped SAM if you specify this format with\n   --input_type. Two steps: first apply BowTie2 and then feed MetaPhlAn with the obtained sam:\n$ bowtie2 --sam-no-hd --sam-no-sq --no-unal --very-sensitive -S metagenome.sam -x \\\n  ${mpa_dir}/metaphlan_databases/mpa_v30_CHOCOPhlAn_201901 -U metagenome.fastq\n$ metaphlan metagenome.sam --input_type sam -o profiled_metagenome.txt\n\n*  We can also natively handle paired-end metagenomes, and, more generally, metagenomes stored in\n  multiple files (but you need to specify the --bowtie2out parameter):\n$ metaphlan metagenome_1.fastq,metagenome_2.fastq --bowtie2out metagenome.bowtie2.bz2 --nproc 5 --input_type fastq\n\n-------------------------------------------------------------------\n\n\n========== Marker level analysis ============================\n\nMetaPhlAn introduces the capability of characterizing organisms at the strain level using non\naggregated marker information. Such capability comes with several slightly different flavours and\nare a way to perform strain tracking and comparison across multiple samples.\nUsually, MetaPhlAn is first ran with the default -t to profile the species present in\nthe community, and then a strain-level profiling can be performed to zoom-in into specific species\nof interest. This operation can be performed quickly as it exploits the --bowtie2out intermediate\nfile saved during the execution of the default analysis type.\n\n*  The following command will output the abundance of each marker with a RPK (reads per kilo-base)\n   higher 0.0. (we are assuming that metagenome_outfmt.bz2 has been generated before as\n   shown above).\n$ metaphlan -t marker_ab_table metagenome_outfmt.bz2 --input_type bowtie2out -o marker_abundance_table.txt\n   The obtained RPK can be optionally normalized by the total number of reads in the metagenome\n   to guarantee fair comparisons of abundances across samples. The number of reads in the metagenome\n   needs to be passed with the '--nreads' argument\n\n*  The list of markers present in the sample can be obtained with '-t marker_pres_table'\n$ metaphlan -t marker_pres_table metagenome_outfmt.bz2 --input_type bowtie2out -o marker_abundance_table.txt\n   The --pres_th argument (default 1.0) set the minimum RPK value to consider a marker present\n\n*  The list '-t clade_profiles' analysis type reports the same information of '-t marker_ab_table'\n   but the markers are reported on a clade-by-clade basis.\n$ metaphlan -t clade_profiles metagenome_outfmt.bz2 --input_type bowtie2out -o marker_abundance_table.txt\n\n*  Finally, to obtain all markers present for a specific clade and all its subclades, the\n   '-t clade_specific_strain_tracker' should be used. For example, the following command\n   is reporting the presence/absence of the markers for the B. fragilis species and its strains\n   the optional argument --min_ab specifies the minimum clade abundance for reporting the markers\n\n$ metaphlan -t clade_specific_strain_tracker --clade s__Bacteroides_fragilis metagenome_outfmt.bz2 --input_typ\n  bowtie2out -o marker_abundance_table.txt\n\n-------------------------------------------------------------------\n\npositional arguments:\n  INPUT_FILE            the input file can be:\n                        * a fastq file containing metagenomic reads\n                        OR\n                        * a BowTie2 produced SAM file.\n                        OR\n                        * an intermediary mapping file of the metagenome generated by a previous MetaPhlAn run\n                        If the input file is missing, the script assumes that the input is provided using the standard\n                        input, or named pipes.\n                        IMPORTANT: the type of input needs to be specified with --input_type\n  OUTPUT_FILE           the tab-separated output file of the predicted taxon relative abundances\n                        [stdout if not present]\n\nRequired arguments:\n  --input_type {fastq,fasta,bowtie2out,sam}\n                        set whether the input is the FASTA file of metagenomic reads or\n                        the SAM file of the mapping of the reads against the MetaPhlAn db.\n\nMapping arguments:\n  --force               Force profiling of the input file by removing the bowtie2out file\n  --bowtie2db METAPHLAN_BOWTIE2_DB\n                        Folder containing the MetaPhlAn database. You can specify the location by exporting the\n                        DEFAULT_DB_FOLDER variable in the shell.\n                        [default /Users/maxime/mambaforge/envs/summer_school_microbiome/lib/python3.9/site-packages/metaphlan/metaphlan_databases]\n  -x INDEX, --index INDEX\n                        Specify the id of the database version to use. If \"latest\", MetaPhlAn will get the latest version.\n                        If an index name is provided, MetaPhlAn will try to use it, if available, and skip the online check.\n                        If the database files are not found on the local MetaPhlAn installation they\n                        will be automatically downloaded [default latest]\n  --bt2_ps BowTie2 presets\n                        Presets options for BowTie2 (applied only when a FASTA file is provided)\n                        The choices enabled in MetaPhlAn are:\n                         * sensitive\n                         * very-sensitive\n                         * sensitive-local\n                         * very-sensitive-local\n                        [default very-sensitive]\n  --bowtie2_exe BOWTIE2_EXE\n                        Full path and name of the BowTie2 executable. This option allowsMetaPhlAn to reach the\n                        executable even when it is not in the system PATH or the system PATH is unreachable\n  --bowtie2_build BOWTIE2_BUILD\n                        Full path to the bowtie2-build command to use, deafult assumes that 'bowtie2-build is present in the system path\n  --bowtie2out FILE_NAME\n                        The file for saving the output of BowTie2\n  --min_mapq_val MIN_MAPQ_VAL\n                        Minimum mapping quality value (MAPQ) [default 5]\n  --no_map              Avoid storing the --bowtie2out map file\n  --tmp_dir             The folder used to store temporary files [default is the OS dependent tmp dir]\n\nPost-mapping arguments:\n  --tax_lev TAXONOMIC_LEVEL\n                        The taxonomic level for the relative abundance output:\n                        'a' : all taxonomic levels\n                        'k' : kingdoms\n                        'p' : phyla only\n                        'c' : classes only\n                        'o' : orders only\n                        'f' : families only\n                        'g' : genera only\n                        's' : species only\n                        [default 'a']\n  --min_cu_len          minimum total nucleotide length for the markers in a clade for\n                        estimating the abundance without considering sub-clade abundances\n                        [default 2000]\n  --min_alignment_len   The sam records for aligned reads with the longest subalignment\n                        length smaller than this threshold will be discarded.\n                        [default None]\n  --add_viruses         Allow the profiling of viral organisms\n  --ignore_eukaryotes   Do not profile eukaryotic organisms\n  --ignore_bacteria     Do not profile bacterial organisms\n  --ignore_archaea      Do not profile archeal organisms\n  --stat_q              Quantile value for the robust average\n                        [default 0.2]\n  --perc_nonzero        Percentage of markers with a non zero relative abundance for misidentify a species\n                        [default 0.33]\n  --ignore_markers IGNORE_MARKERS\n                        File containing a list of markers to ignore.\n  --avoid_disqm         Deactivate the procedure of disambiguating the quasi-markers based on the\n                        marker abundance pattern found in the sample. It is generally recommended\n                        to keep the disambiguation procedure in order to minimize false positives\n  --stat                Statistical approach for converting marker abundances into clade abundances\n                        'avg_g'  : clade global (i.e. normalizing all markers together) average\n                        'avg_l'  : average of length-normalized marker counts\n                        'tavg_g' : truncated clade global average at --stat_q quantile\n                        'tavg_l' : truncated average of length-normalized marker counts (at --stat_q)\n                        'wavg_g' : winsorized clade global average (at --stat_q)\n                        'wavg_l' : winsorized average of length-normalized marker counts (at --stat_q)\n                        'med'    : median of length-normalized marker counts\n                        [default tavg_g]\n\nAdditional analysis types and arguments:\n  -t ANALYSIS TYPE      Type of analysis to perform:\n                         * rel_ab: profiling a metagenomes in terms of relative abundances\n                         * rel_ab_w_read_stats: profiling a metagenomes in terms of relative abundances and estimate\n                                                the number of reads coming from each clade.\n                         * reads_map: mapping from reads to clades (only reads hitting a marker)\n                         * clade_profiles: normalized marker counts for clades with at least a non-null marker\n                         * marker_ab_table: normalized marker counts (only when &gt; 0.0 and normalized by metagenome size if --nreads is specified)\n                         * marker_counts: non-normalized marker counts [use with extreme caution]\n                         * marker_pres_table: list of markers present in the sample (threshold at 1.0 if not differently specified with --pres_th\n                         * clade_specific_strain_tracker: list of markers present for a specific clade, specified with --clade, and all its subclades\n                        [default 'rel_ab']\n  --nreads NUMBER_OF_READS\n                        The total number of reads in the original metagenome. It is used only when\n                        -t marker_table is specified for normalizing the length-normalized counts\n                        with the metagenome size as well. No normalization applied if --nreads is not\n                        specified\n  --pres_th PRESENCE_THRESHOLD\n                        Threshold for calling a marker present by the -t marker_pres_table option\n  --clade               The clade for clade_specific_strain_tracker analysis\n  --min_ab              The minimum percentage abundance for the clade in the clade_specific_strain_tracker analysis\n\nOutput arguments:\n  -o output file, --output_file output file\n                        The output file (if not specified as positional argument)\n  --sample_id_key name  Specify the sample ID key for this analysis. Defaults to 'SampleID'.\n  --use_group_representative\n                        Use a species as representative for species groups.\n  --sample_id value     Specify the sample ID for this analysis. Defaults to 'Metaphlan_Analysis'.\n  -s sam_output_file, --samout sam_output_file\n                        The sam output file\n  --legacy-output       Old MetaPhlAn2 two columns output\n  --CAMI_format_output  Report the profiling using the CAMI output format\n  --unknown_estimation  Scale relative abundances to the number of reads mapping to known clades in order to estimate unknowness\n  --biom biom_output, --biom_output_file biom_output\n                        If requesting biom file output: The name of the output file in biom format\n  --mdelim mdelim, --metadata_delimiter_char mdelim\n                        Delimiter for bug metadata: - defaults to pipe. e.g. the pipe in k__Bacteria|p__Proteobacteria\n\nOther arguments:\n  --nproc N             The number of CPUs to use for parallelizing the mapping [default 4]\n  --install             Only checks if the MetaPhlAn DB is installed and installs it if not. All other parameters are ignored.\n  --force_download      Force the re-download of the latest MetaPhlAn database.\n  --read_min_len READ_MIN_LEN\n                        Specify the minimum length of the reads to be considered when parsing the input file with\n                        'read_fastx.py' script, default value is 70\n  -v, --version         Prints the current MetaPhlAn version and exit\n  -h, --help            show this help message and exit\nmetaphlan ../results/fastp/ERR5766177.merged.fastq.gz  \\\n    --input_type fastq \\\n    --bowtie2out ../results/metaphlan/ERR5766177.bt2.out  \\\n    --nproc 4 \\\n    &gt; ../results/metaphlan/ERR5766177.metaphlan_profile.txt\nThe main results files that we’re interested in is located at ../results/metaphlan/ERR5766177.metaphlan_profile.txt\nIt’s a tab separated file, with taxons in rows, with their relative abundance in the sample\n! head ../results/metaphlan/ERR5766177.metaphlan_profile.txt\n#mpa_v30_CHOCOPhlAn_201901\n#/home/maxime_borry/.conda/envs/maxime/envs/summer_school_microbiome/bin/metaphlan ../results/fastp/ERR5766177.merged.fastq.gz \\\n--input_type fastq --bowtie2out ../results/metaphlan/ERR5766177.bt2.out --nproc 8\n#SampleID   Metaphlan_Analysis\n#clade_name NCBI_tax_id relative_abundance  additional_species\nk__Bacteria 2   82.23198\nk__Archaea  2157    17.76802\nk__Bacteria|p__Firmicutes   2|1239  33.47957\nk__Bacteria|p__Bacteroidetes    2|976   28.4209\nk__Bacteria|p__Actinobacteria   2|201174    20.33151\nk__Archaea|p__Euryarchaeota 2157|28890  17.76802\n\n\n\n10.3.4 4. Visualizing the taxonomic profile\n\n10.3.4.1 4.1 Visualizing metaphlan taxonomic profile with Pavian\nPavian is an interactive app to explore results of different taxonomic classifiers\nThere are different ways to run it:\n\nIf you have docker installed (and are somehow familiar with it)\n\ndocker pull 'florianbw/pavian'\ndocker run --rm -p 5000:80 florianbw/pavian\nThen open your browser and visit localhost:5000\n\nIf you are familiar with R\n\nif (!require(remotes)) { install.packages(\"remotes\") }\nremotes::install_github(\"fbreitwieser/pavian\")\n\npavian::runApp(port=5000)\nThen open your browser and visit localhost:5000\n\nOtherwise, just visit fbreitwieser.shinyapps.io/pavian.\n\n\n\n10.3.4.2 4.2 Visualizing metaphlan taxonomic profile with Krona\n%%bash\npython ../scripts/metaphlan2krona.py -p ../results/metaphlan/ERR5766177.metaphlan_profile.txt -k ../results/krona/ERR5766177_krona.out\nktImportText -o ../results/krona/ERR5766177_krona.html ../results/krona/ERR5766177_krona.out\nWriting ../results/krona/ERR5766177_krona.html...\n\n\n\n10.3.5 5. Getting modern reference data\nIn order to compare our sample with modern reference samples, I used the curatedMetagenomicsData package, which provides both curated metadata, and pre-computed metaphlan taxonomic profiles for published modern human samples. The full R code to get these data is available in curatedMetagenomics/get_sources.Rmd\nI pre-selected 200 gut microbiome samples from non-westernized (100) and westernized (100) from healthy, non-antibiotic users donors.\nlibrary(curatedMetagenomicData)\nlibrary(tidyverse)\n\nsampleMetadata %&gt;%\n  filter(body_site=='stool' & antibiotics_current_use  == 'no' & disease == 'healthy') %&gt;%\n  group_by(non_westernized) %&gt;%\n  sample_n(100) %&gt;%\n  ungroup() -&gt; selected_samples\n\nselected_samples %&gt;%\n  returnSamples(\"relative_abundance\") -&gt; rel_ab\n\ndata_ranks = splitByRanks(rel_ab)\n\nfor (r in names(data_ranks)){\n  print(r)\n  assay_rank = as.data.frame(assay(data_ranks[[r]]))\n  print(paste0(\"../../data/curated_metagenomics/modern_sources_\",tolower(r),\".csv\"))\n  write.csv(assay_rank, paste0(\"../../data/curated_metagenomics/modern_sources_\",tolower(r),\".csv\"))\n\n\nThe resulting metaphlan taxonomic profiles (split by taxonomic ranks) are available at\n../data/curated_metagenomics\nThe associated metadata is available at\n../data/metadata/curated_metagenomics_modern_sources.csv\n\n\n\n\n10.3.6 6. Bringing together ancient and modern data\nThis is the moment where we will the Pandas Python library to perform some data manipulation.\nWe will also use the Taxopy library to work to taxonomic informations.\n! pip install taxopy\nRequirement already satisfied: taxopy in /Users/maxime/mambaforge/envs/summer_school_microbiome/lib/python3.9/site-packages (0.10.0)\nimport pandas as pd\nimport taxopy\nimport pickle\nimport gzip\nwith gzip.open(\"../data/taxopy/taxdb.p.gz\", 'rb') as tdb:\n    taxo_db = pickle.load(tdb)\n! head ../results/metaphlan/ERR5766177.metaphlan_profile.txt\n#mpa_v30_CHOCOPhlAn_201901\n#/home/maxime_borry/.conda/envs/maxime/envs/summer_school_microbiome/bin/metaphlan ../results/fastp/ERR5766177.merged.fastq.gz\n--input_type fastq --bowtie2out ../results/metaphlan/ERR5766177.bt2.out --nproc 8\n#SampleID   Metaphlan_Analysis\n#clade_name NCBI_tax_id relative_abundance  additional_species\nk__Bacteria 2   82.23198\nk__Archaea  2157    17.76802\nk__Bacteria|p__Firmicutes   2|1239  33.47957\nk__Bacteria|p__Bacteroidetes    2|976   28.4209\nk__Bacteria|p__Actinobacteria   2|201174    20.33151\nk__Archaea|p__Euryarchaeota 2157|28890  17.76802\nancient_data = pd.read_csv(\"../results/metaphlan/ERR5766177.metaphlan_profile.txt\",\n                            comment=\"#\",\n                            delimiter=\"\\t\",\n                            names=['clade_name','NCBI_tax_id','relative_abundance','additional_species'])\nancient_data.head()\n\n\n\n\n\n\n\n\n\nclade_name\n\n\nNCBI_tax_id\n\n\nrelative_abundance\n\n\nadditional_species\n\n\n\n\n\n\n0\n\n\nk__Bacteria\n\n\n2\n\n\n82.23198\n\n\nNaN\n\n\n\n\n1\n\n\nk__Archaea\n\n\n2157\n\n\n17.76802\n\n\nNaN\n\n\n\n\n2\n\n\nk__Bacteria|p__Firmicutes\n\n\n2|1239\n\n\n33.47957\n\n\nNaN\n\n\n\n\n3\n\n\nk__Bacteria|p__Bacteroidetes\n\n\n2|976\n\n\n28.42090\n\n\nNaN\n\n\n\n\n4\n\n\nk__Bacteria|p__Actinobacteria\n\n\n2|201174\n\n\n20.33151\n\n\nNaN\n\n\n\n\n\n\nancient_data.sample(10)\n\n\n\n\n\n\n\n\n\nclade_name\n\n\nNCBI_tax_id\n\n\nrelative_abundance\n\n\nadditional_species\n\n\n\n\n\n\n1\n\n\nk__Archaea\n\n\n2157\n\n\n17.76802\n\n\nNaN\n\n\n\n\n46\n\n\nk__Bacteria|p__Bacteroidetes|c_Bacteroidia|o…\n\n\n2|976|200643|171549|171552|838|165179\n\n\n25.75544\n\n\nk__Bacteria|p__Bacteroidetes|c_Bacteroidia|o…\n\n\n\n\n55\n\n\nk__Bacteria|p__Firmicutes|c__Clostridia|o__Clo…\n\n\n2|1239|186801|186802|186803|189330|88431\n\n\n0.91178\n\n\nNaN\n\n\n\n\n18\n\n\nk__Archaea|p__Euryarchaeota|c_Halobacteria|o…\n\n\n2157|28890|183963|2235\n\n\n0.71177\n\n\nNaN\n\n\n\n\n36\n\n\nk__Bacteria|p__Actinobacteria|c__Actinobacteri…\n\n\n2|201174|1760|85004|31953|1678\n\n\n9.39377\n\n\nNaN\n\n\n\n\n65\n\n\nk__Bacteria|p__Actinobacteria|c__Actinobacteri…\n\n\n2|201174|1760|85004|31953|1678|216816\n\n\n0.05447\n\n\nk__Bacteria|p__Actinobacteria|c__Actinobacteri…\n\n\n\n\n37\n\n\nk__Bacteria|p__Firmicutes|c__Clostridia|o__Clo…\n\n\n2|1239|186801|186802|186803|\n\n\n2.16125\n\n\nNaN\n\n\n\n\n38\n\n\nk__Bacteria|p__Firmicutes|c__Clostridia|o__Clo…\n\n\n2|1239|186801|186802|541000|216851\n\n\n1.24537\n\n\nNaN\n\n\n\n\n26\n\n\nk__Bacteria|p__Actinobacteria|c__Actinobacteri…\n\n\n2|201174|1760|85004|31953\n\n\n9.39377\n\n\nNaN\n\n\n\n\n48\n\n\nk__Bacteria|p__Firmicutes|c__Clostridia|o__Clo…\n\n\n2|1239|186801|186802|541000|1263|40518\n\n\n14.96816\n\n\nk__Bacteria|p__Firmicutes|c__Clostridia|o__Clo…\n\n\n\n\n\n\nBecause for this analysis, we’re only going to look at the relative abundance, we’ll only this column, an the TAXID information\nancient_data = (\n    ancient_data\n    .rename(columns={'NCBI_tax_id': 'TAXID'})\n    .drop(['clade_name','additional_species'], axis=1)\n)\nAlways investigate your data at first !\nancient_data.relative_abundance.sum()\n700.00007\nPause and think: A relative abundance of 700%, really ?\nLet’s proceed further and try to understand what’s happening.\nancient_data.head()\n\n\n\n\n\n\n\n\n\nTAXID\n\n\nrelative_abundance\n\n\n\n\n\n\n0\n\n\n2\n\n\n82.23198\n\n\n\n\n1\n\n\n2157\n\n\n17.76802\n\n\n\n\n2\n\n\n2|1239\n\n\n33.47957\n\n\n\n\n3\n\n\n2|976\n\n\n28.42090\n\n\n\n\n4\n\n\n2|201174\n\n\n20.33151\n\n\n\n\n\n\nTo make sense of the TAXID, we will use taxopy to get all the taxonomic related informations such as:\n\nname of the taxon\nrank of the taxon\nlineage of the taxon\n\n#### This function is here to help us get the taxon information\n#### from the metaphlan taxonomic ID lineage, of the following form\n#### 2|976|200643|171549|171552|838|165179\n\ndef to_taxopy(taxid_entry, taxo_db):\n    \"\"\"Returns a taxopy taxon object\n    Args:\n        taxid_entry(str): metaphlan TAXID taxonomic lineage\n        taxo_db(taxopy database)\n    Returns:\n        (bool): Returns a taxopy taxon object\n    \"\"\"\n    taxid = taxid_entry.split(\"|\")[-1] # get the last element\n    try:\n        if len(taxid) &gt; 0:\n            return taxopy.Taxon(int(taxid), taxo_db) # if it's not empty, get the taxon corresponding to the taxid\n        else:\n            return taxopy.Taxon(12908, taxo_db) # otherwise, return the taxon associated with unclassified sequences\n    except taxopy.exceptions.TaxidError as e:\n        return taxopy.Taxon(12908, taxo_db)\nancient_data['taxopy'] = ancient_data['TAXID'].apply(to_taxopy, taxo_db=taxo_db)\nancient_data.head()\n\n\n\n\n\n\n\n\n\nTAXID\n\n\nrelative_abundance\n\n\ntaxopy\n\n\n\n\n\n\n0\n\n\n2\n\n\n82.23198\n\n\ns__Bacteria\n\n\n\n\n1\n\n\n2157\n\n\n17.76802\n\n\ns__Archaea\n\n\n\n\n2\n\n\n2|1239\n\n\n33.47957\n\n\ns__Bacteria;c__Terrabacteria group;p__Firmicutes\n\n\n\n\n3\n\n\n2|976\n\n\n28.42090\n\n\ns__Bacteria;c__FCB group;p__Bacteroidetes\n\n\n\n\n4\n\n\n2|201174\n\n\n20.33151\n\n\ns__Bacteria;c__Terrabacteria group;p__Actinoba…\n\n\n\n\n\n\nancient_data = ancient_data.assign(\n    rank = ancient_data.taxopy.apply(lambda x: x.rank),\n    name = ancient_data.taxopy.apply(lambda x: x.name),\n    lineage = ancient_data.taxopy.apply(lambda x: x.name_lineage),\n)\nancient_data\n\n\n\n\n\n\n\n\n\nTAXID\n\n\nrelative_abundance\n\n\ntaxopy\n\n\nrank\n\n\nname\n\n\nlineage\n\n\n\n\n\n\n0\n\n\n2\n\n\n82.23198\n\n\ns__Bacteria\n\n\nsuperkingdom\n\n\nBacteria\n\n\n[Bacteria, cellular organisms, root]\n\n\n\n\n1\n\n\n2157\n\n\n17.76802\n\n\ns__Archaea\n\n\nsuperkingdom\n\n\nArchaea\n\n\n[Archaea, cellular organisms, root]\n\n\n\n\n2\n\n\n2|1239\n\n\n33.47957\n\n\ns__Bacteria;c__Terrabacteria group;p__Firmicutes\n\n\nphylum\n\n\nFirmicutes\n\n\n[Firmicutes, Terrabacteria group, Bacteria, ce…\n\n\n\n\n3\n\n\n2|976\n\n\n28.42090\n\n\ns__Bacteria;c__FCB group;p__Bacteroidetes\n\n\nphylum\n\n\nBacteroidetes\n\n\n[Bacteroidetes, Bacteroidetes/Chlorobi group, …\n\n\n\n\n4\n\n\n2|201174\n\n\n20.33151\n\n\ns__Bacteria;c__Terrabacteria group;p__Actinoba…\n\n\nphylum\n\n\nActinobacteria\n\n\n[Actinobacteria, Terrabacteria group, Bacteria…\n\n\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n\n\n62\n\n\n2|1239|186801|186802|186803|572511|33039\n\n\n0.24910\n\n\ns__Bacteria;c__Terrabacteria group;p__Firmicut…\n\n\nspecies\n\n\n[Ruminococcus] torques\n\n\n[[Ruminococcus] torques, Mediterraneibacter, L…\n\n\n\n\n63\n\n\n2|201174|84998|84999|84107|1472762|1232426\n\n\n0.17084\n\n\ns__Bacteria;c__Terrabacteria group;p__Actinoba…\n\n\nspecies\n\n\n[Collinsella] massiliensis\n\n\n[[Collinsella] massiliensis, Enorma, Coriobact…\n\n\n\n\n64\n\n\n2|1239|186801|186802|186803|189330|39486\n\n\n0.07690\n\n\ns__Bacteria;c__Terrabacteria group;p__Firmicut…\n\n\nspecies\n\n\nDorea formicigenerans\n\n\n[Dorea formicigenerans, Dorea, Lachnospiraceae…\n\n\n\n\n65\n\n\n2|201174|1760|85004|31953|1678|216816\n\n\n0.05447\n\n\ns__Bacteria;c__Terrabacteria group;p__Actinoba…\n\n\nspecies\n\n\nBifidobacterium longum\n\n\n[Bifidobacterium longum, Bifidobacterium, Bifi…\n\n\n\n\n66\n\n\n2|1239|186801|186802|541000|1263|1262959\n\n\n0.01440\n\n\ns__Bacteria;c__Terrabacteria group;p__Firmicut…\n\n\nspecies\n\n\nRuminococcus sp. CAG:488\n\n\n[Ruminococcus sp. CAG:488, environmental sampl…\n\n\n\n\n\n\n67 rows × 6 columns\n\n\nBecause our modern data are split by ranks, we’ll first split our ancient sample by rank\nWhich of the entries are at the species rank level ?\nancient_species = ancient_data.query(\"rank == 'species'\")\nancient_species.head()\n\n\n\n\n\n\n\n\n\nTAXID\n\n\nrelative_abundance\n\n\ntaxopy\n\n\nrank\n\n\nname\n\n\nlineage\n\n\n\n\n\n\n46\n\n\n2|976|200643|171549|171552|838|165179\n\n\n25.75544\n\n\ns__Bacteria;c__FCB group;p__Bacteroidetes;c__B…\n\n\nspecies\n\n\nPrevotella copri\n\n\n[Prevotella copri, Prevotella, Prevotellaceae,…\n\n\n\n\n47\n\n\n2157|28890|183925|2158|2159|2172|2173\n\n\n17.05626\n\n\ns__Archaea;p__Euryarchaeota;c__Methanomada gro…\n\n\nspecies\n\n\nMethanobrevibacter smithii\n\n\n[Methanobrevibacter smithii, Methanobrevibacte…\n\n\n\n\n48\n\n\n2|1239|186801|186802|541000|1263|40518\n\n\n14.96816\n\n\ns__Bacteria;c__Terrabacteria group;p__Firmicut…\n\n\nspecies\n\n\nRuminococcus bromii\n\n\n[Ruminococcus bromii, Ruminococcus, Oscillospi…\n\n\n\n\n49\n\n\n2|1239|186801|186802|186803|841|301302\n\n\n13.57908\n\n\ns__Bacteria;c__Terrabacteria group;p__Firmicut…\n\n\nspecies\n\n\nRoseburia faecis\n\n\n[Roseburia faecis, Roseburia, Lachnospiraceae,…\n\n\n\n\n50\n\n\n2|201174|84998|84999|84107|102106|74426\n\n\n9.49165\n\n\ns__Bacteria;c__Terrabacteria group;p__Actinoba…\n\n\nspecies\n\n\nCollinsella aerofaciens\n\n\n[Collinsella aerofaciens, Collinsella, Corioba…\n\n\n\n\n\n\nLet’s do a bit of renaming to prepare for what’s coming next\nancient_species = ancient_species[['relative_abundance','name']].set_index('name').rename(columns={'relative_abundance':'ERR5766177'})\nancient_species.head()\n\n\n\n\n\n\n\n\n\nERR5766177\n\n\n\n\nname\n\n\n\n\n\n\n\n\nPrevotella copri\n\n\n25.75544\n\n\n\n\nMethanobrevibacter smithii\n\n\n17.05626\n\n\n\n\nRuminococcus bromii\n\n\n14.96816\n\n\n\n\nRoseburia faecis\n\n\n13.57908\n\n\n\n\nCollinsella aerofaciens\n\n\n9.49165\n\n\n\n\n\n\nancient_phylums = ancient_data.query(\"rank == 'phylum'\")\nancient_phylums = ancient_phylums[['relative_abundance','name']].set_index('name').rename(columns={'relative_abundance':'ERR5766177'})\nancient_phylums\n\n\n\n\n\n\n\n\n\nERR5766177\n\n\n\n\nname\n\n\n\n\n\n\n\n\nFirmicutes\n\n\n33.47957\n\n\n\n\nBacteroidetes\n\n\n28.42090\n\n\n\n\nActinobacteria\n\n\n20.33151\n\n\n\n\nEuryarchaeota\n\n\n17.76802\n\n\n\n\n\n\nNow, let’s go back to the 700% relative abundance issue…\nancient_data.groupby('rank')['relative_abundance'].sum()\nrank\nclass            99.72648\nfamily           83.49854\ngenus            97.56524\nno rank          19.48331\norder            99.72648\nphylum          100.00000\nspecies         100.00002\nsuperkingdom    100.00000\nName: relative_abundance, dtype: float64\nSeems better, right ?\nPause and think: why don’t we get exactly 100% ?\nNow let’s load our modern reference samples\nmodern_phylums = pd.read_csv(\"../data/curated_metagenomics/modern_sources_phylum.csv\", index_col=0)\nmodern_phylums.head()\n\n\n\n\n\n\n\n\n\nde028ad4-7ae6-11e9-a106-68b59976a384\n\n\nPNP_Main_283\n\n\nPNP_Validation_55\n\n\nG80275\n\n\nPNP_Main_363\n\n\nSAMEA7045572\n\n\nSAMEA7045355\n\n\nHD-13\n\n\nEGAR00001420773_9002000001423910\n\n\nSID5428-4\n\n\n…\n\n\nA46_02_1FE\n\n\nTZ_87532\n\n\nA94_01_1FE\n\n\nKHG_7\n\n\nLDK_4\n\n\nKHG_9\n\n\nA48_01_1FE\n\n\nKHG_1\n\n\nTZ_81781\n\n\nA09_01_1FE\n\n\n\n\n\n\nBacteroidetes\n\n\n0.00000\n\n\n17.44332\n\n\n82.86400\n\n\n69.99087\n\n\n31.93081\n\n\n51.76204\n\n\n53.32801\n\n\n74.59667\n\n\n8.81074\n\n\n26.39694\n\n\n…\n\n\n1.97760\n\n\n1.49601\n\n\n67.21410\n\n\n4.29848\n\n\n68.16890\n\n\n38.59709\n\n\n14.81828\n\n\n10.13908\n\n\n57.14031\n\n\n11.61544\n\n\n\n\nFirmicutes\n\n\n95.24231\n\n\n60.47031\n\n\n16.53946\n\n\n22.81977\n\n\n65.23075\n\n\n41.96928\n\n\n45.77661\n\n\n23.51065\n\n\n54.35341\n\n\n62.23094\n\n\n…\n\n\n76.68499\n\n\n78.13269\n\n\n29.72394\n\n\n33.51772\n\n\n19.11149\n\n\n46.87139\n\n\n72.68136\n\n\n35.43789\n\n\n40.57101\n\n\n24.72113\n\n\n\n\nProteobacteria\n\n\n4.49959\n\n\n0.77098\n\n\n0.05697\n\n\n4.07757\n\n\n0.27316\n\n\n3.33972\n\n\n0.02001\n\n\n1.72865\n\n\n0.00000\n\n\n1.81016\n\n\n…\n\n\n16.57250\n\n\n0.76159\n\n\n2.35058\n\n\n9.83772\n\n\n5.32392\n\n\n0.19699\n\n\n3.64655\n\n\n17.64151\n\n\n0.30580\n\n\n56.20177\n\n\n\n\nActinobacteria\n\n\n0.25809\n\n\n10.27631\n\n\n0.45187\n\n\n1.11902\n\n\n2.31075\n\n\n2.92715\n\n\n0.77667\n\n\n0.16403\n\n\n36.55138\n\n\n1.19951\n\n\n…\n\n\n3.01814\n\n\n19.20468\n\n\n0.69913\n\n\n46.99479\n\n\n7.39093\n\n\n14.26365\n\n\n5.47750\n\n\n36.77145\n\n\n1.16426\n\n\n7.40894\n\n\n\n\nVerrucomicrobia\n\n\n0.00000\n\n\n0.00784\n\n\n0.00000\n\n\n1.99276\n\n\n0.25451\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.09940\n\n\n3.29795\n\n\n…\n\n\n0.05011\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n\n\n\n\n5 rows × 200 columns\n\n\nmodern_species = pd.read_csv(\"../data/curated_metagenomics/modern_sources_species.csv\", index_col=0)\nmodern_species.head()\n\n\n\n\n\n\n\n\n\nde028ad4-7ae6-11e9-a106-68b59976a384\n\n\nPNP_Main_283\n\n\nPNP_Validation_55\n\n\nG80275\n\n\nPNP_Main_363\n\n\nSAMEA7045572\n\n\nSAMEA7045355\n\n\nHD-13\n\n\nEGAR00001420773_9002000001423910\n\n\nSID5428-4\n\n\n…\n\n\nA46_02_1FE\n\n\nTZ_87532\n\n\nA94_01_1FE\n\n\nKHG_7\n\n\nLDK_4\n\n\nKHG_9\n\n\nA48_01_1FE\n\n\nKHG_1\n\n\nTZ_81781\n\n\nA09_01_1FE\n\n\n\n\n\n\nBacteroides vulgatus\n\n\n0.0\n\n\n0.60446\n\n\n1.59911\n\n\n4.39085\n\n\n0.04494\n\n\n4.66505\n\n\n2.99431\n\n\n29.30325\n\n\n1.48560\n\n\n0.98818\n\n\n…\n\n\n0.20717\n\n\n0.0\n\n\n0.00309\n\n\n0.48891\n\n\n0.00000\n\n\n0.02230\n\n\n0.00000\n\n\n0.15112\n\n\n0.0\n\n\n0.00836\n\n\n\n\nBacteroides stercoris\n\n\n0.0\n\n\n0.00546\n\n\n0.00000\n\n\n0.00000\n\n\n2.50789\n\n\n0.00000\n\n\n20.57498\n\n\n8.28443\n\n\n1.23261\n\n\n0.00000\n\n\n…\n\n\n0.00000\n\n\n0.0\n\n\n0.00000\n\n\n0.00693\n\n\n0.00000\n\n\n0.02603\n\n\n0.00000\n\n\n0.19318\n\n\n0.0\n\n\n0.00000\n\n\n\n\nAcidaminococcus intestini\n\n\n0.0\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.32822\n\n\n0.00000\n\n\n…\n\n\n0.00000\n\n\n0.0\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.00000\n\n\n0.0\n\n\n0.00000\n\n\n\n\nEubacterium sp CAG 38\n\n\n0.0\n\n\n0.06712\n\n\n0.81149\n\n\n0.05247\n\n\n0.26027\n\n\n0.00000\n\n\n0.00000\n\n\n2.62415\n\n\n0.46585\n\n\n0.23372\n\n\n…\n\n\n0.78140\n\n\n0.0\n\n\n0.00000\n\n\n0.00499\n\n\n0.00000\n\n\n0.02446\n\n\n0.00000\n\n\n0.00000\n\n\n0.0\n\n\n0.00000\n\n\n\n\nParabacteroides distasonis\n\n\n0.0\n\n\n1.34931\n\n\n2.00672\n\n\n5.85067\n\n\n0.59019\n\n\n7.00027\n\n\n1.28075\n\n\n0.61758\n\n\n0.07383\n\n\n2.80355\n\n\n…\n\n\n0.11423\n\n\n0.0\n\n\n0.01181\n\n\n0.01386\n\n\n0.03111\n\n\n0.07463\n\n\n0.15597\n\n\n0.07541\n\n\n0.0\n\n\n0.01932\n\n\n\n\n\n\n5 rows × 200 columns\n\n\nNow, let’s merge our ancient sample with the modern data in one single table\nall_species = ancient_species.merge(modern_species, left_index=True, right_index=True, how='outer').fillna(0)\nall_phylums = ancient_phylums.merge(modern_phylums, left_index=True, right_index=True, how='outer').fillna(0)\nFinally, let’s load the metadata\nmetadata = pd.read_csv(\"../data/metadata/curated_metagenomics_modern_sources.csv\")\nmetadata.head()\n\n\n\n\n\n\n\n\n\nstudy_name\n\n\nsample_id\n\n\nsubject_id\n\n\nbody_site\n\n\nantibiotics_current_use\n\n\nstudy_condition\n\n\ndisease\n\n\nage\n\n\ninfant_age\n\n\nage_category\n\n\n…\n\n\nhla_drb11\n\n\nbirth_order\n\n\nage_twins_started_to_live_apart\n\n\nzigosity\n\n\nbrinkman_index\n\n\nalcohol_numeric\n\n\nbreastfeeding_duration\n\n\nformula_first_day\n\n\nALT\n\n\neGFR\n\n\n\n\n\n\n0\n\n\nShaoY_2019\n\n\nde028ad4-7ae6-11e9-a106-68b59976a384\n\n\nC01528_ba\n\n\nstool\n\n\nno\n\n\ncontrol\n\n\nhealthy\n\n\n0.0\n\n\n4.0\n\n\nnewborn\n\n\n…\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\n\n\n1\n\n\nZeeviD_2015\n\n\nPNP_Main_283\n\n\nPNP_Main_283\n\n\nstool\n\n\nno\n\n\ncontrol\n\n\nhealthy\n\n\nNaN\n\n\nNaN\n\n\nadult\n\n\n…\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\n\n\n2\n\n\nZeeviD_2015\n\n\nPNP_Validation_55\n\n\nPNP_Validation_55\n\n\nstool\n\n\nno\n\n\ncontrol\n\n\nhealthy\n\n\nNaN\n\n\nNaN\n\n\nadult\n\n\n…\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\n\n\n3\n\n\nVatanenT_2016\n\n\nG80275\n\n\nT014806\n\n\nstool\n\n\nno\n\n\ncontrol\n\n\nhealthy\n\n\n1.0\n\n\nNaN\n\n\nchild\n\n\n…\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\n\n\n4\n\n\nZeeviD_2015\n\n\nPNP_Main_363\n\n\nPNP_Main_363\n\n\nstool\n\n\nno\n\n\ncontrol\n\n\nhealthy\n\n\nNaN\n\n\nNaN\n\n\nadult\n\n\n…\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\n\n\n\n\n5 rows × 130 columns\n\n\n\n\n10.3.7 7. Comparing ancient and modern samples\n\n10.3.7.1 7.1 Taxonomic composition\nOne common plot in microbiome papers in a stacked barplot, often at the phylum or family level.\nFirst, we’ll do some renaming, to make the value of the metadata variables a bit easier to understand\ngroup_info = (\n    metadata['non_westernized']\n    .map({'no':'westernized','yes':'non_westernized'}) # for the non_westernized in the modern sample metadata, rename the value levels\n    .to_frame(name='group').set_index(metadata['sample_id']) # rename the column to group\n    .reset_index()\n    .append({'sample_id':'ERR5766177', 'group':'ancient'}, ignore_index=True) # add the ancient sample\n)\ngroup_info\n/var/folders/1c/l1qb09f15jddsh65f6xv1n_r0000gp/T/ipykernel_40830/27419655.py:2:\nFutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version.\nUse pandas.concat instead.\n  metadata['non_westernized']\n\n\n\n\n\n\n\n\n\nsample_id\n\n\ngroup\n\n\n\n\n\n\n0\n\n\nde028ad4-7ae6-11e9-a106-68b59976a384\n\n\nwesternized\n\n\n\n\n1\n\n\nPNP_Main_283\n\n\nwesternized\n\n\n\n\n2\n\n\nPNP_Validation_55\n\n\nwesternized\n\n\n\n\n3\n\n\nG80275\n\n\nwesternized\n\n\n\n\n4\n\n\nPNP_Main_363\n\n\nwesternized\n\n\n\n\n…\n\n\n…\n\n\n…\n\n\n\n\n196\n\n\nA48_01_1FE\n\n\nnon_westernized\n\n\n\n\n197\n\n\nKHG_1\n\n\nnon_westernized\n\n\n\n\n198\n\n\nTZ_81781\n\n\nnon_westernized\n\n\n\n\n199\n\n\nA09_01_1FE\n\n\nnon_westernized\n\n\n\n\n200\n\n\nERR5766177\n\n\nancient\n\n\n\n\n\n\n201 rows × 2 columns\n\n\nWe need transform our data in tidy format to plot with plotnine, a python clone of ggplot.\nWe then add the group information (Westernized, non westernized, or ancient sample), and compute the mean abundance for each phylum.\nFirst we transpose the dataframe to have the samples as index, and the phylums as columns\nWe then add the metadata information\n(\n    all_phylums\n    .transpose()\n    .merge(group_info, left_index=True, right_on='sample_id')\n)\n\n\n\n\n\n\n\n\n\nActinobacteria\n\n\nApicomplexa\n\n\nAscomycota\n\n\nBacteroidetes\n\n\nBasidiomycota\n\n\nCandidatus Melainabacteria\n\n\nChlamydiae\n\n\nChloroflexi\n\n\nCyanobacteria\n\n\nDeferribacteres\n\n\n…\n\n\nFusobacteria\n\n\nLentisphaerae\n\n\nPlanctomycetes\n\n\nProteobacteria\n\n\nSpirochaetes\n\n\nSynergistetes\n\n\nTenericutes\n\n\nVerrucomicrobia\n\n\nsample_id\n\n\ngroup\n\n\n\n\n\n\n200\n\n\n20.33151\n\n\n0.0\n\n\n0.0\n\n\n28.42090\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n…\n\n\n0.0\n\n\n0.00000\n\n\n0.0\n\n\n0.00000\n\n\n0.00000\n\n\n0.0\n\n\n0.0\n\n\n0.00000\n\n\nERR5766177\n\n\nancient\n\n\n\n\n0\n\n\n0.25809\n\n\n0.0\n\n\n0.0\n\n\n0.00000\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n…\n\n\n0.0\n\n\n0.00000\n\n\n0.0\n\n\n4.49959\n\n\n0.00000\n\n\n0.0\n\n\n0.0\n\n\n0.00000\n\n\nde028ad4-7ae6-11e9-a106-68b59976a384\n\n\nwesternized\n\n\n\n\n1\n\n\n10.27631\n\n\n0.0\n\n\n0.0\n\n\n17.44332\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n…\n\n\n0.0\n\n\n0.01486\n\n\n0.0\n\n\n0.77098\n\n\n0.00000\n\n\n0.0\n\n\n0.0\n\n\n0.00784\n\n\nPNP_Main_283\n\n\nwesternized\n\n\n\n\n2\n\n\n0.45187\n\n\n0.0\n\n\n0.0\n\n\n82.86400\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n…\n\n\n0.0\n\n\n0.00000\n\n\n0.0\n\n\n0.05697\n\n\n0.00000\n\n\n0.0\n\n\n0.0\n\n\n0.00000\n\n\nPNP_Validation_55\n\n\nwesternized\n\n\n\n\n3\n\n\n1.11902\n\n\n0.0\n\n\n0.0\n\n\n69.99087\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n…\n\n\n0.0\n\n\n0.00000\n\n\n0.0\n\n\n4.07757\n\n\n0.00000\n\n\n0.0\n\n\n0.0\n\n\n1.99276\n\n\nG80275\n\n\nwesternized\n\n\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n\n\n195\n\n\n14.26365\n\n\n0.0\n\n\n0.0\n\n\n38.59709\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n…\n\n\n0.0\n\n\n0.00000\n\n\n0.0\n\n\n0.19699\n\n\n0.00000\n\n\n0.0\n\n\n0.0\n\n\n0.00000\n\n\nKHG_9\n\n\nnon_westernized\n\n\n\n\n196\n\n\n5.47750\n\n\n0.0\n\n\n0.0\n\n\n14.81828\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n…\n\n\n0.0\n\n\n0.00000\n\n\n0.0\n\n\n3.64655\n\n\n0.09964\n\n\n0.0\n\n\n0.0\n\n\n0.00000\n\n\nA48_01_1FE\n\n\nnon_westernized\n\n\n\n\n197\n\n\n36.77145\n\n\n0.0\n\n\n0.0\n\n\n10.13908\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n…\n\n\n0.0\n\n\n0.00000\n\n\n0.0\n\n\n17.64151\n\n\n0.00000\n\n\n0.0\n\n\n0.0\n\n\n0.00000\n\n\nKHG_1\n\n\nnon_westernized\n\n\n\n\n198\n\n\n1.16426\n\n\n0.0\n\n\n0.0\n\n\n57.14031\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n…\n\n\n0.0\n\n\n0.00000\n\n\n0.0\n\n\n0.30580\n\n\n0.70467\n\n\n0.0\n\n\n0.0\n\n\n0.00000\n\n\nTZ_81781\n\n\nnon_westernized\n\n\n\n\n199\n\n\n7.40894\n\n\n0.0\n\n\n0.0\n\n\n11.61544\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n…\n\n\n0.0\n\n\n0.00000\n\n\n0.0\n\n\n56.20177\n\n\n0.00000\n\n\n0.0\n\n\n0.0\n\n\n0.00000\n\n\nA09_01_1FE\n\n\nnon_westernized\n\n\n\n\n\n\n201 rows × 24 columns\n\n\nNow, we need it in the tidy format\ntidy_phylums = (\n    all_phylums\n    .transpose()\n    .merge(group_info, left_index=True, right_on='sample_id')\n    .melt(id_vars=['sample_id', 'group'], value_name='relative_abundance', var_name='Phylum', ignore_index=True)\n)\nFinally, we only want to keep the mean relative abundance for each phylum\ntidy_phylums = tidy_phylums.groupby(['group', 'Phylum']).mean().reset_index()\ntidy_phylums.groupby('group')['relative_abundance'].sum()\ngroup\nancient            100.000000\nnon_westernized     99.710255\nwesternized         99.905089\nName: relative_abundance, dtype: float64\nfrom plotnine import *\nggplot(tidy_phylums, aes(x='group', y='relative_abundance', fill='Phylum')) \\\n+ geom_bar(position='stack', stat='identity') \\\n+ ylab('mean abundance') \\\n+ xlab(\"\") \\\n+ theme_classic()\n\n&lt;ggplot: (406187548)&gt;\n\n\n10.3.7.2 7.2 Ecological diversity\n\n10.3.7.2.1 7.2.1 Alpha diversity\nAlpha diversity is the measure of diversity withing each sample. It is used to estimate how many species are present in a sample, and how diverse they are.\nWe’ll use the python library scikit-bio to compute it, and the plotnine library (a python port of ggplot2 to visualize the results).\nimport skbio\nLet’s compute the species richness, the Shannon, and Simpson index of diversity index\nshannon = skbio.diversity.alpha_diversity(metric='shannon', counts=all_species.transpose(), ids=all_species.columns)\nsimpson = skbio.diversity.alpha_diversity(metric='simpson', counts=all_species.transpose(), ids=all_species.columns)\nrichness = (all_species != 0).astype(int).sum(axis=0)\nalpha_diversity = (shannon.to_frame(name='shannon')\n                   .merge(simpson.to_frame(name='simpson'), left_index=True, right_index=True)\n                   .merge(richness.to_frame(name='richness'), left_index=True, right_index=True))\nalpha_diversity\n\n\n\n\n\n\n\n\n\nshannon\n\n\nsimpson\n\n\nrichness\n\n\n\n\n\n\nERR5766177\n\n\n3.032945\n\n\n0.844769\n\n\n21\n\n\n\n\nde028ad4-7ae6-11e9-a106-68b59976a384\n\n\n0.798112\n\n\n0.251280\n\n\n11\n\n\n\n\nPNP_Main_283\n\n\n5.092878\n\n\n0.954159\n\n\n118\n\n\n\n\nPNP_Validation_55\n\n\n3.670162\n\n\n0.812438\n\n\n72\n\n\n\n\nG80275\n\n\n3.831358\n\n\n0.876712\n\n\n66\n\n\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n\n\nKHG_9\n\n\n3.884285\n\n\n0.861683\n\n\n87\n\n\n\n\nA48_01_1FE\n\n\n4.377755\n\n\n0.930024\n\n\n53\n\n\n\n\nKHG_1\n\n\n3.733834\n\n\n0.875335\n\n\n108\n\n\n\n\nTZ_81781\n\n\n2.881856\n\n\n0.719491\n\n\n44\n\n\n\n\nA09_01_1FE\n\n\n2.982322\n\n\n0.719962\n\n\n75\n\n\n\n\n\n\n201 rows × 3 columns\n\n\nLet’s load the group information from the metadata\nalpha_diversity = (\n    alpha_diversity\n    .merge(metadata[['sample_id', 'non_westernized']], left_index=True, right_on='sample_id', how='outer')\n    .set_index('sample_id')\n    .rename(columns={'non_westernized':'group'})\n)\nalpha_diversity['group'] = alpha_diversity['group'].replace({'yes':'non_westernized','no':'westernized', pd.NA:'ERR5766177'})\nalpha_diversity\n\n\n\n\n\n\n\n\n\nshannon\n\n\nsimpson\n\n\nrichness\n\n\ngroup\n\n\n\n\nsample_id\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nERR5766177\n\n\n3.032945\n\n\n0.844769\n\n\n21\n\n\nERR5766177\n\n\n\n\nde028ad4-7ae6-11e9-a106-68b59976a384\n\n\n0.798112\n\n\n0.251280\n\n\n11\n\n\nwesternized\n\n\n\n\nPNP_Main_283\n\n\n5.092878\n\n\n0.954159\n\n\n118\n\n\nwesternized\n\n\n\n\nPNP_Validation_55\n\n\n3.670162\n\n\n0.812438\n\n\n72\n\n\nwesternized\n\n\n\n\nG80275\n\n\n3.831358\n\n\n0.876712\n\n\n66\n\n\nwesternized\n\n\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n\n\nKHG_9\n\n\n3.884285\n\n\n0.861683\n\n\n87\n\n\nnon_westernized\n\n\n\n\nA48_01_1FE\n\n\n4.377755\n\n\n0.930024\n\n\n53\n\n\nnon_westernized\n\n\n\n\nKHG_1\n\n\n3.733834\n\n\n0.875335\n\n\n108\n\n\nnon_westernized\n\n\n\n\nTZ_81781\n\n\n2.881856\n\n\n0.719491\n\n\n44\n\n\nnon_westernized\n\n\n\n\nA09_01_1FE\n\n\n2.982322\n\n\n0.719962\n\n\n75\n\n\nnon_westernized\n\n\n\n\n\n\n201 rows × 4 columns\n\n\nalpha_diversity = alpha_diversity.melt(id_vars='group', value_name='alpha diversity', var_name='diversity_index', ignore_index=False)\nalpha_diversity\n\n\n\n\n\n\n\n\n\ngroup\n\n\ndiversity_index\n\n\nalpha diversity\n\n\n\n\nsample_id\n\n\n\n\n\n\n\n\n\n\n\n\nERR5766177\n\n\nERR5766177\n\n\nshannon\n\n\n3.032945\n\n\n\n\nde028ad4-7ae6-11e9-a106-68b59976a384\n\n\nwesternized\n\n\nshannon\n\n\n0.798112\n\n\n\n\nPNP_Main_283\n\n\nwesternized\n\n\nshannon\n\n\n5.092878\n\n\n\n\nPNP_Validation_55\n\n\nwesternized\n\n\nshannon\n\n\n3.670162\n\n\n\n\nG80275\n\n\nwesternized\n\n\nshannon\n\n\n3.831358\n\n\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n\n\nKHG_9\n\n\nnon_westernized\n\n\nrichness\n\n\n87.000000\n\n\n\n\nA48_01_1FE\n\n\nnon_westernized\n\n\nrichness\n\n\n53.000000\n\n\n\n\nKHG_1\n\n\nnon_westernized\n\n\nrichness\n\n\n108.000000\n\n\n\n\nTZ_81781\n\n\nnon_westernized\n\n\nrichness\n\n\n44.000000\n\n\n\n\nA09_01_1FE\n\n\nnon_westernized\n\n\nrichness\n\n\n75.000000\n\n\n\n\n\n\n603 rows × 3 columns\n\n\ng = ggplot(alpha_diversity, aes(x='group', y='alpha diversity', color='group'))\ng += geom_violin()\ng += geom_jitter()\ng += theme_classic()\ng += facet_wrap('~diversity_index', scales = 'free')\ng += theme(axis_text_x=element_text(rotation=45, hjust=1))\ng += scale_color_manual({'ERR5766177':'#DB5F57','westernized':'#5F57DB','non_westernized':'#57DB5E'})\ng += theme(subplots_adjust={'wspace': 0.15})\ng\n\n\n\npng\n\n\n&lt;ggplot: (407407577)&gt;\nPause and think: Why do we observe a smaller species richness and diversity in our sample ?\n\n\n\n10.3.7.3 7.2.2 Beta diversity\nThe Beta diversity is the measure of diversity between a pair of samples. It is used to compare the diversity between samples and see how they relate.\nWe will compute the beta diversity using the bray-curtis dissimilarity\nbeta_diversity = skbio.diversity.beta_diversity(metric='braycurtis', counts=all_species.transpose(), ids=all_species.columns, validate=True)\nWe get a distance matrix\nprint(beta_diversity)\n201x201 distance matrix\nIDs:\n'ERR5766177', 'de028ad4-7ae6-11e9-a106-68b59976a384', 'PNP_Main_283', ...\nData:\n[[0.         1.         0.81508134 ... 0.85716612 0.69790092 0.8303726 ]\n [1.         0.         0.99988327 ... 0.99853413 0.994116   0.99877258]\n [0.81508134 0.99988327 0.         ... 0.82311942 0.87202543 0.91363156]\n ...\n [0.85716612 0.99853413 0.82311942 ... 0.         0.84253376 0.76616679]\n [0.69790092 0.994116   0.87202543 ... 0.84253376 0.         0.82409272]\n [0.8303726  0.99877258 0.91363156 ... 0.76616679 0.82409272 0.        ]]\nTo visualize this distance matrix in a lower dimensional space, we’ll use a PCoA, which is is a method very similar to a PCA, but taking a distance matrix as input.\npcoa = skbio.stats.ordination.pcoa(beta_diversity)\n/Users/maxime/mambaforge/envs/summer_school_microbiome/lib/python3.9/site-packages/skbio/stats/ordination/_principal_coordinate_analysis.py:143: RuntimeWarning:\nThe result contains negative eigenvalues. Please compare their magnitude with the magnitude of some of the largest positive eigenvalues.\nIf the negative ones are smaller, it's probably safe to ignore them, but if they are large in magnitude, the results won't be useful.\nSee the Notes section for more details. The smallest eigenvalue is -0.25334842745723996 and the largest is 10.204440747987945.\npcoa.samples\n\n\n\n\n\n\n\n\n\nPC1\n\n\nPC2\n\n\nPC3\n\n\nPC4\n\n\nPC5\n\n\nPC6\n\n\nPC7\n\n\nPC8\n\n\nPC9\n\n\nPC10\n\n\n…\n\n\nPC192\n\n\nPC193\n\n\nPC194\n\n\nPC195\n\n\nPC196\n\n\nPC197\n\n\nPC198\n\n\nPC199\n\n\nPC200\n\n\nPC201\n\n\n\n\n\n\nERR5766177\n\n\n0.216901\n\n\n-0.039778\n\n\n0.107412\n\n\n0.273272\n\n\n0.020540\n\n\n0.114876\n\n\n-0.256332\n\n\n-0.151069\n\n\n0.097451\n\n\n0.060211\n\n\n…\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n\n\nde028ad4-7ae6-11e9-a106-68b59976a384\n\n\n-0.099355\n\n\n0.145224\n\n\n-0.191676\n\n\n0.127626\n\n\n0.119754\n\n\n-0.132209\n\n\n-0.097382\n\n\n0.036728\n\n\n0.081294\n\n\n-0.056686\n\n\n…\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n\n\nPNP_Main_283\n\n\n-0.214108\n\n\n-0.147466\n\n\n0.116027\n\n\n0.090059\n\n\n0.076644\n\n\n0.111536\n\n\n0.092115\n\n\n0.026477\n\n\n-0.006460\n\n\n-0.018592\n\n\n…\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n\n\nPNP_Validation_55\n\n\n0.244827\n\n\n-0.173996\n\n\n-0.311197\n\n\n-0.012836\n\n\n0.031759\n\n\n0.117548\n\n\n0.148715\n\n\n-0.135641\n\n\n0.034730\n\n\n-0.009395\n\n\n…\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n\n\nG80275\n\n\n-0.261358\n\n\n-0.077147\n\n\n-0.254374\n\n\n-0.065932\n\n\n0.088538\n\n\n0.165970\n\n\n-0.005260\n\n\n-0.028739\n\n\n-0.002016\n\n\n0.015719\n\n\n…\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n…\n\n\n\n\nKHG_9\n\n\n0.296057\n\n\n-0.150300\n\n\n0.013941\n\n\n0.032649\n\n\n-0.147692\n\n\n0.019663\n\n\n-0.063120\n\n\n-0.034453\n\n\n-0.073514\n\n\n0.070085\n\n\n…\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n\n\nA48_01_1FE\n\n\n0.110621\n\n\n0.030971\n\n\n0.154231\n\n\n-0.185961\n\n\n-0.008512\n\n\n-0.103420\n\n\n0.028169\n\n\n-0.044530\n\n\n0.041902\n\n\n0.068597\n\n\n…\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n\n\nKHG_1\n\n\n-0.100009\n\n\n0.167885\n\n\n0.009915\n\n\n0.076842\n\n\n-0.405582\n\n\n-0.039111\n\n\n-0.006421\n\n\n-0.009774\n\n\n-0.072252\n\n\n0.150000\n\n\n…\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n\n\nTZ_81781\n\n\n0.405716\n\n\n-0.139297\n\n\n-0.075026\n\n\n-0.079716\n\n\n-0.053264\n\n\n-0.119271\n\n\n0.068261\n\n\n-0.018821\n\n\n0.198152\n\n\n-0.012792\n\n\n…\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n\n\nA09_01_1FE\n\n\n0.089101\n\n\n0.471135\n\n\n0.069629\n\n\n-0.125644\n\n\n-0.036793\n\n\n0.115151\n\n\n0.060507\n\n\n-0.000912\n\n\n-0.027239\n\n\n-0.138436\n\n\n…\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n0.0\n\n\n\n\n\n\n201 rows × 201 columns\n\n\nLet’s look at the variance explained by the first axes by using a scree plot\nvar_explained = pcoa.proportion_explained[:9].to_frame(name='variance explained').reset_index().rename(columns={'index':'PC'})\nggplot(var_explained, aes(x='PC', y='variance explained', group=1)) \\\n+ geom_point() \\\n+ geom_line() \\\n+ theme_classic()\n\n\n\npng\n\n\n&lt;ggplot: (407531271)&gt;\nIn this scree plot, we’re looking for the “elbow”, where there is a drop in the slope. Here, it seems that most of the variance is captures by the 3 first principal components\npcoa_embed = pcoa.samples[['PC1','PC2','PC3']].rename_axis('sample').reset_index()\npcoa_embed = (\n    pcoa_embed\n    .merge(metadata[['sample_id', 'non_westernized']], left_on='sample', right_on='sample_id', how='outer')\n    .drop('sample_id', axis=1)\n    .rename(columns={'non_westernized':'group'})\n)\npcoa_embed['group'] = pcoa_embed['group'].replace({'yes':'non_westernized','no':'westernized', pd.NA:'ERR5766177'})\nLet’s first look at these components with 2D plots\nggplot(pcoa_embed, aes(x='PC1', y='PC2', color='group')) \\\n+ geom_point() \\\n+ theme_classic() \\\n+ scale_color_manual({'ERR5766177':'#DB5F57','westernized':'#5F57DB','non_westernized':'#57DB5E'})\n\n\n\npng\n\n\n&lt;ggplot: (407572134)&gt;\nggplot(pcoa_embed, aes(x='PC1', y='PC3', color='group')) +\ngeom_point() +\ntheme_classic() +\nscale_color_manual({'ERR5766177':'#DB5F57','westernized':'#5F57DB','non_westernized':'#57DB5E'})\n\n\n\npng\n\n\n&lt;ggplot: (407612651)&gt;\nThen with a 3d plot\nimport plotly.express as px\n\nfig = px.scatter_3d(pcoa_embed, x=\"PC1\", y=\"PC2\", z=\"PC3\",\n                  color = \"group\",\n                  color_discrete_map={'ERR5766177':'#DB5F57','westernized':'#5F57DB','non_westernized':'#57DB5E'},\n                  hover_name=\"sample\")\nfig.show()\n\n\n\n\n\n\nImportant\n\n\n\n3D PLOT HERE NOT DISPLAYED DUE TO RENDERING LIMITATIONS - PLEASE SEE JUPYTER NOTEBOOK\n\n\nPause and think: How do you think this embedding represents how our sample relates to modern reference samples ?\nWe can also visualize this distance matrix using a clustered heatmap, where pairs of sample with a small beta diversity are clustered together\nimport seaborn as sns\nimport scipy.spatial as sp, scipy.cluster.hierarchy as hc\npcoa_embed['colour'] = pcoa_embed['group'].map({'ERR5766177':'#DB5F57','westernized':'#5F57DB','non_westernized':'#57DB5E'})\nlinkage = hc.linkage(sp.distance.squareform(beta_diversity.to_data_frame()), method='average')\n\nsns.clustermap(\n    beta_diversity.to_data_frame(),\n    row_linkage=linkage,\n    col_linkage=linkage,\n    row_colors = pcoa_embed['colour'].to_list()\n)\n&lt;seaborn.matrix.ClusterGrid at 0x185b56100&gt;\n\n\n\npng\n\n\n\n\n\n10.3.8 8. Additional steps\n\n10.3.8.1 8.1 Source tracking\nSourcetracker is a program that can estimate the proportion of different sources (reference biomes) contained in a sample (a sink). However, because of the statistical framework that it uses (MCMC with Gibbs sampling), we recommend to limit the number of source samples to greatly reduce runtime\nFirst, you will need to transform our relative abundance table to counts for SourceTracker\nall_species_counts = all_species.multiply(1000000).astype(int)\nmin_count = all_species_counts.sum(axis=0).min()\nmin_count\n95327810\nExporting the count table to tsv\nall_species_counts.to_csv(\"../results/sourcetracker2/all_species_counts.tsv\", sep=\"\\t\", index_label='Taxon')\nConverting to biom format\n!biom convert -i ../results/sourcetracker2/all_species_counts.tsv \\\n-o ../results/sourcetracker2/all_species_counts.biom \\\n--table-type=\"Taxon table\" --to-hdf5\nConverting the metadata to Sourtracker format\nst2_metadata = metadata[['sample_id', 'non_westernized']].rename(columns={'non_westernized':'Env', 'sample_id':'#SampleID'})\nst2_metadata['Env'] = st2_metadata['Env'].replace({'yes':'non_westernized','no':'westernized'})\nst2_metadata['SourceSink'] = ['source'] * st2_metadata.shape[0]\nWe subset it to select only 10 samples from each source\nst2_metadata = st2_metadata.groupby('Env').sample(10).reset_index()\nst2_metadata = st2_metadata.append({'#SampleID':'ERR5766177', 'Env':'-','SourceSink':'sink'},\n                                   ignore_index=True)[['#SampleID','SourceSink','Env']].set_index('#SampleID')\n/var/folders/1c/l1qb09f15jddsh65f6xv1n_r0000gp/T/ipykernel_40830/2882312005.py:1: FutureWarning:\n\nThe frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\nst2_metadata.to_csv(\"../results/sourcetracker2/labels_st2.tsv\", sep=\"\\t\", index_label='#SampleID')\nsourcetracker2 gibbs \\\n    -i ../results/sourcetracker2/all_species_counts.biom \\\n    -m ../results/sourcetracker2/labels_st2.tsv \\\n    -o ../results/sourcetracker2/st2 \\\n    --source_rarefaction_depth 95327810 \\\n    --sink_rarefaction_depth 95327810 \\\n    --jobs 10\nBecause SourceTracker is relying on MCMC sampling, it can very slow to run (which is why we won’t run it here)\nAmong alternative faster solutions for source tracking are (among others):\n\nFEAST (article, code),\nSourcepredict (article, code)\n\n\n\n10.3.8.2 8.2 The next steps:\n\nDamage Analysis (mapDamage, DamageProfiler, PyDamage)\nAssembly (megahit, metaSPAdes), binning (metabat2, maxbin2, dastool), and bin validation (checkm, gunc)\nFunctional analysis (Prokka, Humann)\nDifferential abundance (Maaslin2, Lefse, Songbird, GLM, Mixed effect models). Nice review by Wallen 2021\ngenotyping\nPhylogenies\n…"
  },
  {
    "objectID": "functional-profiling.html#lecture",
    "href": "functional-profiling.html#lecture",
    "title": "11  Functional Profiling",
    "section": "11.1 Lecture",
    "text": "11.1 Lecture\nLecture slides and video from the 2022 edition of the summer school.\n\n\nPDF version of these slides can be downloaded from here."
  },
  {
    "objectID": "functional-profiling.html#preparation",
    "href": "functional-profiling.html#preparation",
    "title": "11  Functional Profiling",
    "section": "11.2 Preparation",
    "text": "11.2 Preparation\nThe data and conda environment .yaml file for this practical session can be downloaded from here: https://doi.org/10.5281/zenodo.6983188. See instructions on page.\nChange into the session directory\ncd /&lt;path&gt;/&lt;to&gt;/functional-genomics/\nLoad the conda environment.\nconda activate phylogenomics-functional\nOpen R Studio from within the conda environment, and we can load the required libraries for this walkthrough.\nlibrary(mixOmics) ## For PCA generation\n\n## Utility packages (pretty stuff)\nlibrary(knitr)\nlibrary(data.table)\nlibrary(tidyverse)\nlibrary(gplots)\nlibrary(ggrepel)\nlibrary(viridis)\nlibrary(patchwork)"
  },
  {
    "objectID": "functional-profiling.html#humann3-pathways",
    "href": "functional-profiling.html#humann3-pathways",
    "title": "11  Functional Profiling",
    "section": "11.3 HUMAnN3 Pathways",
    "text": "11.3 HUMAnN3 Pathways\nFirst, we need to run HUMMAn3 to align reads against gene databases and convert to gene family names counts.\n\n\n\n\n\n\nWarning\n\n\n\nWe will not run HUMANn3 here as it requires very large databases and takes a long time to run, so we will give you the commands you normally would run but we provide with you pre-made results files before you (see below).\n## DO NOT RUN!\n\n# run humann3\nhumann3 --input file.fastq --output output --threads &lt;threads&gt;\n\n# join all output tables (can do for both gene and pathways)\nhumann_join_tables -i output/ -o genefamilies_joined.tsv --file_name unmapped_genefamilies\n\n# normalize the output (here by tss - total sum scaling, can do for both gene and pathways)\nhumann_renorm_table --input genefamilies_joined.tsv --output genefamilies_joined_cpm.tsv --units tss\n\n# regroup the table to combine gene families (standardise gene family IDs across taxa)\nhumann_regroup_table --input genefamilies_joined_cpm.tsv --output genefamilies_joined_cpm_ur90rxn.tsv --groups uniref90_rxn\n\n# give the gene families names\nhumann_rename_table --input genefamilies_joined_cpm_ur90rxn.tsv --output genefamilies_joined_cpm_ur90rxn_names.tsv -n metacyc-rxn"
  },
  {
    "objectID": "functional-profiling.html#humann3-tables",
    "href": "functional-profiling.html#humann3-tables",
    "title": "11  Functional Profiling",
    "section": "11.4 humann3 tables",
    "text": "11.4 humann3 tables\nFirst lets load a pre-made pathway abundance file\n## load the species and genus tables generated with humann3\nhumann3_path_full &lt;- fread(\"./pathabundance_joined_cpm.tsv\")\nhumann3_path_full &lt;- as_tibble(humann3_path_full)\n\n# clean the file names\nhumann3_path_full &lt;- rename(humann3_path_full, Pathway = `# Pathway`)\ncolnames(humann3_path_full) &lt;- gsub(\".unmapped_Abundance\",\"\", colnames(humann3_path_full))\ncolnames(humann3_path_full) &lt;- gsub(\".SG1\",\"\", colnames(humann3_path_full))\n\n# remove unmapped and ungrouped reads\nhumann3_path &lt;- humann3_path_full %&gt;% filter(!str_detect(Pathway, \"UNMAPPED|UNINTEGRATED\"))\nThen lets load associated sample metadata to help make it easier for comparative analysis and make actual informative inferences.\nThe data being used in this session, is from Velsko et al. 2022 (PNAS Nexus), where we tried to find associations between dental pathologies and taxonomic and genome content. We had a large skeletal collection from a single site in the Netherlands, with a lot of osteological metadata. The study aimed to see if there were any links between the oral microbiome and groups of dental pathologies.\n# load the metadata file\nfull_metadata &lt;- fread(\"full_combined_metadata.tsv\")\n\n\n## Example of metadata\ntibble(full_metadata %&gt;%\n    filter(Site_code == \"MID\") %&gt;%\n    select(Site, Time_period, Library_ID, Sequencing_instrument, Pipenotch, Max_Perio_Score, `%teeth_with_caries`))\nFirst step: we can pre-define various functions for generate PCAs we will use downstream - you don’t have to worry about these too much they are just custom functions to quickly plot PCAs from a mixOmics PCA output object with ggplot, but we leave the code here for if you’re curious.\n# plot PCA with colored dots and the title including the # of species or genera\nplot_pca &lt;- function(df, pc1, pc2, color_group, shape_group, ncomps) {\n    metadata_group_colors &lt;- get(paste(color_group, \"_colors\", sep = \"\"))\n    metadata_group_shapes &lt;- get(paste(shape_group, \"_shapes\", sep = \"\"))\n\n    pca.list &lt;- mixOmics::pca(df, ncomp = ncomps, logratio = 'CLR')\n\n    ## Pull out loadings\n    exp_var &lt;- paste0(round(pca.list$explained_variance * 100, 2), \"%\")\n    df_X &lt;- pca.list$variates$X %&gt;%\n              as.data.frame() %&gt;%\n              rownames_to_column(\"Library_ID\") %&gt;%\n              inner_join(full_metadata, by = \"Library_ID\")\n\n    color_group = df_X[[color_group]]\n    shape_group = df_X[[shape_group]]\n\n    ## Selecting which PCs to plot\n    if (pc1 == 'PC1') {\n        pc1 &lt;- df_X$PC1\n        exp_var_pc1 &lt;- exp_var[1]\n        xaxis &lt;- c(\"PC1\")\n    }  else if (pc1 == 'PC2') {\n        pc1 &lt;- df_X$PC2\n        exp_var_pc1 &lt;- exp_var[2]\n        xaxis &lt;- c(\"PC2\")\n    } else if (pc1 == 'PC3') {\n        pc1 &lt;- df_X$PC3\n        exp_var_pc1 &lt;- exp_var[3]\n        xaxis &lt;- c(\"PC3\")\n    }\n\n    if (pc2 == 'PC1') {\n        pc2 &lt;- df_X$PC1\n        exp_var_pc2 &lt;- exp_var[1]\n        yaxis &lt;- c(\"PC1\")\n    }  else if (pc2 == 'PC2') {\n        pc2 &lt;- df_X$PC2\n        exp_var_pc2 &lt;- exp_var[2]\n        yaxis &lt;- c(\"PC2\")\n    } else if (pc2 == 'PC3') {\n        pc2 &lt;- df_X$PC3\n        exp_var_pc2 &lt;- exp_var[3]\n        yaxis &lt;- c(\"PC3\")\n    }\n\n    ## Generate figure\n    pca_plot &lt;- ggplot(df_X, aes(pc1, pc2)) +\n     geom_point(aes(fill = color_group, shape = shape_group), size = 4.5, stroke = 0.3) +\n     scale_fill_manual(values = metadata_group_colors) +\n     scale_shape_manual(values = metadata_group_shapes) +\n     # stat_ellipse() +\n     xlab(paste(xaxis, \" - \", exp_var_pc1)) +\n     ylab(paste(yaxis, \" - \", exp_var_pc2)) +\n     theme_minimal(base_size = 16) +\n     theme(text = element_text(size=16)) +\n     theme(legend.title = element_blank(),\n           legend.key.size = unit(2,\"mm\"),\n           legend.text = element_text(size = 6)) +\n     theme(legend.position = \"top\")\n\n    return(pca_plot)\n}\n\n# for continuous data\nplot_pca_cont &lt;- function(df, pc1, pc2, color_group, shape_group, ncomps, title_text) {\n\n    pca.list &lt;- mixOmics::pca(df, ncomp = ncomps, logratio = 'CLR')\n\n    exp_var &lt;- paste0(round(pca.list$explained_variance * 100, 2), \"%\")\n    df_X &lt;- pca.list$variates$X %&gt;%\n              as.data.frame() %&gt;%\n              rownames_to_column(\"Library_ID\") %&gt;%\n              inner_join(full_metadata, by = \"Library_ID\")\n\n    color_group = df_X[[color_group]]\n    shape_group = df_X[[shape_group]]\n\n    if (pc1 == 'PC1') {\n        pc1 &lt;- df_X$PC1\n        exp_var_pc1 &lt;- exp_var[1]\n        xaxis &lt;- c(\"PC1\")\n    }  else if (pc1 == 'PC2') {\n        pc1 &lt;- df_X$PC2\n        exp_var_pc1 &lt;- exp_var[2]\n        xaxis &lt;- c(\"PC2\")\n    } else if (pc1 == 'PC3') {\n        pc1 &lt;- df_X$PC3\n        exp_var_pc1 &lt;- exp_var[3]\n        xaxis &lt;- c(\"PC3\")\n    }\n\n    if (pc2 == 'PC1') {\n        pc2 &lt;- df_X$PC1\n        exp_var_pc2 &lt;- exp_var[1]\n        yaxis &lt;- c(\"PC1\")\n    }  else if (pc2 == 'PC2') {\n        pc2 &lt;- df_X$PC2\n        exp_var_pc2 &lt;- exp_var[2]\n        yaxis &lt;- c(\"PC2\")\n    } else if (pc2 == 'PC3') {\n        pc2 &lt;- df_X$PC3\n        exp_var_pc2 &lt;- exp_var[3]\n        yaxis &lt;- c(\"PC3\")\n    }\n\n    pca_plot &lt;- ggplot(df_X, aes(pc1, pc2, fill = color_group, shape = shape_group)) +\n     geom_point(size = 5, color = \"black\") +\n     scale_fill_viridis_c(option = \"C\") +\n     scale_shape_manual(values = c(24,21)) +\n     # stat_ellipse() +\n     xlab(paste(xaxis, \" - \", exp_var_pc1)) +\n     ylab(paste(yaxis, \" - \", exp_var_pc2)) +\n     theme_minimal(base_size = 16) +\n     theme(text = element_text(size=16)) +\n     theme(legend.title = element_blank(),\n           legend.key.size = unit(2,\"mm\"),\n           legend.text = element_text(size = 6)) +\n     theme(legend.position = \"top\") +\n     ggtitle(title_text) + theme(plot.title = element_text(size = 10))\n\n    return(pca_plot)\n}\n\nplot_pca_bi &lt;- function(df, pc1, pc2, metadata_group, columntitle) {\n    metadata_group_colors &lt;- get(paste(metadata_group, \"_colors\", sep = \"\"))\n    metadata_group_shapes &lt;- get(paste(metadata_group, \"_shapes\", sep = \"\"))\n\n    arrow_pc &lt;- enquo(columntitle)\n\n    exp_var &lt;- paste0(round(df$explained_variance * 100, 2), \"%\") # explained variance for x- and y-labels\n\n    # select only the PCs from the PCA and add metadata\n    df_X &lt;- df$variates$X %&gt;%\n              as.data.frame() %&gt;%\n              rownames_to_column(\"Library_ID\") %&gt;%\n              inner_join(full_metadata, by = \"Library_ID\")\n\n    metadata_group = df_X[[metadata_group]]\n\n    corr_lam &lt;- df$sdev[c(\"PC1\", \"PC2\", \"PC3\")] * sqrt(nrow(df_X))\n\n    df_X &lt;- df_X %&gt;%\n      mutate(PC1 = PC1 / corr_lam[1],\n             PC2 = PC2 / corr_lam[2],\n             PC3 = PC3 / corr_lam[3])\n\n    # select the correct PC column and explained variance for PC1\n    if (pc1 == 'PC1') {\n        Pc1 &lt;- df_X$PC1\n        exp_var_pc1 &lt;- exp_var[1]\n        xaxis &lt;- c(\"PC1\")\n    } else if (pc1 == 'PC2') {\n        Pc1 &lt;- df_X$PC2\n        exp_var_pc1 &lt;- exp_var[2]\n        xaxis &lt;- c(\"PC2\")\n    } else if (pc1 == 'PC3') {\n        Pc1 &lt;- df_X$PC3\n        exp_var_pc1 &lt;- exp_var[3]\n        xaxis &lt;- c(\"PC3\")\n   }\n\n    # select the correct PC column and explained variance for PC2\n    if (pc2 == 'PC1') {\n        Pc2 &lt;- df_X$PC1\n        exp_var_pc2 &lt;- exp_var[1]\n        yaxis &lt;- c(\"PC1\")\n } else if (pc2 == 'PC2') {\n       Pc2 &lt;- df_X$PC2\n       exp_var_pc2 &lt;- exp_var[2]\n       yaxis &lt;- c(\"PC2\")\n    } else if (pc2 == 'PC3') {\n       Pc2 &lt;- df_X$PC3\n       exp_var_pc2 &lt;- exp_var[3]\n       yaxis &lt;- c(\"PC3\")\n   }\n\n    # Identify the 10 pathways that have highest positive and negative loadings in the selected PC\n    pws_10 &lt;- df$loadings$X %&gt;%\n      as.data.frame(.) %&gt;%\n      rownames_to_column(var = \"Pathway\") %&gt;%\n      separate(Pathway, into = \"Pathway\", sep = \":\", extra = \"drop\") %&gt;%\n      top_n(10, !!arrow_pc)\n\n    neg_10 &lt;- df$loadings$X %&gt;%\n      as.data.frame(.) %&gt;%\n      rownames_to_column(var = \"Pathway\") %&gt;%\n      separate(Pathway, into = \"Pathway\", sep = \":\", extra = \"drop\") %&gt;%\n      top_n(-10, !!arrow_pc)\n\n\n    pca_plot_bi &lt;- ggplot(df_X, aes(x = Pc1, y = Pc2)) +\n      geom_point(size = 3.5, aes(shape = metadata_group, fill = metadata_group))+\n      geom_segment(data = pws_10,\n                   aes(xend = get(paste(pc1)), yend = get(paste(pc2))),\n                   x = 0, y = 0, colour = \"black\",\n                   size = 0.5,\n                   arrow = arrow(length = unit(0.03, \"npc\"))) +\n      geom_label_repel(data = pws_10,\n                   aes(x = get(paste(pc1)), y = get(paste(pc2)), label = Pathway),\n                   size = 2.5, colour = \"grey20\", label.padding = 0.2, force = 5, max.overlaps = 20) +\n      geom_segment(data = neg_10,\n                   aes(xend = get(paste(pc1)), yend = get(paste(pc2))),\n                   x = 0, y = 0, colour = \"grey50\",\n                   size = 0.5,\n                   arrow = arrow(length = unit(0.03, \"npc\"))) +\n      geom_label_repel(data = neg_10,\n                   aes(x = get(paste(pc1)), y = get(paste(pc2)), label = Pathway),\n                   size = 2.5, colour = \"grey20\", label.padding = 0.2, max.overlaps = 12) +\n      labs(x = paste(xaxis, \" - \", exp_var_pc1),\n           y = paste(yaxis, \" - \", exp_var_pc2)) +\n      scale_fill_manual(values = metadata_group_colors) +\n      scale_shape_manual(values = metadata_group_shapes) +\n      theme_minimal() + theme(text = element_text(size = 16)) +\n      theme(text = element_text(size=16)) +\n      theme(legend.position = \"top\")\n\n    return(pca_plot_bi)\n}\nAs we are dealing with aDNA, and we often have bad samples, its sometimes interesting to see differences between well/badly preserved samples at all stages of analysis.\nTherefore we may generate results for all samples. However for actual analysis where we want to intepret biological differences, should exclude outliers (in this case highly contaminated samples - as identified by the decontam package - see Velsko et al. 2022 _PNAS Nexus for more details).\nWe can make a list the outliers from the previous authentication analyses.\noutliers_mpa3 &lt;- c(\"EXB059.A2101\",\"EXB059.A2501\",\"EXB015.A3301\",\"EXB034.A2701\",\n                   \"EXB059.A2201\",\"EXB059.A2301\",\"EXB059.A2401\",\"LIB058.A0103\",\"LIB058.A0106\",\"LIB058.A0104\")\npoor_samples_mpa3 &lt;- c(\"CS28\",\"CS38\",\"CSN\",\"ELR003.A0101\",\"ELR010.A0101\",\n                       \"KT09calc\",\"MID024.A0101\",\"MID063.A0101\",\"MID092.A0101\")\n\noutliersF &lt;- str_c(outliers_mpa3, collapse = \"|\")"
  },
  {
    "objectID": "functional-profiling.html#sample-clustering-with-pca",
    "href": "functional-profiling.html#sample-clustering-with-pca",
    "title": "11  Functional Profiling",
    "section": "11.5 Sample Clustering with PCA",
    "text": "11.5 Sample Clustering with PCA\n\n11.5.1 Pathway abundance analyses\nOnce we’ve removed outlier samples, our first simple question is - what is the functional relationships of the groups?\nCan we already see distinctive patterns between the different groups in our dataset?\nTo do this lets clean up the data a bit (cleaning names, removing samples with no metadata etc.), normalise (via a ‘centered-log-ratio’ transform ), and run a PCA.\nOnce we’ve done this we should always check our PCA’s Scree plot first.\n\nhumann3_path_l1 &lt;- humann3_path %&gt;%\n  filter(!str_detect(Pathway, \"\\\\|\")) %&gt;%\n  # no full_metadata, remove these\n  select(-c(\"MID025.A0101\",\"MID033.A0101\",\"MID052.A0101\",\"MID056.A0101\",\n            \"MID065.A0101\",\"MID068.A0101\",\"MID076.A0101\",\"MID078.A0101\")) %&gt;%\n  # remove poorly preserved saples\n  select(-c(\"MID024.A0101\",\"MID063.A0101\",\"MID092.A0101\")) %&gt;%\n  select(-matches(\"EXB|LIB\")) %&gt;%\n  # inner_join(., humann3_path.decontam_noblanks_presence_more_30, by = \"Pathway\") %&gt;%\n  gather(\"Library_ID\",\"Counts\",2:ncol(.)) %&gt;%\n  mutate(Counts = Counts + 1) %&gt;%\n  spread(Pathway,Counts) %&gt;%\n  column_to_rownames(\"Library_ID\")\n\n# prepare to run a PCA\n# check the number of components to retain by tuning the PCA\nmixOmics::tune.pca(humann3_path_l1, logratio = 'CLR')\n\n\nhumann3_all_otu.pca &lt;- mixOmics::pca(humann3_path_l1, ncomp = 3, logratio = 'CLR')\nhumann3_all_pca_values &lt;- humann3_all_otu.pca$variates$X %&gt;%\n  as.data.frame() %&gt;%\n  rownames_to_column(\"Library_ID\") %&gt;%\n  inner_join(., full_metadata, by = \"Library_ID\")\nWe can see the first couple of PCs in the scree plot account for a good chunk of the variation of our dataset, so lets visualise the PCA itself.\nWe visualise the PCA with one of our custom functions defined above, and colour by the Pipe notch metadata column.\n# pipenotch colors/shapes\nPipenotch_colors = c(\"#311068\",\"#C83E73\")\nPipenotch_shapes = c(16,17)\n\n# by minimum number of pipenotches\npipenotch &lt;- plot_pca_cont(humann3_path_l1, \"PC1\", \"PC2\",\"Min_no_Pipe_notches\",\"Pipenotch\", 3,\"Min. No. Pipe Notches\")\npipenotch\nWe can see there is a slight separation between the groups, but how do we find out which pathways are maybe driving this pattern?\nFor this we can generate a PCA bi-plot which show what loadings are driving the spread of the samples.\nPipenotch_colors = c(\"#311068\",\"#C83E73\")\nPipenotch_shapes = c(24,21)\n\nbiplot &lt;- plot_pca_bi(humann3_all_otu.pca, \"PC1\", \"PC2\", \"Pipenotch\", PC1)\nbiplot\nFrom the biplot we can see which pathways are differentiating along PC1.\nWe can pull these IDs out to find out what pathways there are from the biplot object itself.\n# make a table of the pathways to save, to use again later in another R notebook\nhumann3_pathway_biplot_list &lt;- biplot$plot_env$pws_10 %&gt;% arrange(desc(PC1)) %&gt;% select(Pathway, PC1, PC2) %&gt;% mutate(Direction = \"PC1+\")\nhumann3_pathway_biplot_list &lt;- humann3_pathway_biplot_list %&gt;%\n  bind_rows(biplot$plot_env$neg_10 %&gt;% arrange(desc(PC1)) %&gt;% select(Pathway, PC1, PC2)%&gt;% mutate(Direction = \"PC1-\"))\n\n\n11.5.2 Species contributions to pathways\nHowever, this ID numbers aren’t very informative to us. At this point we have to do a bit of literature review/database scraping to pull the human-readable names/descriptions of the IDs - which we have already done for you.\nWe can load these back into our environment\n# PC biplot loading top 10s\nhumann3_pathway_biplot_list &lt;- fread(\"./humann3_pathway_biplot_list.tsv\")\nhumann3_pathway_biplot_list &lt;- humann3_pathway_biplot_list %&gt;%\n  rename(Pathway = pathway) %&gt;%\n  mutate(Path = sapply(Pathway, function(f) {\n                                  unlist(str_split(f, \":\"))[1]\n                                  })) %&gt;%\n  select(Pathway, Path, everything()) %&gt;%\n  # remove 3 of the 4 ubiquinol pathways w/identical loadings\n  filter(!str_detect(Pathway, \"5856|5857|6708\"))\n\ntibble(humann3_pathway_biplot_list)\nWe now have the pathway ID, and a pathway description for each of the loadings of the PCA.\n\n11.5.2.0.1 PC1\nWhile we have the pathways, we don’t who contributed these.\nFor this, we can join our pathway table back onto the original output from HUMANn3 we loaded at the beginning, which includes the taxa information.\n# list the 10 orthologs with strongest loading in PC1 + values\nhumann3_path_biplot_pc &lt;- humann3_pathway_biplot_list %&gt;%\n  filter(Direction == \"PC1+\") %&gt;%\n  pull(Path) %&gt;%\n  str_c(., collapse = \"|\") # need this format for filtering in the next step\n\n\n# select only those 10 pathways from the list, and split the column with names into 3 (Pathway, Genus, Species)\nhumann3_path_pc1pws &lt;- humann3_path %&gt;%\n  filter(str_detect(Pathway, humann3_path_biplot_pc)) %&gt;%\n  filter(str_detect(Pathway, \"\\\\|\")) %&gt;%\n  gather(\"SampleID\", \"CPM\", 2:ncol(.)) %&gt;%\n  mutate(Pathway = str_replace_all(Pathway, \"\\\\.s__\", \"|s__\")) %&gt;%\n  separate(., Pathway, into = c(\"Pathway\", \"Genus\", \"Species\"), sep = \"\\\\|\") %&gt;%\n  mutate(Species = replace_na(Species, \"unclassified\"),\n         Genus = str_replace_all(Genus, \"g__\", \"\"),\n         Species = str_replace_all(Species, \"s__\", \"\")) %&gt;%\n  inner_join(., humann3_pathway_biplot_list %&gt;%\n              select(Pathway, Path) %&gt;%\n               distinct(.), by = \"Pathway\") %&gt;%\n  inner_join(.,  humann3_pathway_biplot_list %&gt;%\n               filter(Direction == \"PC1+\") %&gt;%\n               select(Path), by = \"Path\") %&gt;%\n  # select(-Pathway) %&gt;%\n  select(Path, everything()) %&gt;%\n  arrange(Path)\n\ntibble(humann3_path_pc1pws)\nWe can now see who contributed which pathway, and also the abundance information (CPM)!\nGiven many taxa may contribute to the same pathway, we may want to see which taxa are more ‘dominantly’ contributing to this.\nFor this we can calculate of all copies of a given pathway what fraction comes from which taxa (you can imagine this like ‘depth’ coverage in genomic analysis), based on the percentage of the total copies per million for that pathway.\n# calculate the % for each pathway contributed by each genus\nhumann3_path_pc1pws_stats &lt;- humann3_path_pc1pws %&gt;%\n  group_by(Path, Genus) %&gt;%\n  summarize(Sum = sum(CPM)) %&gt;%\n  mutate(Percent = Sum/sum(Sum)*100) %&gt;%\n  ungroup(.)\n\n# create the list of 10 orthologs again, but don't collapse the list as above\nhumann3_path_biplot_pc &lt;- humann3_pathway_biplot_list %&gt;%\n  filter(Direction == \"PC1+\") %&gt;%\n  arrange(Path) %&gt;%\n  pull(Path)\n\n# calculate the total % of all genera that contribute &lt; X% to each ortholog\nhumann3_path_pc1pws_stats_extra &lt;- lapply(humann3_path_biplot_pc, function(eclass) {\n high_percent &lt;- humann3_path_pc1pws_stats %&gt;%\n   filter(Path == eclass) %&gt;%\n   filter(Percent &lt; 5) %&gt;%\n   summarise(Remaining = sum(Percent)) %&gt;%\n   mutate(Path = eclass,\n          Genus = \"Other\")\n}) %&gt;%\n bind_rows(.)\n\n# add this additional % to the main table\nhumann3_path_pcbi_bar_df &lt;- humann3_path_pc1pws_stats_extra %&gt;%\n  rename(Percent = Remaining) %&gt;%\n  bind_rows(., humann3_path_pc1pws_stats %&gt;%\n              select(-Sum)) %&gt;%\n  select(Path, Genus, Percent) %&gt;%\n  mutate(Direction = \"PC1+\") %&gt;%\n  distinct()\nAnd we can visualize the contributors to the top 10 pathways) driving the main variation along PC1 (with the assumption these maybe the most biological significant, and to reduce the numbers of pathways we have to research.\nFor the loadings falling in the positive direction of the PC1:\n# plot the values in a bar chart\npaths_sp_pc1 &lt;- humann3_path_pcbi_bar_df %&gt;%\n  # filter(Direction == \"PC1+\", Genus != \"Other\") %&gt;% # removing Other plots all species/unassigned - no need to filter the pathways\n  filter(Percent &gt;= 5 | (Percent &lt;= 5 & Genus == \"Other\")) %&gt;% # filter out the genera with % &lt; 5, but keep Other &lt; 5\n  # filter(Percent &gt;= 5) %&gt;% # filter out the genera with % &lt; 5, but keep Other &lt; 5\n  mutate(\n    Genus = fct_relevel(Genus, \"Other\",\"unclassified\",\"Aggregatibacter\",\"Capnocytophaga\",\"Cardiobacterium\",\n                        \"Eikenella\",\"Haemophilus\",\"Kingella\",\"Lautropia\",\"Neisseria\",\"Ottowia\",\"Streptococcus\"),\n         Path = fct_relevel(Path, humann3_pathway_biplot_list %&gt;%\n                              filter(Direction == \"PC1+\") %&gt;%\n                              pull(Path))) %&gt;%\n  ggplot(., aes(x=Path, y=Percent, fill = Genus)) +\n    geom_bar(stat = \"identity\") +\n    theme_minimal() +\n    scale_fill_manual(values = c(\"#0D0887FF\",\"#969696\",\"#5D01A6FF\",\"#7E03A8FF\",\n                                 \"#9C179EFF\",\"#B52F8CFF\",\"#CC4678FF\",\"#DE5F65FF\",\n                                 \"#ED7953FF\",\"#F89441FF\",\"#FDB32FFF\",\"#FBD424FF\",\"#F0F921FF\")) +\n    theme(text = element_text(size=18),\n          axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +\n    ylab(\"Percent\") +\n    ggtitle(\"Metacyc pathways - PC1 positive\") +\n    theme(title = element_text(size=10))\n\n# viridis_pal(option = \"B\")(13)\npaths_sp_pc1\n\n\n\n\n\n\nWarning\n\n\n\nPWY-5345 has no species assignment to that pathway.\n\n\nAnd the negative loadings:\n# list the 10 orthologs with strongest loading in PC1 + values\nhumann3_path_biplot_pc &lt;- humann3_pathway_biplot_list %&gt;%\n  filter(Direction == \"PC1-\") %&gt;%\n  arrange(Path) %&gt;%\n  pull(Path) %&gt;%\n  str_c(., collapse = \"|\") # need this format for filtering in the next step\n\n# select only those 10 orthologs from the list, and split the column with names into 3 (Ortholog, Genus, Species)\nhumann3_path_pc1neg &lt;- humann3_path %&gt;%\n  filter(str_detect(Pathway, humann3_path_biplot_pc)) %&gt;%\n  filter(str_detect(Pathway, \"\\\\|\")) %&gt;%\n  gather(\"SampleID\", \"CPM\", 2:ncol(.)) %&gt;%\n  mutate(Pathway = str_replace_all(Pathway, \"\\\\.s__\", \"|s__\")) %&gt;%\n  separate(., Pathway, into = c(\"Pathway\", \"Genus\", \"Species\"), sep = \"\\\\|\") %&gt;%\n  mutate(Species = replace_na(Species, \"unclassified\"),\n         Genus = str_replace_all(Genus, \"g__\", \"\"),\n         Species = str_replace_all(Species, \"s__\", \"\")) %&gt;%\n  inner_join(., humann3_pathway_biplot_list %&gt;%\n              select(Pathway, Path) %&gt;%\n               distinct(.), by = \"Pathway\") %&gt;%\n  inner_join(.,  humann3_pathway_biplot_list %&gt;%\n               filter(Direction == \"PC1-\") %&gt;%\n               select(Path), by = \"Path\") %&gt;%\n  select(-Pathway) %&gt;%\n  select(Path, everything()) %&gt;%\n  arrange(Path)\n\n# calculate the % for each ortholog contributed by each genus\nhumann3_path_pc1neg_stats &lt;- humann3_path_pc1neg %&gt;%\n  group_by(Path, Genus) %&gt;%\n  summarize(Sum = sum(CPM)) %&gt;%\n  mutate(Percent = Sum/sum(Sum)*100) %&gt;%\n  ungroup(.)\n\n# create the list of 10 orthologs again, but don't collapse the list as above\nhumann3_path_biplot_pc &lt;- humann3_pathway_biplot_list %&gt;%\n  filter(Direction == \"PC1-\") %&gt;%\n  arrange(Path) %&gt;%\n  pull(Path)\n\n# calculate the total % of all genera that contribute &lt; X% to each ortholog\nhumann3_path_pc1neg_stats_extra &lt;- lapply(humann3_path_biplot_pc, function(eclass) {\n high_percent &lt;- humann3_path_pc1neg_stats %&gt;%\n   filter(Path == eclass) %&gt;%\n   filter(Percent &lt; 5) %&gt;%\n   summarise(Remaining = sum(Percent)) %&gt;%\n   mutate(Path = eclass,\n          Genus = \"Other\")\n}) %&gt;%\n bind_rows(.)\n\n# add this additional % to the main table\nhumann3_path_pcbi_bar_df &lt;- humann3_path_pcbi_bar_df %&gt;%\n  bind_rows(humann3_path_pc1neg_stats_extra %&gt;%\n            rename(Percent = Remaining) %&gt;%\n            bind_rows(., humann3_path_pc1neg_stats %&gt;%\n                      select(-Sum)) %&gt;%\n            select(Path, Genus, Percent) %&gt;%\n            mutate(Direction = \"PC1-\")) %&gt;%\n  distinct()\n\n# plot the values in a bar chart\npaths_sp_pc2 &lt;- humann3_path_pcbi_bar_df %&gt;%\n  filter(Direction == \"PC1-\") %&gt;% # removing Other plots all species/unassigned - no need to filter the pathways\n  filter(Percent &gt;= 5 | (Percent &lt;= 5 & Genus == \"Other\")) %&gt;% # filter out the genera with % &lt; 5, but keep Other &lt; 5\n  mutate(Genus = fct_relevel(Genus, \"Other\",\"unclassified\",\"Desulfobulbus\",\"Desulfomicrobium\",\"Methanobrevibacter\"),\n         Path = fct_relevel(Path, humann3_pathway_biplot_list %&gt;%\n                              filter(Direction == \"PC1-\") %&gt;%\n                              pull(Path))) %&gt;%\n  ggplot(., aes(x=Path, y=Percent, fill = Genus)) +\n    geom_bar(stat = \"identity\") +\n    theme_minimal() +\n    scale_fill_manual(values = c(\"#0D0887FF\",\"#969696\",\"#B52F8CFF\",\"#ED7953FF\",\"#FCFFA4FF\")) +\n    theme(text = element_text(size=18),\n          axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +\n    # facet_wrap(~pathrtholog, nrow=2) +\n    ylab(\"Percent\") +\n    ggtitle(\"Metacyc pathways - PC1 negative\") +\n    theme(title = element_text(size=12))\n\npaths_sp_pc2\n\n\n\n11.5.3 Final Visualisation\nFinally, we can stick the biplot and the taxon contribution plots together!\nh3biplots &lt;- biplot + paths_sp_pc2 + paths_sp_pc1 +\n  plot_layout(widths = c(2, 1,1))\n\nggsave(\"./h3_paths_biplots.pdf\", plot = h3biplots,\n        device = \"pdf\", scale = 1, width = 20, height = 9.25, units = c(\"in\"), dpi = 300)\n\nsystem(paste0('firefox \"h3_paths_biplots.pdf\"'))\nThis allows us to evaluate all the information together.\nFrom this point onwards, we would have to do manual research/literature reviews into each of the pathways, see if they make ‘sense’ to the sample type and associated groups of samples, and evaluate whether they are interesting or not.."
  },
  {
    "objectID": "denovo-assembly.html#introduction",
    "href": "denovo-assembly.html#introduction",
    "title": "12  Introduction to de novo Genome Assembly",
    "section": "12.1 Introduction",
    "text": "12.1 Introduction\n\nTBC"
  },
  {
    "objectID": "authentication-decontamination.html",
    "href": "authentication-decontamination.html",
    "title": "13  Authentication and Decontamination",
    "section": "",
    "text": "14 Introduction\nIn ancient metagenomics we typically try to answer two questions: “Who is there?” and “How ancient?”, meaning we would like to detect an organism and investigate whether this organism is ancient. There are three typical ways to identify the presence of an organism in a metagenomic sample:\nThe first two are reference-based, i.e. they assume a similarity of a query ancient DNA fragment to a modern reference genome in a database. This is a strong assumption, which might not be true for very old or very diverged ancient organisms. This is the case when the reference-free de-novo assembly approach becomes prowerful. However, de-novo assembly has its own computational challenges for low-coverage ancient metagenomic samples that typically contain very short DNA fragments.\nWhile all the three types of metagenomic analysis are suitable for exploring composition of metagenomic samples, they do not directly validate the findings or provide information about ancient or endogenous status of the detected organims. It can happen that the detected organism\nTherefore, additional analysis is needed to follow-up each hit and demonstrate its ancient origin. Below, we describe a few steps that can help ancient metagenomic researchers to verify their findings and put them into biological context.\nIn this chapter, we will cover:\nThe chapter has the following outline:\nIn this chapter, we will use 10 simulated with gargammel ancient metagenomic samples from Pochon et al. 2023. The simulated data can be accessed via https://doi.org/10.17044/scilifelab.21261405.\nTo download the simulated ancient metagenomic data please use the following command lines:\nThe DNA reads were simulated with damage, sequencing errors and Illumina adapters, therefore one will have to trim the adapters first:\nNow, after the basic data pre-processing has been done, we can proceed with validation, authentication and decontamination analyses.\nOnce an organism has been detected in a sample (via alignment, classification or de-novo assembly), one needs to take a closer look at multiple quality metrics in order to reliably confrm that the organism is not a false-positive detection and is of ancient origin. The methods used for this purpose can be divided into modern validation and ancient-specific validation criteria. Below, we will cover both of them.\nModern contamination can severely bias ancient metagenomic analysis. Also, ancient contamination, i.e. entered post-mortem, can potentially lead to false biological interpretations. Therefore, a lot of efforts in the ancient metagenomics field are directed on establishing methodology for identification of contaminants. Among them, the use of negative (blank) control samples is perhaps the most reliable and straighforward method. Additionally, one often performs microbial source tracking for predicting environment (including contamination environment) of origin for ancient metagenomic samples."
  },
  {
    "objectID": "authentication-decontamination.html#modern-validation-criteria",
    "href": "authentication-decontamination.html#modern-validation-criteria",
    "title": "13  Authentication and Decontamination",
    "section": "16.1 Modern validation criteria",
    "text": "16.1 Modern validation criteria\nThe modern validation methods aim at confirming organism presence regradless of its ancient status. The main approaches include evenness / breadth of coverage computation, assessing alignmnet quality, and monitoring affinity of the DNA reads to the reference genome of the potential host.\n\n16.1.1 Depth vs breadth and evenness of coverage\nConcluding organism presence by relying solely on the numbers of assigned sequenced reads (aka depth of coverage metric) turns out to be not optimal and too permissive, which may result in a large amount of false-positive discoveries. For example, when using alignment to a reference genome, the mapped reads may demonstrate non-uniform coverage as visualized in the Integrative Genomics Viewer (IGV) below.\n\nIn this case, DNA reads originating from another microbe were (mis-)aligned to Yersina pestis reference genome. It can be observed that a large numer the reads align only to a few conserved genomic loci. Therefore, even if many thousands of DNA reads are capable of aligning to the reference genome, the overall uneven alignment pattern suggests no presence of Yersina pestis in the metagenomic sample. Thus, not only the number of assigned reads (proportinal to depth of coverage metric) but also the breadth and evenness of coverage metrics become of particular importance for veryfication of metagenomic findings, i.e. hits with DNA reads uniformly aligned across the reference genome are more likely to be true-positive detections.\n\nIn the next sections, we will show how to practically compute the breadth and evenness of coverage via KrakenUniq and Samtools.\n\n\n16.1.2 Breadth of coverage via KrakenUniq\nHere we are going to demonstrate that one can assess breadth of coverage information already at the taxonomic profiling step. Although taxonomic classifiers do not perform alignment, some of them, such as KrakenUniq and Kraken2 provide a way to infer breadth of coverage in addition to the number of assigned reads to a taxon. This allows for immediate filtering out a lot of false positive hits. Since Kraken-family classifiers are typically faster and less memory-demanding, i.e. can work with very large reference databases, compared to genome aligners, they provide a robust and fairly unbiased initial taxonomic profiling, which can still later be followed-up with proper alignment and computing evenness of coverage as described above.\nTo profile the data with KrakenUniq one needs a database, a pre-built complete microbial NCBI RefSeq database can be accessed via https://doi.org/10.17044/scilifelab.21299541. Please use the following command line to download the databse:\nwget https://figshare.scilifelab.se/ndownloader/articles/21299541/versions/1 \\\n&& unzip 1 && rm 1\nThen, taxonomic k-mer-based classification of the ancient metagenomic reads can be done via KrakenUniq:\nfor i in $(ls *.trimmed.fastq.gz)\ndo\nkrakenuniq --db KRAKENUNIQ_DB --fastq-input $i --threads 20 \\\n--classified-out${i}.classified_sequences.krakenuniq \\\n--unclassified-out ${i}.unclassified_sequences.krakenuniq \\\n--output ${i}.sequences.krakenuniq --report-file ${i}.krakenuniq.output\ndone\nKrakenUniq by default delivers a proxy metric for breadth of coverage called the number of unique kmers (in the 4th column of its output table) assigned to a taxon. KrakenUniq output can be easily filtered with respect to both depth and breadth of coverage, which substantially reduces the number of false-positive hits.\n\nWe can filter the KrakenUniq output with respect to both depth (taxReads) and breadth (kmers) of coverage with the following custom Python script, which selects only species with at east 200 assigned reads and 1000 unique k-mers. After the filtering, we can see a Yersinia pestis hit in the sample 10 that passess the filtering thresholds with respect to both depth and breadth of coverage.\nfor i in $(ls *.krakenuniq.output)\ndo\n$SCRIPTS_DIR/filter_krakenuniq.py $i 1000 200 $SCRIPTS_DIR/pathogenomesFound.tab\ndone\n\nWe can also easily produce a KrakenUniq taxonomic abundance table krakenuniq_abundance_matrix.txt using the custom R script below, which takes as argument the folder KRAKENUNIQ containing the KrakenUniq output files. From the krakenuniq_abundance_matrix.txt table, it becomes clear that Yersinia pestis seems to be present in a few other samples in addition to sample 10.\nRscript ${SCRIPTS_DIR}/krakenuniq_abundance_matrix.R KRAKENUNIQ \\ \nKRAKENUNIQ_ABUNDANCE_MATRIX 1000 200\n\nWhile KrakenUniq delivers information about breadth of coverage by default, one has to use a special flag –report-minimizer-data when running Kraken2 in order to get the breadth of coverage proxy which is called the number of distrinct minimizers for the case of Kraken2. Below, we provide an example Kraken2 command line containing the distinct minimizer flag:\nDBNAME=Kraken2_DB_directory\nKRAKEN_INPUT=sample.fastq.gz\nKRAKEN_OUTPUT=Kraken2_output_directory\nkraken2 --db $DBNAME --fastq-input $KRAKEN_INPUT --threads 20 \\\n--classified-out $KRAKEN_OUTPUT/classified_sequences.kraken2 \\\n--unclassified-out $KRAKEN_OUTPUT/unclassified_sequences.kraken2 \\\n--output $KRAKEN_OUTPUT/sequences.kraken2 \\\n--report $KRAKEN_OUTPUT/kraken2.output \\\n--use-names --report-minimizer-data\nThen the filtering of Kraken2 output with respect to breadth and depth of coverage can be done by analogy with filtering KrakenUniq output table. In case of de-novo assembly, the original DNA reads are typically alligned back to the assembled contigs, and the evennes / breadth of coverage can be computed from these alignments.\n\n\n16.1.3 Evenness of coverage via Samtools\nNow, after we have detected an interesting Y. pestis hit, we would like to follow it up, and compute multiple quality metrics (including proper breadth and evenness of coverage) from alignments (Bowtie2 aligner willl be used in our case) of the DNA reads to the Y. pestis reference genome. Below, we download Yersinia pestis reference genome from NCBI, build its Bowtie2 index, and align trimmed reads against Yersinia pestis reference genome with Bowtie2. Do not forget to sort and index the alignments as it will be important for computing the evenness of coverage. It is also recommended to remove multi-mapping reads, i.e. the ones that have MAPQ = 0, at least for Bowtie and BWA aligners that are commonly used in ancient metagenomics. Samtools with -q flag can be used to extract reads with MAPQ &gt; = 1.\nNCBI=https://ftp.ncbi.nlm.nih.gov; ID=GCF_000222975.1_ASM22297v1\nwget $NCBI/genomes/all/GCF/000/222/975/${ID}/${ID}_genomic.fna.gz\n\ngunzip ${ID}_genomic.fna.gz; echo NC_017168.1 &gt; region.bed\nseqtk subseq ${ID}_genomic.fna region.bed &gt; NC_017168.1.fasta\nbowtie2-build --large-index NC_017168.1.fasta NC_017168.1.fasta --threads 20\n\nbowtie2 --large-index -x NC_017168.1.fasta --end-to-end --threads 20 \\ \n--very-sensitive -U sample10.trimmed.fastq.gz | samtools view -bS -h -q 1 \\\n-@ 20 - &gt; Y.pestis_sample10.bam\nsamtools sort Y.pestis_sample10.bam -@ 20 &gt; Y.pestis_sample10.sorted.bam\nsamtools index Y.pestis_sample10.sorted.bam\nNext, the breadth / evenness of coverage can be computed from the BAM-alignments via samtools depth as follows:\nsamtools depth -a Y.pestis_sample10.sorted.bam &gt; Y.pestis_sample10.sorted.boc\nand visualized using for example the following R code snippet (alternatively aDNA-BAMPlotter can be used):\n# Read output of samtools depth commans\ndf &lt;- read.delim(\"Y.pestis_sample10.sorted.boc\", header = FALSE, sep = \"\\t\")\nnames(df) &lt;- c(\"Ref\", \"Pos\", \"N_reads\")\n\n# Split reference genome in tiles, compute breadth of coverage for each tile\nN_tiles &lt;- 500\nstep &lt;- (max(df$Pos) - min(df$Pos)) / N_tiles\ntiles &lt;- c(0:N_tiles) * step; boc &lt;- vector()\nfor(i in 1:length(tiles))\n{\n  df_loc &lt;- df[df$Pos &gt;= tiles[i] & df$Pos &lt; tiles[i+1], ]\n  boc &lt;- append(boc, rep(sum(df_loc$N_reads &gt; 0) / length(df_loc$N_reads),\n  dim(df_loc)[1]))\n}\nboc[is.na(boc)]&lt;-0; df$boc &lt;- boc\nplot(df$boc ~ df$Pos, type = \"s\", xlab = \"Genome position\", ylab = \"Coverage\")\nabline(h = 0, col = \"red\", lty = 2)\nmtext(paste0(round((sum(df$N_reads &gt; 0) / length(df$N_reads)) * 100, 2), \n\"% of genome covered\"), cex = 0.8)\n\nIn the R script above, we simply split the reference genome into N_tiles tiles and compute the breadth of coverage (number of reference nucleotides covered by at least one read normalized by the total length) locally in each tile. By visualizing how the local breadth of coverage changes from tile to tile, we can monitor the distribution of the reads across the reference genome. In the evenness of coverage figure above, the reads seem to cover all parts of the reference genome uniformly, which is a good evidence of true-positive detection, even though the total mean breadth of coverage is low due to the low total number of reads.\n\n\n16.1.4 Alignment quality\nIn addition to evenness and breadth of coverage, it is very informative to monitor how well the metagenomic reads map to a reference genome. Here one can control for mapping quality (MAPQ field in the BAM-alignments) and the number of mismatches for each read, i.e. edit distance.\nMapping quality (MAPQ) can be extracted from the 5th column of BAM-alignments using Samtools and cut command in bash.\nsamtools view Y.pestis_sample10.sorted.bam | cut -f5 &gt; mapq.txt\nThen the 5th column of the filtered BAM-alignment can be visualized via a simple histogram in R as below for two random metagenomic samples.\nhist(as.numeric(readLines(\"mapq.txt\")), col = “darkred”, breaks = 100)\n\nNote that MAPQ scores are computed slightly differently for Bowtie and BWA, so they are not directly comparable, however, for both MAPQ ~ 10-30, as in the histograms below, indicates good affinity of the DNA reads to the reference genome. here we provide some examples of how typical MAPQ histograms for Bowtie2 and BWA alignments can look like:\n\nEdit distance can be extracted by gathering information in the NM-tag inside BAM-alignemnts, which reports the number of mismatches for each aligned read. This can be done either in bash / awk, or using handy functions from Rsamtools R package:\nlibrary(\"Rsamtools\")\nparam &lt;- ScanBamParam(tag = \"NM\")\nbam &lt;- scanBam(\"Y.pestis_sample10.sorted.bam\", param = param)\nbarplot(table(bam[[1]]$tag$NM), ylab=\"Number of reads\", xlab=\"Number of mismatches\")\n\nIn the barplot above we can see that the majority of reads align either without or with very few mismatches, which is an evidence of high affinity of the aligned reads with respect to the reference genome. For a true-positive finding, the edit distance barplot typically has a decreasing profile. However, for a very degraded DNA, it can have a mode around 1 or 2, which can also be reasonable. A fasle-positive hit would have a mode of the edit distance barplot shifted toward higher numbers of mismatches.\n\n\n16.1.5 Affinity to reference\nVery related to edit distance is another alignment validation metric which is called percent identity. It represents a barplot demonstrating the numbers of reads that are 100% identical to the reference genome (i.e. map without a single mismatch), 99% identical, 98% identical etc. Misaligned reads originating from another related organism have typically most reads with percent identity of 93-96%. In the figure below, the panels (c–e) demonstrate different percent identity distributions. In panel c, most reads show a high similarity to the reference, which indicates a correct assignment of the reads to the reference. In panel d, most reads are highly dissimilar to the reference, which suggests that they originate from different related species. In some cases, as in panel e, a mixture of correctly assigned and misassigned reads can be observed.\n\nAnother important way to detect reads that cross-map between related species is haploidy or checking the amount of multi-allelic SNPs. Because bacteria are haploid organisms, only one allele is expected for each genomic position. Only a small number of multiallelic sites are expected, which can result from a few misassigned or incorrectly aligned reads. In the figure above, panels (f–i) demonstrate histograms of SNP allele frequency distributions. Panel f demonstrates the situation when we have only a few multiallelic sites originating from a misaligned reads. This is a preferrable case scenario corresponding to correct assignment of the reads to the reference. Please also check the corresponding “Good alignments” IGV visualization to the right in the figure above.\nIn contrast, a large number of multiallelic sites indicates that the assigned reads originate from more than one species or strain, which can result in symmetric allele frequency distributions (e.g., if two species or strains are present in equal abundance) (panel g) or asymmetric distributions (e.g., if two species or strains are present in unequal abundance) (panel h). A large number of misassigned reads from closely related species can result in a large number of multiallelic sites with low frequencies of the derived allele (panel i). The situations (g-i) correspond to incorrect assignment of the reads to the reference. Please also check the corresponding “Bad alignments” IGV visualization to the right in the figure above."
  },
  {
    "objectID": "authentication-decontamination.html#ancient-specific-validation-criteria",
    "href": "authentication-decontamination.html#ancient-specific-validation-criteria",
    "title": "13  Authentication and Decontamination",
    "section": "16.2 Ancient-specific validation criteria",
    "text": "16.2 Ancient-specific validation criteria\nIn contrast to modern genomic hit validation criteria, the ancient-specific validation methods concentrate on DNA degradation and damage pattern as ultimate signs of ancient DNA. Below, we will discuss demination profile, read length distribution and post mortem damage (PMD) scores metrics that provide good confirmation of ancient origin of the detected organism.\n\n16.2.1 Ancient status\nChecking evenness of coverage and alignment quality can help us to make sure that the organism we are thinking about is really present in the metagenomic sample. However, we still need to address the question “How ancinet?”. For this purpose we need to compute deamination profile and read length distribution of the aligned reads in order to prove that they demonstrate damage pattern and are sufficiently fragmented, which would be a good evidence of ancient origin of the detected organisms.\nDeamination profile of a damaged DNA demonstrate an enrichment of C / T polymorphisms at the ends of the reads compared to all other single nucleotide substitutions. There are several tools for computing demination profile, but perhaps the most popular is mapDamage. The tool can be run using the following command line:\nmapDamage -i Y.pestis_sample10.sorted.bam -r NC_017168.1.fasta \\\n-d MAPDAMAGE --merge-reference-sequences --no-stats\n\nmaDamage delivers a bunch of useful statistics, among other read length distribution can be checked. A typical mode of DNA reads should be within a range 30-70 base-pairs in order to be a good evidence of DNA fragmentation. Reads longer tha 100 base-pairs are more likely to originate from modern contamination.\n\nAnother useful tool that can be applied to assess how DNA is damaged is PMDtools which is a maximum-likelihood probabilistic model that calculates an ancient score, PMD score, for each read. The ability of PMDtools to infer ancient status with a single read resolution is quite unique and different from mapDamage that can only assess deamination based on a number of reads. PMD scores can be computed using the following command line, please note that Python2 is needed for this purpose.\nsamtools view -h Y.pestis_sample10.bam | python2 ${SCRIPTS_DIR}/pmdtools.0.60.py \\\n --printDS &gt; PMDscores.txt\nThe distribution of PMD scores can be visualized via a histogram in R as follows:\npmd_scores &lt;- read.delim(\"PMDscores.txt\", header = FALSE, sep = \"\\t\")\nhist(pmd_scores$V4, breaks = 1000, xlab = \"PMDscores\")\n\nTypcally, reads with PMD scores greater than 3 are considered to be reliably ancient, i.e. damaged, and can be extracted for taking a closer look. Therefore PMDtools is great for separating ancient reads from modern contaminant reads.\nAs mapDamage, PMDtools can also compute demination profile. However, the advantage of PMDtools that it can compute deamination profile for UDG / USER treated samples (with the flag –CpG). For this purpose, PMDtools uses only CpG sites which escape the treatment, so deamination is not gone completely and there is a chance to authenticate treated samples. Computing deamination pattern with PMDtoools can be achieved with the following command line (please note that the scripts pmdtools.0.60.py and plotPMD.v2.R can be downloaded from the github repository here https://github.com/pontussk/PMDtools):\nsamtools view Y.pestis_sample10.bam | python2 ${SCRIPTS_DIR}/pmdtools.0.60.py \\ \n--platypus &gt; PMDtemp.txt\n\nR CMD BATCH plotPMD.v2.R\n\nWhen performing ancient status analysis on de-novo assembled contigs, it can be computationally challenging and time consuming to run mapDamage or PMDtools on all of them as there can be hundreds of thousands contigs. In addition, the outputs from mapDamage and PMDtools lacking a clear numeric quantitiy or a statistical test that could provide an “ancient vs. non-ancient” desicion for each de-novo assembled contig. To address these limitations, pyDamage tool was recently developed. PyDamage evaluates the amount of aDNA damage and tests the hypothesis whether a model assuming presence of aDNA damage better explains the data than a null model.\n\npyDamage can be run on a sorted BAM-alignments of the microbial reads to the de-novo assembled contigs using the following command line:\npydamage analyze -w 30 -p 14 filtered.sorted.bam"
  },
  {
    "objectID": "authentication-decontamination.html#decontamination",
    "href": "authentication-decontamination.html#decontamination",
    "title": "13  Authentication and Decontamination",
    "section": "17.1 Decontamination",
    "text": "17.1 Decontamination\nModern contamination is one of the major problems in ancient metagenomics analysis. Large fractions of modern bacterial, animal or human DNA in metagenomic samples can lead to false biological and historical conclusions. A lot of scientific literature is dedicated to this topic, and comprehensive tables and sources of potential contamination (e.g. animal and bacterial DNA present in PCR reagensts) are available.\n\nA good practice to discriminate between endogenous and contaminant organisms is to sequence negative controls, so-called blanks. Organisms detected on blanks, like the microbial genera reported in the table below, can substantially facilitate making more informed decision about true metagenomic profile of a sample. Nevertheless, the table below may seem rather conservative since in addition to well-known environmental contaminants as Burkholderia and Pseudomonas it includes also human oral genera as Streptococcus, which are probably less likely to be of environmental origin.\n\nIt is typically assumed that an organism found on a blank has a lower confidence to be endogenous to the studied metagenomic sample, and sometimes it is even expluded from the downstream analysis as an unreliable hit. Despite there are attempts to automate filtering out modern contaminants (we will discuss them below), decontamination process still remains to be a tidious manual work where each candidate should be carefully investigated from different contexts in order to prove its ancient and endogenous origin.\nIf negative control samples (balnks) are available, contaminating organisms can be detected by comparing their abundances in the negative controls with true samples. In this case, contaminant organisms stand out by their high prevalence in both types of samples if one simply plots mean across samples abundance of each detected organism in true samples and negative controls against each other as in the figure below:\nsamples&lt;-read.delim(\"krakenuniq_abundance_matrix.txt\",header=TRUE,\nrow.names = 1, check.names = FALSE, sep = \"\\t\")\ncontrols&lt;-read.delim(\"blank_krakenuniq_abundance_matrix.txt\",header=TRUE,\nrow.names = 1, check.names = FALSE, sep = \"\\t\")\n\ndf &lt;- merge(samples, controls, all = TRUE, by = \"row.names\")\nrownames(df)&lt;-df$Row.names; df$Row.names &lt;- NULL; df[is.na(df)] &lt;- 0\n\ntrue_sample &lt;- subset(df,select=colnames(df)[!grepl(\"control\",colnames(df))])\nnegative_control &lt;- subset(df,select=colnames(df)[grepl(\"control\",colnames(df))])\n\nplot(log10(rowMeans(true_sample)+1) ~ log10(rowMeans(negative_control)+1),\nxlab = \"Log10 ( Negative controls )\", ylab = \"Log10 ( True samples )\",\nmain = \"Organism abundance in true samples vs. negative controls\",\npch = 19, col = \"blue\")\n\npoints(log10(rowMeans(true_sample)+1)[(log10(rowMeans(true_sample)+1) &gt; 1) & \n(log10(rowMeans(negative_control)+1)&gt;1)] ~ \nlog10(rowMeans(negative_control)+1)[(log10(rowMeans(true_sample)+1) &gt; 1) & \n(log10(rowMeans(negative_control)+1)&gt;1)], pch = 19, col = \"red\")\n\ntext(log10(rowMeans(true_sample)+1)[(log10(rowMeans(true_sample)+1) &gt; 1) & \n(log10(rowMeans(negative_control)+1) &gt; 1)] ~ \nlog10(rowMeans(negative_control)+1)[(log10(rowMeans(true_sample)+1) &gt; 1) & \n(log10(rowMeans(negative_control)+1)  &gt;1)],\nlabels = rownames(true_sample)[(log10(rowMeans(true_sample)+1) &gt; 1) & \n(log10(rowMeans(negative_control)+1) &gt; 1)], pos = 4)\n\nIn the figure above, one point indicates an organism detected in a group of metagenomic samples. The points highlighted by red have high abundance in negative control samples, and therefore they are likely contamiannts.\nIn addition to PCR reagents and lab contaminants, reference databses can also be contaminanted by various, often microbial, organisms. A typical example that when screening environmental or sedimentary ancient DNA samples, a fish Cyprinos carpio can pop up if adapter trimming procedure was not successful for some reason.\n\nIt was noticed that the Cyprinos carpio reference genome available at NCBI contains large fraction of Illumina sequncing adapters. Therefore, appearence of this organism in your analysis may falsely lead your conclusion toward potential lake or river present in the excavation site.\nLet us now discuss a few available computational approaches to decontaminate metagenomic samples. One of them is decontam R package that offers a simple statistical test for whether a detected organism is likely contaminant. This approach is useful when DNA quantitation data recording the concentration of DNA in each sample (e.g. PicoGreen fluorescent intensity measures) is available. The idea of the decontam is that contaminant DNA is expected to be present in approximately equal and low concentrations across samples, while sample DNA concentrations can vary widely. As a result, the expected frequency of contaminant DNA varies inversely with total sample DNA concentration (red line in the figure below), while the expected frequency of non-contaminant DNA does not (blue line).\n\nAnother popular tool for detecting contaminating microorganisms is Recentrifuge. It works as a classifier that is trained to recognize contaminant microbial organisms. In case of Recentrifuge, one has to use blanks or other negative controls and provide microbial names and abundances on the blanks in order to train Recentrifuge to recognize endogenous vs. contaminant sources.\nIf one wants to assess the degree of contamination for each sample, there is a handy tool cuperdec, which is an R package that allows a quick comparison of microbial profiles in a query metagenomic sample against a database. The idea of cuperdec is to rank organisms in each sample by their abundance and then using an “expanding window” approach to compute their enrichment in a reference database that contains a comprehensive list of microbial organisms which are specific to a tissue / environment in question. The tool produces so-called Cumulative Percent Decay curves that aim to represent the level of endogenous content of microbiome samples, such as ancient dental calculus, to help to identify samples with low levels of preservation that should be discarded for downstream analysis.\nlibrary(\"cuperdec\"); library(\"magrittr\"); library(\"dplyr\")\n\n# Load database (in this case oral database)\ndata(cuperdec_database_ex)\ndatabase &lt;- load_database(cuperdec_database_ex, target = \"oral\") %&gt;% print()\n\n# Load abundance matrix and metadata\ntaxatable &lt;- load_taxa_table(\"krakenuniq_abundance_matrix.txt\")  %&gt;% print()\nmetadata &lt;- as_tibble(data.frame(Sample = unique(taxatable$Sample), \nSample_Source = \"Oral\"))\n\n# Compute cumulative percent decay curves, filter and plot results\ncurves &lt;- calculate_curve(taxatable, database = database) %&gt;% print()\nfilter_result &lt;- simple_filter(curves, percent_threshold = 50) %&gt;% print()\nplot_cuperdec(curves, metadata = metadata, filter_result)\n\nIn the figure above, one curve represents one sample, and the red curves have a very high amount of contamination and very low amount of endogenous DNA. These samples might be considered to be dropped from the downstream analysis."
  },
  {
    "objectID": "authentication-decontamination.html#microbial-source-tracking",
    "href": "authentication-decontamination.html#microbial-source-tracking",
    "title": "13  Authentication and Decontamination",
    "section": "17.2 Microbial source tracking",
    "text": "17.2 Microbial source tracking\nFor the case of ancient microbiome profiling, in addition to traditional inspection of the list of detected organisms and comparing it with the ones detected on blanks, we can use tools that make a prediction on what environment the detected organisms most likely come from.\nThe most popular and widely used tool is called SourceTracker. SourceTracker is a Bayesian version of the Gaussian Mixture Model (GMM) clustering algorithm that is trained on a user-supplied reference data called Sources, i.e. different classes such as Soil or Human Oral or Human Gut microbial communities etc., and then it can estimate proportion / contribution of each of these sources the users actual samples called Sinks.\n\nOriginally, SourceTracker was developed for 16S data, i.e. using only 16S ribosomal RNA genes, but it can be easily trained using also shotgun metagenomics data, which was demonstrated in its metagenomic extension called mSourceTracker and its faster and more scalable version FEAST. The input data for SourceTracker are metadata, i.e. each sample has to have “source” or “sink” annotation as well as environmental label (e.g. Oral, Gut, Soil etc.), and microbial abundances (OTU abundances) quantified in some way, for example through QIIME pipeline, MetaPhlan or Kraken. The SourceTracker R script can be downloaded from https://github.com/danknights/sourcetracker.\nSourcetracker expects two input data frames: metadata with at least sample name, environment and source / sink labels, and abundance matrix. Note that source and sink metadata and abundances have to be merged together prior to using SourceTracker. Here we are going to use data from the Human Microbiome Project (HMP) as sources, and we are going to merge the HMP data with the sink samples into single OTU table and meta-data table.\notus_hmp &lt;- read.delim(\"otus_hmp.txt\", header = TRUE, row.names = 1, sep = \"\\t\")\nmeta_hmp &lt;- read.delim(\"meta_hmp.txt\", header = TRUE, row.names = 1, sep = \"\\t\")\n\notus_sink&lt;-read.delim(\"krakenuniq_abundance_matrix.txt\",header=T,row.names=1,sep=\"\\t\")\notus &lt;- merge(otus_hmp, otus_sink, all = TRUE, by = \"row.names\")\nrownames(otus) &lt;- otus$Row.names; otus$Row.names &lt;- NULL; otus[is.na(otus)] &lt;- 0\nmeta_sink &lt;- data.frame(ID = colnames(otus_sink), Env = \"Unknown\", SourceSink = \"sink\")\nrownames(meta_sink) &lt;- meta_sink$ID; meta_sink$ID&lt;-NULL\nmetadata &lt;- rbind(meta_hmp, meta_sink)\n\notus &lt;- as.data.frame(t(as.matrix(otus)))\notus[otus &gt; 0] &lt;- 1; otus &lt;- otus[rowSums(otus)!=0,]\nmetadata&lt;-metadata[as.character(metadata$Env)!=\"Vaginal\",]; envs &lt;- metadata$Env\ncommon.sample.ids &lt;- intersect(rownames(metadata), rownames(otus))\notus &lt;- otus[common.sample.ids,]; metadata &lt;- metadata[common.sample.ids,]\nNext, training SourceTracker on source samples and running predictions on sink samples can be done using following command lines:\n# Train SourceTracker on sources (HMP) and run predictions on sinks\nsource('/sourcetracker/src/SourceTracker.r')\ntrain.ix &lt;- which(metadata$SourceSink=='source')\ntest.ix &lt;- which(metadata$SourceSink=='sink')\nst &lt;- sourcetracker(otus[train.ix,], envs[train.ix])\nresults &lt;- predict(st, otus[test.ix,], alpha1 = 0.001, alpha2 = 0.001)\nFinally, we can plot SourceTracker environment inference in the form of barcharts as follows:\n# Sort SourceTracker proportions for plotting\nprops &lt;- results$proportions\nprops &lt;- props[order(-props[,\"Oral\"]),]\nresults$proportions &lt;- props\n\n# Prepare SourceTracker output for plotting\nname &lt;- rep(rownames(results$proportions), each = 4)\nvalue &lt;- as.numeric(t(results$proportions))\nlabels &lt;- c(\"Gut\",\"Oral\",\"Skin\",\"Unknown\"); condition&lt;-rep(labels, length(test.ix))\ndata &lt;- data.frame(name, condition, value)\n\n# Plot SourceTracker inference as a barplot\nlibrary(\"ggplot2\")\nggplot(data, aes(fill=condition, y=value, x = reorder(name, seq(1:length(name))))) + \ngeom_bar(position = \"fill\", stat = \"identity\") + \ntheme(axis.text.x = element_text(angle = 90, size=5, hjust=1, vjust=0.5)) + \nxlab(\"Sample\") + ylab(\"Fraction\")\n\nIn the figure above the SourceTracker was trained on Human Microbiome Project (HMP) data, and was capable of predicting the fractions of oral, gut, skin or other microbial composition on the query sink samples. In a similar way, environmental soil or marine microbes can be used as Sources. In this way, environmental percentage of contamination can be detected per sample.\nA drawback of SourceTracker, mSourceTracker and FEAST is that they require a microbial abundance table after a taxonomic classification with e.g. QIIME or Kraken has been performed. Such taxonomic classification can be biased since it is computed against a reference database with known taxonomic annotation. In contrast, a novel microbial source tracking tool decOM aims at moving away from database-dependent methods and using unsupervised approaches exploiting read-level sequence composition.\n\ndecOM uses kmtricks to compute a matrix of k-mer counts on raw reads (FASTQ files) from source samples, and then uses the source k-mer abundance matrix for looking up k-mer composition of sink samples. This allows decOM to calculate microbial contributions / fractions from the sources. For example, for estimating contributions from ancient Oral (aOral), modern Oral (mOral), Skin and Sediment / Soil environments one can use an already computed source matrix from here https://github.com/CamilaDuitama/decOM/ and provide it as a -p_sources parameter. Then decOM can be run using the following command line:\ngit clone https://github.com/CamilaDuitama/decOM.git  \ncd decOM  \nconda env create -n decOM --file environment.yml  \nconda deactivate\nconda activate decOM  \n\nexport PATH=/absolute/path/to/decOM:${PATH}\n\n# Prepare input fof-files that have a key - value format\ncd CUTADAPT # folder containing trimmed fastq-files\nfor i in {1..10}\ndo\necho \"sample${i}_trimmed : sample${i}_trimmed.fastq.gz\" &gt; sample${i}_trimmed.fof\necho sample${i}_trimmed &gt;&gt; FASTQ_NAMES_LIST.txt\ndone\n\n# Download pre-built kmer-matrix of sources (aOral, mOral, Sediment/Soil, Skin)\nwget https://zenodo.org/record/6513520/files/decOM_sources.tar.gz  \ntar -xf decOM_sources.tar.gz\n\n# Run decOM predictions\ndecOM -p_sources decOM_sources/ -p_sinks FASTQ_NAMES_LIST.txt \\\n-p_keys decOM/FASTQ -mem 900GB -t 15\nIn the command line above, he -p_sinks parameter provides a list of sink samples, for example SRR13355807. The sink fastq-files are placed in decOM/FASTQ together with keys fof-files containing the mapping between fastq file names and locations of the fastq-files, for example SRR13355807 : decOM/FASTQ/SRR13355807.fastq.gz. The contributions from the sources to the sink samples, which are recorded in the decOM_output.csv output file, can then be processed and plotted as follows:\ndf&lt;-read.csv(\"decOM_output.csv\", check.names=FALSE)\n\nresult &lt;- subset(df, select = c(\"Sink\", \"Sediment/Soil\", \"Skin\", \"aOral\", \n\"mOral\", \"Unknown\"))\nrownames(result) &lt;- result$Sink; result$Sink &lt;- NULL\nresult &lt;- result / rowSums(result)\nresult&lt;-result[order(-result$aOral),]\n\nname &lt;- rep(rownames(result), each = 5); value &lt;- as.numeric(t(result))\ncondition &lt;- rep(c(\"Sediment/Soil\",\"Skin\",\"aOral\",\"mOral\",\"Unknown\"), \ndim(result)[1])\ndata &lt;- data.frame(name, condition, value)\n\nlibrary(\"ggplot2\"); library(\"viridis\")\nggplot(data, aes(fill=condition, y=value, x=reorder(name,seq(1:length(name))))) + \n  geom_bar(position = \"fill\", stat = \"identity\") + \n  theme(axis.text.x = element_text(angle=90, size = 5, hjust = 1, vjust = 0.5)) + \n  xlab(\"Sample\") + ylab(\"Fraction\")\n\ndecOM has certain advantages compared to SourceTracker as its is a taxonomic classification / database free approach. However, it also appears to be very sensitive to the particular training / source data set. In the example above it can be seen that the microbial source tracking of sink samples is very much dominated by the Oral community, which was the training / source data set."
  },
  {
    "objectID": "authentication-decontamination.html#summary",
    "href": "authentication-decontamination.html#summary",
    "title": "13  Authentication and Decontamination",
    "section": "17.3 Summary",
    "text": "17.3 Summary\nIn this chapter we have learned that:\n\nEvenness of coverage is an important metric for validation of findings\nDeamination profile, DNA fragmentation, mapping quality, edit distance and PMD scores are other authentication / validation metrics to consider\nNegative controls are important for disentangling ancient / endogenous from modern / exogenous contamination\nMicrobial source tracking is another layer of evidence that can facilitate interpretation of ancient metagenomic findings"
  },
  {
    "objectID": "authentication-decontamination.html#questions-to-think-about",
    "href": "authentication-decontamination.html#questions-to-think-about",
    "title": "13  Authentication and Decontamination",
    "section": "17.4 Questions to think about",
    "text": "17.4 Questions to think about\n\nWhat is a false-positive microbial finding and how can we recognize it?\nWhat is the diffeerence between depth, breadth and evenness of coverage?\nWhat is contamination and how can it bias ancient metagenomic analysis?\nHow can we separate ancient from modern DNA sequence?\nWhat is a negative (blank) control sample and why is it useful to have?\nWhat is microbial source tracking and how can it help with decontamination?"
  },
  {
    "objectID": "authentication-decontamination.html#readings",
    "href": "authentication-decontamination.html#readings",
    "title": "13  Authentication and Decontamination",
    "section": "17.5 Readings",
    "text": "17.5 Readings\n\nClio Der Sarkissian, Irina M. Velsko, Anna K. Fotakis, Åshild J. Vågene, Alexander Hübner, and James A. Fellows Yates, Ancient Metagenomic Studies: Considerations for the Wider Scientific Community, mSystems 2021 Volume 6 Issue 6 e01315-21.\nWarinner C, Herbig A, Mann A, Fellows Yates JA, Weiß CL, Burbano HA, Orlando L, Krause J. A Robust Framework for Microbial Archaeology. Annu Rev Genomics Hum Genet. 2017 Aug 31;18:321-356. doi: 10.1146/annurev-genom-091416-035526. Epub 2017 Apr 26. PMID: 28460196; PMCID: PMC5581243.\nOrlando, L., Allaby, R., Skoglund, P. et al. Ancient DNA analysis. Nat Rev Methods Primers 1, 14 (2021). https://doi.org/10.1038/s43586-020-00011-0"
  },
  {
    "objectID": "authentication-decontamination.html#resources",
    "href": "authentication-decontamination.html#resources",
    "title": "13  Authentication and Decontamination",
    "section": "17.6 Resources",
    "text": "17.6 Resources\n\nKrakenUniq: Breitwieser, F. P., Baker, D. N., & Salzberg, S. L. (2018). KrakenUniq: confident and fast metagenomics classification using unique k-mer counts. Genome Biology, vol. 19(1), p. 1–10. http://www.ec.gc.ca/education/default.asp?lang=En&n=44E5E9BB-1\nSamtools: Heng Li, Bob Handsaker, Alec Wysoker, Tim Fennell, Jue Ruan, Nils Homer, Gabor Marth, Goncalo Abecasis, Richard Durbin, 1000 Genome Project Data Processing Subgroup, The Sequence Alignment/Map format and SAMtools, Bioinformatics, Volume 25, Issue 16, 15 August 2009, Pages 2078–2079, https://doi.org/10.1093/bioinformatics/btp352\nPMDtools: Skoglund P, Northoff BH, Shunkov MV, Derevianko AP, Pääbo S, Krause J, Jakobsson M. Separating endogenous ancient DNA from modern day contamination in a Siberian Neandertal. Proc Natl Acad Sci U S A. 2014 Feb 11;111(6):2229-34. doi: 10.1073/pnas.1318934111. Epub 2014 Jan 27. PMID: 24469802; PMCID: PMC3926038.\npyDamage: Borry M, Hübner A, Rohrlach AB, Warinner C. PyDamage: automated ancient damage identification and estimation for contigs in ancient DNA de novo assembly. PeerJ. 2021 Jul 27;9:e11845. doi: 10.7717/peerj.11845. PMID: 34395085; PMCID: PMC8323603.\nSourceTracker: Knights D, Kuczynski J, Charlson ES, Zaneveld J, Mozer MC, Collman RG, Bushman FD, Knight R, Kelley ST. Bayesian community-wide culture-independent microbial source tracking. Nat Methods. 2011 Jul 17;8(9):761-3. doi: 10.1038/nmeth.1650. PMID: 21765408; PMCID: PMC3791591.\ndeCOM: https://www.biorxiv.org/content/10.1101/2023.01.26.525439v1, doi: https://doi.org/10.1101/2023.01.26.525439\naMeta: https://www.biorxiv.org/content/10.1101/2022.10.03.510579v1, doi: https://doi.org/10.1101/2022.10.03.510579\nBowtie2: Langmead, B., Salzberg, S. Fast gapped-read alignment with Bowtie 2. Nat Methods 9, 357–359 (2012). https://doi.org/10.1038/nmeth.1923\ncuperdec: https://cran.r-project.org/web/packages/cuperdec/index.html\ndecontam: https://www.bioconductor.org/packages/release/bioc/html/decontam.html"
  },
  {
    "objectID": "section-ancient-genomics.html#genome-mapping",
    "href": "section-ancient-genomics.html#genome-mapping",
    "title": "Ancient Genomics",
    "section": "Genome Mapping",
    "text": "Genome Mapping\nAn important step in the reconstruction of full genomic sequences is mapping. Even relatively short genomes usually cannot be sequenced as a single consecutive piece. Instead, millions of short sequence reads are generated from genomic fragments. These reads can be several hundred nucleotides in length but are considerably shorter for ancient DNA (aDNA).\nFor many applications involving comparative genomics these ‘reads’ have to be aligned to one or multiple already-reconstructed reference genomes in order to identify differences between the sequenced genome and any given contextual dataset. Aligning millions of short reads to much longer genome sequences in a time-efficient and accurate manner is a bioinformatics challenge for which numerous algorithms and tools have been developed. Each of these programs comes with a variety of parameters that can significantly alter the results and default settings are often not optimal when working with aDNA. Furthermore, read mapping procedures are often part of complex computational genomics pipelines and are therefore not directly applied by many users.\nIn this chapter we will take a look at specific challenges during read mapping when dealing with aDNA. We will get an overview of common input and output formats and manually apply a read mapper to aDNA data studying the direct effects of variation in mapping parameters. We will conclude the session with an outlook on genotyping, which is an important follow-up analysis step, that in turn is very relevant for down-stream analyses such as phylogenetics."
  },
  {
    "objectID": "section-ancient-genomics.html#phylogenomics",
    "href": "section-ancient-genomics.html#phylogenomics",
    "title": "Ancient Genomics",
    "section": "Phylogenomics",
    "text": "Phylogenomics\nPhylogenetic trees are central tools for studying the evolution of microorganisms, as they provide essential information about their relationships and timing of divergence between microbial strains.\nIn this chapter, we will introduce basic phylogenetic concepts and definitions, and provide guidance on how to interpret phylogenetic trees. We will then learn how to reconstruct phylogenetic trees from DNA sequences using various methods ranging from distance-based methods to probabilistic approaches, including maximum likelihood and Bayesian phylogenetics. In particular, we will learn how to use ancient genomic data to reconstruct time-calibrated trees with BEAST2."
  },
  {
    "objectID": "genome-mapping.html#lecture",
    "href": "genome-mapping.html#lecture",
    "title": "14  Genome Mapping",
    "section": "14.1 Lecture",
    "text": "14.1 Lecture\nLecture slides and video from the 2022 edition of the summer school.\n\n\nPDF version of these slides can be downloaded from here."
  },
  {
    "objectID": "genome-mapping.html#mapping-to-a-reference-genome",
    "href": "genome-mapping.html#mapping-to-a-reference-genome",
    "title": "14  Genome Mapping",
    "section": "14.2 Mapping to a Reference Genome",
    "text": "14.2 Mapping to a Reference Genome\nOne way of reconstructing genomic information from DNA sequencing reads is mapping/aligning them to a reference genome. This allows for identification of differences between the genome from your sample and the reference genome. This information can be used for example for comparative analyses such as in phylogenetics. For a detailed explanation of the read alignment problem and an overview of concepts for solving it, please see https://doi.org/10.1146/annurev-genom-090413-025358.\nIn this session we will map two samples to the Yersinia pestis (plague) genome using different parameter sets. We will do this “manually” in the sense that we will use all necessary commands one by one in the terminal. These commands usually run in the back when you apply DNA sequencing data processing pipelines.\n\n14.2.1 Preparation\nThe data and conda environment .yaml file for this practical session can be downloaded from here: https://doi.org/10.5281/zenodo.6983174. See instructions on page.\nWe will open a terminal and then navigate to the working directory of this session:\ncd /&lt;path&gt;/&lt;to&gt;/genome-mapping/\nThen, we need to activate the conda environment of this session. By this all the necessary tools can be accessed in the current terminal session:\nconda activate microbial-genomics\nWe will be using the Burrows-Wheeler Aligner (Li et al. 2009 – http://bio-bwa.sourceforge.net). There are different algorithms implemented for different types of data (e.g. different read lengths). Here, we use BWA backtrack (bwa aln), which is well suitable for Illumina sequences up to 100bp. Other algorithms are bwa mem and bwa sw for longer reads.\n\n\n14.2.2 Reference Genome\nFor mapping we need a reference genome in FASTA format. Ideally we use a genome from the same species that our data relates to or, if not available, a closely related species. The selection of the correct reference genome is highly relevant. E.g. if the chosen genome differs too much from the organism the data relates to, it might not be possible to map most of the reads. Reference genomes can be retrieved from comprehensive databases such as NCBI.\nIn your directory, you can find 2 samples and your reference. As a first step we will index our reference genome (make sure you are inside your directory).\nThe first index we will generate is for bwa.\nbwa index YpestisCO92.fa\nThe second index will be used by the genome browser we will apply to our results later on:\nsamtools faidx YpestisCO92.fa\nWe need to build a third index that is necessary for the genotyping step, which comes later after mapping:\npicard CreateSequenceDictionary R=YpestisCO92.fa\n\n\n14.2.3 Mapping Parameters\nWe will be using bwa aln, but we need to specify parameters. For now we will concentrate on the “seed length” and the “maximum edit distance”. We will use the default setting for all other parameters during this session. The choice of the right parameters depend on many factors such as the type of data and the specific use case. One aspect is the mapping sensitivity, i.e. how different a read can be from the chosen reference and still be mapped. In this context we generally differentiate between strict and lenient mapping parameters.\nAs many other mapping algorithms bwa uses a so-called “seed-and-extend” approach. I.e. it initially maps the first N nucleotides of each read to the genome with relatively few mismatches and thereby determines candidate positions for the more time-intensive full alignment.\nA short seed length will generate more such candidate positions and therefore mapping will take longer, but it will also be more sensitive, i.e. there can be more differences between the read and the genome. Long seeds are less sensitive but the mapping procedure is faster.\nIn this session we will use the following two parameter sets:\nLenient\nAllow for more mismatches → -n 0.01\nShort seed length → -l 16\nStrict\nAllow for less mismatches → -n 0.1\nLong seed length → -l 32\nWe will be working with pre-processed files (sample1.fastq.gz, sample2.fastq.gz), i.e. any quality filtering and removal of sequencing adapters is already done.\nWe will map each file once with lenient and once with strict parameters. For this, we will make 4 separate directories, to avoid mixing up files:\nmkdir sample1_lenient sample2_lenient sample1_strict sample2_strict\n\n\n14.2.4 Mapping Sample1\nLet’s begin with a lenient mapping of sample1.\nGo into the corresponding folder:\ncd sample1_lenient\nPerform the bwa alignment, here for sample1, and specify lenient mapping parameters:\nbwa aln -n 0.01 -l 16 ../YpestisCO92.fa ../sample1.fastq.gz &gt; reads_file.sai\nProceed with writing the mapping in sam format (https://en.wikipedia.org/wiki/SAM_(file_format)):\nbwa samse -r '@RG\\tID:all\\tLB:NA\\tPL:illumina\\tPU:NA\\tSM:NA' ../YpestisCO92.fa reads_file.sai ../sample1.fastq.gz &gt; reads_mapped.sam\nNote that we have specified the sequencing platform (Illumina) by creating a so-called “Read Group” (-r). This information is used later during the genotyping step.\nConvert SAM file to binary format (BAM file):\nsamtools view -b -S reads_mapped.sam &gt; reads_mapped.bam\nFor processing of sam and bam files we use SAMtools (Li et al. 2009 – http://samtools.sourceforge.net/).\n-b specifies to output in BAM format. (-S specifies input is SAM, can be omitted in recent versions.)\nNow we sort the bam file → Sort alignments by leftmost coordinates:\nsamtools sort reads_mapped.bam &gt; reads_mapped_sorted.bam\nThe sorted bam file needs to be indexed → more efficient for further processing:\nsamtools index reads_mapped_sorted.bam\nDeduplication → Removal of reads from duplicated fragments:\nsamtools rmdup -s reads_mapped_sorted.bam reads_mapped_sorted_dedup.bam\nsamtools index reads_mapped_sorted_dedup.bam\nDuplicated reads are usually a consequence of amplification of the DNA fragments in the lab. Therefore, they are not biologically meaningful.\nWe have now completed the mapping procedure. Let’s have a look at our mapping results:\nsamtools view reads_mapped_sorted_dedup.bam | less -S\n(exit by pressing q)\nWe can also get a summary about the number of mapped reads. For this we use the samtools idxstats command (http://www.htslib.org/doc/samtools-idxstats.html):\nsamtools idxstats reads_mapped_sorted_dedup.bam\n\n\n14.2.5 Genotyping\nThe next step we need to perform is genotyping, i.e. the identification of all SNPs that differentiate the sample from the reference. For this we use the Genome Analysis Toolkit (GATK) (DePristo et al. 2011 – http://www.broadinstitute.org/gatk/)\nIt uses the reference genome and the mapping as input and produces an output in Variant Call Format (VCF) (https://en.wikipedia.org/wiki/Variant_Call_Format).\nPerform genotyping on the mapping file:\ngatk3 -T UnifiedGenotyper -R ../YpestisCO92.fa -I reads_mapped_sorted_dedup.bam --output_mode EMIT_ALL_SITES -o mysnps.vcf\nLet’s have a look…\ncat mysnps.vcf | less -S\n(exit by pressing q)\n\n\n14.2.6 Mapping and Genotyping for the other Samples/Parameters\nLet’s now continue with mapping and genotyping for the other samples and parameter settings.\n\n14.2.6.1 Sample2 Lenient\ncd ..\ncd sample2_lenient\n\nbwa aln -n 0.01 -l 16 ../YpestisCO92.fa ../sample2.fastq.gz &gt; reads_file.sai\n\nbwa samse -r '@RG\\tID:all\\tLB:NA\\tPL:illumina\\tPU:NA\\tSM:NA' ../YpestisCO92.fa reads_file.sai ../sample2.fastq.gz &gt; reads_mapped.sam\n\nsamtools view -b -S reads_mapped.sam &gt; reads_mapped.bam\n\nsamtools sort reads_mapped.bam &gt; reads_mapped_sorted.bam\n\nsamtools index reads_mapped_sorted.bam\n\nsamtools rmdup -s reads_mapped_sorted.bam reads_mapped_sorted_dedup.bam\n\nsamtools index reads_mapped_sorted_dedup.bam\n\ngatk3 -T UnifiedGenotyper -R ../YpestisCO92.fa -I reads_mapped_sorted_dedup.bam --output_mode EMIT_ALL_SITES -o mysnps.vcf\n\n\n14.2.6.2 Sample1 Strict\ncd ..\ncd sample1_strict\n\nbwa aln -n 0.1 -l 32 ../YpestisCO92.fa ../sample1.fastq.gz &gt; reads_file.sai\n\nbwa samse -r '@RG\\tID:all\\tLB:NA\\tPL:illumina\\tPU:NA\\tSM:NA' ../YpestisCO92.fa reads_file.sai ../sample1.fastq.gz &gt; reads_mapped.sam\n\nsamtools view -b -S reads_mapped.sam &gt; reads_mapped.bam\n\nsamtools sort reads_mapped.bam &gt; reads_mapped_sorted.bam\n\nsamtools index reads_mapped_sorted.bam\n\nsamtools rmdup -s reads_mapped_sorted.bam reads_mapped_sorted_dedup.bam\n\nsamtools index reads_mapped_sorted_dedup.bam\n\ngatk3 -T UnifiedGenotyper -R ../YpestisCO92.fa -I reads_mapped_sorted_dedup.bam --output_mode EMIT_ALL_SITES -o mysnps.vcf\n\n\n14.2.6.3 Sample2 Strict\ncd ..\ncd sample2_strict\n\nbwa aln -n 0.1 -l 32 ../YpestisCO92.fa ../sample2.fastq.gz &gt; reads_file.sai\n\nbwa samse -r '@RG\\tID:all\\tLB:NA\\tPL:illumina\\tPU:NA\\tSM:NA' ../YpestisCO92.fa reads_file.sai ../sample2.fastq.gz &gt; reads_mapped.sam\n\nsamtools view -b -S reads_mapped.sam &gt; reads_mapped.bam\n\nsamtools sort reads_mapped.bam &gt; reads_mapped_sorted.bam\n\nsamtools index reads_mapped_sorted.bam\n\nsamtools rmdup -s reads_mapped_sorted.bam reads_mapped_sorted_dedup.bam\n\nsamtools index reads_mapped_sorted_dedup.bam\n\ngatk3 -T UnifiedGenotyper -R ../YpestisCO92.fa -I reads_mapped_sorted_dedup.bam --output_mode EMIT_ALL_SITES -o mysnps.vcf\n\n\n\n14.2.7 Comparing Genotypes\nIn order to combine the results from multiple samples and parameter settings we need to agregate and comparatively analyse the information from all the vcf files. For this we will use the software MultiVCFAnalyzer (https://github.com/alexherbig/MultiVCFAnalyzer).\nIt produces various output files and summary statistics and can integrate gene annotations for SNP effect analysis as done by the program SnpEff (Cingolani et al. 2012 - http://snpeff.sourceforge.net/).\nRun MultiVCFAnalyzer on all 4 files at once. First cd one level up (if you type ls you should see your 4 directories, reference, etc.):\ncd ..\nThen make a new directory…\nmkdir vcf_out\n…and run the programme:\nmultivcfanalyzer NA YpestisCO92.fa NA vcf_out F 30 3 0.9 0.9 NA sample1_lenient/mysnps.vcf sample1_strict/mysnps.vcf sample2_lenient/mysnps.vcf sample2_strict/mysnps.vcf\nLet’s have a look in the ‘vcf_out’ directory (cd into it):\ncd vcf_out\nCheck the parameters we set earlier:\nless -S info.txt\n(exit by pressing q)\nCheck results:\nless -S snpStatistics.tsv\n(exit by pressing q)\nThe file content should look like this:\nSNP statistics for 4 samples.\nQuality Threshold: 30.0\nCoverage Threshold: 3\nMinimum SNP allele frequency: 0.9\nsample  SNP Calls (all) SNP Calls (het) coverage(fold)  coverage(percent)\nrefCall allPos  noCall  discardedRefCall    discardedVarCall    filteredVarCall unhandledGenotype\nsample1_lenient 213 0   16.38   92.69\n4313387 4653728 293297  46103   728 0   0\nsample1_strict  207 0   16.33   92.71\n4314060 4653728 293403  45633   425 0   0\nsample2_lenient 1274    0   9.01    83.69\n3893600 4653728 453550  297471  7829    0   4\nsample2_strict  1218    0   8.94    83.76\n3896970 4653728 455450  295275  4815    0   0\nFirst we find the most important parameter settings and then the table of results. The first column contains the dataset name and the second column the number of called SNPs. The genome coverage and the fraction of the genome covered with the used threshold can be found in columns 4 and 5, respectively. For example, sample1 had 207 SNP calls with strict parameters. The coverage is about 16-fold and about 93% of the genome are covered 3 fold or higher (The coverage threshold we set was 3).\n\n\n14.2.8 Exploring the Results\nFor visual exploration of mapping results so-called “Genome Browsers” are used. Here we will use the Integrative Genomics Viewer (IGV) (https://software.broadinstitute.org/software/igv/).\nTo open IGV, simply type the following command and the app will open:\nigv\nNote that you cannot use the terminal while IGV is open. If you want to use it anyways, open a second terminal via the bar on the bottom.\nLoad your reference (YpestisCO92.fa):\n→ Genomes → Load Genome from File\n\nLoad your bam files (do this 4 times, once for each mapping):\n→ File → Load from File\n\nTry to explore the mapping results yourself. Here are some questions to guide you. Please also have a look at the examples below.\nWhat differences do you observe between the samples and parameters?\nDifferences in number of mapped reads, coverage, number of SNPs\nDo you see any global patterns?\nWhich sample is more affected by changing the parameters?\nWhich of the two samples might be ancient, which is modern?\nLet’s examine some SNPs. Have a look at snpTable.tsv.\nCan you identify SNPs that were called with lenient but not with strict parameters or vice versa?\nLet’s check out some of these in IGV. Do you observe certain patterns in these genomic regions?\n\n\n14.2.9 Examples\nPlease find here a few examples for exploration. To get a better visualization we have loaded here only sample2_lenient (top track) and sample2_strict (bottom track):\n\nYou can see all aligned reads in the current genomic region as stacks of grey arrows. In the middle of the image you see brown dashes in all of the reads. This is a SNP. You also see sporadically green or red dashes in some reads but not all of them at a given position. These sporadic differences are DNA damage such as we typically find it for ancient DNA.\nFor jumping to a specific coordinate you need to enter it into the coordinate field at the top:\n\nE.g. if you enter 12326942 after the colon in the coordinate field and hit enter, you will jump to the same position as in the screenshot above.\nLet’s have a look at some positions.\nFor example position 36472:\n\nIn the middle of the image you see a SNP (T) that was called with strict parameters (bottom) but not with lenient parameters (top). But why would it not be called in the top track? It is not called because there are three reads that cover the same position, but do not contain the T. We can see that these reads have other difference to the reference at other positions. That’s why they are not mapped with strict parameters. It is quite likely that they originate from a different species. This example demonstrates that sensitive mapping parameters might actually lead to a loss of certain SNP calls.\nDoes this mean that stricter parameters will always give us a clean mapping? Let’s have a look at position 219200:\n\nYou might need to zoom out a bit using the slider in the upper right corner.\nSo, what is going on here? We see a lot of variation in most of the reads. This is reduced a bit with strict mapping parameters (bottom track) but the effect is still quite pronounced. Here, we see a region that seems to be conserved in other species as well, so we have a lot of mapping from other organisms. We can’t compensate that with stricter mapping parameters and we would have to apply some filtering on genotype level to remove this variation from our genotyping. Removing false positive SNP calls is important as it would interfere with downstream analysis such as phylogenomics.\nSuch regions can be fairly large. For example, see this 20 kb region around position 224750:\n\n\n\n14.2.10 Conclusions\n\nMapping DNA sequencing reads to a reference genome is a complex procedure that requires multiple steps.\nMapping results are the basis for genotyping, i.e. the detection of differences to the reference.\nThe genotyping results can be aggregated from multiple samples and comparatively analysed e.g. in the context of phylogenomics.\nThe chosen mapping parameters can have a strong influence on the results of any downstream analysis.\nThis is particularly true when dealing with ancient DNA samples as they tend to contain DNA from multiple organisms. This can lead to mismapped reads and therefore incorrect genotypes, which can further influence downstream analyses."
  },
  {
    "objectID": "phylogenomics.html#lecture",
    "href": "phylogenomics.html#lecture",
    "title": "15  Introduction to Phylogenomics",
    "section": "15.1 Lecture",
    "text": "15.1 Lecture\nLecture slides and video from the 2022 edition of the summer school.\n\n\nPDF version of these slides can be downloaded from here."
  },
  {
    "objectID": "phylogenomics.html#practical",
    "href": "phylogenomics.html#practical",
    "title": "15  Introduction to Phylogenomics",
    "section": "15.2 Practical",
    "text": "15.2 Practical\n\n15.2.1 Preparation\nThe data and conda environment .yaml file for this practical session can be downloaded from here: https://doi.org/10.5281/zenodo.6983184. See instructions on page.\nChange into the session directory\ncd /&lt;path&gt;/&lt;to&gt;/phylogenomics/\nThe data in this folder should contain an alignment (snpAlignment_session5.fasta) and a txt file with the ages of the samples that we are going to be working with in this session (samples.ages.txt)\nLoad the conda environment.\nconda activate phylogenomics\n\n\n15.2.2 Visualize the sequence alignment\nIn this practical session, we will be working with an alignment produced as you learned in the practical Genome mapping.\n\n\n\n\n\n\nWhat is in the data?\n\n\n\n\nthe alignment is a SNP alignment (it contains only the variable genomic positions, not the full genomes)\nit contains 32 Yersinia pestis sequences and 1 Yersinia pseudotuberculosis sequence which can be used as an outgroup\nin this practical, we will investigate the phylogenetic position of four prehistorical Y. pestis strains that we have recently discovered: KZL002, GZL002, CHC004 and VLI092\n\n\n\nWe start by exploring the alignment in MEGA. Open the MEGA desktop application by typing mega & in the terminal.\n\n\n\n\n\n\nTip\n\n\n\nAdding “&” at the end of a commandline allows to run a program in the background while letting the terminal accessible. This particularly useful when starting a graphical interface from the terminal.\n\n\nThen, load the alignment by clicking on File -&gt; Open A File/Session -&gt; Select the snpAligment_session5.fasta (in the working directory of the session).\n\nIt will you ask what you want to do with the alignment. In MEGA you can also produce an alignment, however, since our sequences are already aligned we will press on Analyze.\nThen we will select Nucleotide Sequences since we are working with a DNA alignment. Note that MEGA can also work with Protein Sequences as well as Pairwise Distance Matrix (which we will cover shortly). In the same window, we will change the character for Missing Data to N and click in OK.\n\nA window would open up asking if our alignment contains protein encoding sequences, and we will select No.\n\n\n\n\n\n\nTip\n\n\n\nIf you had protein encoding sequences, you would have selected Yes. This will allow you to treat different positions with different evolutionary modes depending on their codon position. One can do this to take in account that the third codon position can change to different nucleotides without resulting in a different amino acid, while position one and two of the codon are more restricted.\n\n\nTo explore the alignment, you will then click on the box with TA\n\nYou will see an alignment containing sequences from the bacterial pathogen Yersinia pestis. Within the alignment, we have four sequences of interest (KZL002, GZL002, CHC004 and VLI092) that date between 5000-2000 years Before Present (BP), and we want to know how they relate to the rest of the Yersinia pestis genomes in the alignment.\n\nQuestions:\nHow many sequences are we analysing?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nWe are analysing 33 sequences.\n\n\n\nWhat are the Ns in the sequences?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThey represent positions where we have missing data. We told MEGA to encode missing positions as N\n\n\n\nWhat do you think the dots represent?\n\n\n\n\n\n\nTip\n\n\n\nThe first line is a consensus sequence: it indicates the nucleotide supported by the majority of the sequences in the alignment (90% of the sequences should agree, otherwise an N is displayed)\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThey represent positions that are the same as the consensus\n\n\n\nOnce you know this, can you already tell by looking at the alignment which sequence is the most divergent (scroll down)\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nWe can easily see that the last sequence in the alignment (Y. pseudotuberculosis) contains more disagreements to the consensus. This is normal since this is the only genome not belonging to the Y. pestis species: we will use it as an outgroup\n\n\n\n\n\n15.2.3 Distance-based phylogeny: Neighbour Joining\nThe Neighbour Joining (NJ) method is an agglomerative algorithm which can be used to derive a phylogenetic tree from a pairwise distance matrix. In essence, this method will be grouping taxa that have the shortest distance together first, and will be doing this iteratively until all the taxa/sequences included in your alignment have been placed in a tree.\nHere are the details of the calculations for a small NJ tree example with 6 taxa:\n\nLuckily, you won’t have to do this by hand since MEGA allows you to build a NJ tree. For that go back to MEGA and click on the Phylogeny symbol (toolbar of the main menu window) and then select Construct Neighbour Joining Tree. Type “Yes” when you are asked if you want to use the currenctly active date. In the window that pop up, you will then chance the Model/Method to p-distance. Then press OK and a window with the calculated phylogenetic tree will pop up.\n\n\n\n\n\n\n\np-distances?\n\n\n\nA NJ tree can be built from any type of distances. This includes:\n\np-distances (also called raw distances): these are simply the proportion of differences between sequences\ncorrected distances: these are based on an underlying substitution model (JC69, K80, GTR…) and account for multiple substitutions at the same sites (which would result in only one visible difference)\np-distances and corrected distances should be similar when the number of substitutions is low compared to the genome length\n\nnote: a “substitution” is a type of mutation in which a nucleotide is replaced by another.\n\n\nSince the tree is not easily visualised in MEGA, we will export it in newick format (a standard text format for trees) and explore our tree in FigTree. This tool has a better interface for visually manipulating trees and allows us to interact with the phylogenetic tree.\nTo do that you will click on File, then Export current tree (Newick) and click on Branch Lengths to include those in the newick annotation. When you press OK, a new window with the tree in newick format will pop up and you will then press File -&gt; Save and saved it as NJ_tree.nwk. You can then close the text editor and tree explorer windows (no need to save the session).\n\nAs said above, we will explore own NJ tree in FigTree. Open the software by typing figtree & in the terminal (if you use the same terminal window as the one in which you ran mega, you might have to press enter first). Then, open the NJ tree by clicking on File -&gt; Open and selecting the file with the NJ tree NJ_tree.nwk\n\nNote that even though a root is displayed by default in FigTree, NJ trees are actually unrooted. We know that Yersinia pseudotuberculosis (labelled here as Y. pseudotuberculosis) is an outgroup to Yersinia pestis. You can reroot the tree by selecting Y.pseudotuberculosis and pressing Reroot.\n\nNow we have a rooted tree.\nQuestions:\nHow much time did the NJ-tree calculation take?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n~1 second\n\n\n\nHow many leaves/tips has our tree?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n33, i.e. the number of sequences in our SNP alignment.\n\n\n\nWhere are our taxa of interest? (KZL002, GZL002, CHC004 and VLI092)\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThey all fall ancestral to the rest of Yersinia pestis in this tree.\n\n\n\nDo they form a monophyletic group (a clade)?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nYes, they form a monophyletic group. We can also say that this group of prehistoric strains form their own lineage.\n\n\n\n\n\n15.2.4 Probabilistic methods: Maximum Likelihood and Bayesian inference\nThese are the most commonly used approach today. In general, probabilistic methods are statistical techniques that are based on models under which the observed data is generated through a stochastic process depending on a set of parameters which we want to estimate. The probability of the data given the model parameters is called the likelihood.\n\nQuestion:\nIn a phylogenetic probabilistic model, what are the data and what are the parameters?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nIn a phylogenetic probabilistic model, the data is the sequence alignment and the parameters, are:\n\nthe parameters of the chosen substitution model (substitution rates and base frequencies)\nthe phylogenetic tree\n\n\n\n\n\n\n15.2.4.1 Maximum likelihood estimation and bootstrapping\nOne way we can make inferences from a probabilistic model is by finding the combination of parameters which maximises the likelihood. These parameter values are called maximum likelihood (ML) estimates. We are usually not able to compute the likelihood value for all possible combinations of parameters and have to rely on heuristic algorithms to find the maximum likelihood estimates.\n\nThe Maximum likelihood estimates are point estimates, i.e. single parameter values (for example, a tree), which does not allow to measure the associated uncertainty. A classic method to measure the uncertainty in ML trees is bootstrapping, which consists in repeatedly “disturbing” the alignment by masking sites randomly and estimating a tree from each of these bootstrap alignments.\n\nFor each clade in the ML tree, a bootstrap support value is computed which corresponds to the proportion of bootstrap trees containing the clade. This gives an indication of how robustly the clade is supported by the data (i.e. whether it holds even after disturbing the dataset). Bootstrapping can be used to measure the topology uncertainty of trees estimated with any inference method.\n\n\n\n\n\n\nNote\n\n\n\nBootstrapping can be used to measure incertainty with any type of inference method, including distance methods\n\n\nLet’s make our own ML tree!\nHere is a command to estimate an ML phylogenetic tree together with bootstraps using RAxML (you may find the list of parameters in the RAxML manual):\nraxmlHPC-PTHREADS -m GTRGAMMA -T 3 -f a -x 12345 -p 12345 -N autoMRE -s snpAlignment_session5.fasta -n full_dataset.tre\nHere is the meaning of the chosen parameters:\n\nOnce the analysis has been completed, you can open the tree using Figtree (RAxML_bipartitions.full_dataset.tre file, change “label” to “bootstrap support” at the prompt).\n\nThe tree estimated using this model is a substitution tree (branch lengths represent genetic distances in substitutions/site). As for the NJ tree,it is not oriented in time: this is an unrooted tree (displayed with a random root in Figtree). You can reroot the tree in Figtree using Y. pseudotuberculosis as an outgroup, as previously.\nQuestions:\nCan you confirm the position of our genomes of interest (KZL002, GZL002, CHC004 and VLI092)?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nYes. Just as in the NJ tree, they form a clade which is basal to the rest of the Y. pestis diversity.\n\n\n\nIs that placement well-supported? (look at the bootstrap support value: click on the “Node Labels” box and open the drop-down menu, change “Node ages” to “bootstrap support”)\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe placement is strongly supported as indicated by a bootstrap support of 100% for this clade (it is not very easy to see, you probably need to zoom in a bit)\n\n\n\n\nYou can notice that the phylogeny is difficult to visualize due to the long branch leading to Y. pseudotuberculosis. Having a very distant outgroup can also have deleterious effects on the estimated phylogeny (due to the so-called “long branch attraction” effect). We can construct a new phylogeny after removing the outgroup:\n\ngo back to the alignment in mega, unclick Y.pseudotuberculosis, and export in fasta format (“Data” -&gt; “Export Data” -&gt; change “Format” to “Fasta” and click “Ok”; you can save it as: “snpAlignment_without_outgroup.fas”)\nrun raxml on this new alignment (change input to “snpAlignment_without_outgroup.fas” and output prefix to “without_outgroup” in the commandline)\nopen the bipartition… file in figtree and reroot the tree based on the knowledge we have gained previously: place the root on the branch leading to the prehistoric Y. pestis strains (KZL002, GZL002, CHC004 and VLI092).\n\n\nLastly, we will export the rooted tree from figtree: File -&gt; Export trees -&gt; select the “save as currently displayed” box and save as “ML_tree_rooted.tre” (this will be useful for the section “Temporal signal assessment” at the end of this tutorial)\n\n\n\n15.2.4.2 Estimating a time-tree using Bayesian phylogenetics (BEAST2)\nNow, we will try to use reconstruct a phylogeny in which the branch lengths do not represent a number of substitutions but instead represent the time of evolution. To do so, we will use the dates of ancient genomes (C14 dates) to calibrate the tree in time. This assumes a molecular clock hypothesis in which substitutions occur at a rate that is relatively constant in time so that the time of evolution can be estimated based on the number of substitutions.\n\n\n\n\n\n\nNote\n\n\n\nA great advantage of ancient pathogen genomes is that they provide key calibration points to estimate molecular clocks and dated phylogenies. This is more difficult to do with modern data alone.\n\n\nWe will estimate a time-tree from our alignment using Bayesian inference as implemented in the BEAST2 software. Bayesian inference is based on a probability distribution that is different from the likelihood: the posterior probability. The posterior probability is the probability of the parameters given the data. It is easier to interpret than the likelihood because it directly contains all the information about the parameters: point estimates such as the median or the mean can be directly estimated from it, but also percentile intervals which can be used to measure uncertainty.\n\nThe Bayes theorem tells us that the posterior probability is proportional to the product of the likelihood and the “prior” probability of the parameters:\n\nTherefore, for Bayesian inference, we need to complement our probabilistic model with prior distributions for all the parameters. Because we want to estimate a time tree, we also add another parameter: the molecular clock (average substitution rate in time units).\n\nTo characterize the full posterior distribution of each parameter, we would need in theory to compute the posterior probability for each possible combination of parameters. This is impossible, and we will instead use an algorithm called Markov chain Monte Carlo (MCMC) to approximate the posterior distribution. The MCMC is an algorithm which iteratively samples values of the parameters from the posterior distribution. Therefore, if the MCMC has run long enough, the (marginal) posterior distribution of the parameters can be approximated by a histogram of the sampled values.\n\n\n15.2.4.2.1 Set up a BEAST2 analysis\n\n\n\n\n\n\nTip\n\n\n\nThe “taming the beast” website has great tutorials to learn setting a BEAST2 analysis. In particular, the “Introduction to BEAST2”, “Prior selection” and “Time-stamped data” are good starts.\n\n\nThe different components of the BEAST2 analysis can be set up in the program BEAUti:\n\nOpen BEAUTi by typing beauti & in the terminal, and set up an analysis as followed:\n\nload the alignment without outgroup in the “Partitions” tab (“File” -&gt; “Import alignment”; select “nucleotide”)\n\n\n\nset the sampling dates in the “Tip dates” tab:\n\nselect “Use tip dates”\nclick on “Auto-configure” -&gt; “read from file” and select the sample_dates.txt file\nchange “Since some time in the past” to “Before present”\n\n\n\n\nselect the substitution model in the “Site model” tab:\n\nchose a GTR model\nuse 4 Gamma categories for the Gamma site model: this is to account for variations of the substitution rate accross sites (site=nucleotide position)\n\n\n\n\nchoose the molecular clock model in the “Clock model” tab:\n\nuse a relaxed clock lognormal model (this is to allow for some variation of the clock rate accross branches)\nchange the initial value of the clock rate to 10-4 substitution/site/year (10-4 can be written 1E-4)\n\n\n\n\nchoose the prior distribution of parameters in the “Priors” tab:\n\nuse a Coalescent Bayesian Skyline tree prior\nchange the mean clock prior to a uniform distribution between 1E-6 and 1E-3 subst/site/year\nleave everything else to default\n\n\n\n\nset up the MCMC in the “MCMC” tab:\n\nuse a chain length of 300M\nsample the monodimensional parameters and trees every 10,000 iterations (unfold “tracelog” and “treelog” menus and change “log every” to 10,000)\n\n\n\n\nsave the analysis setup as an xml file: “File” -&gt; “Save as”; you can name the file “beast_analysis_Y_pestis.xml”\n\nNow that the analysis is setup, we can run it using BEAST:\nbeast beast_analysis_Y_pestis.xml\nOnce the analysis is running two files should have been created and are continuously updated:\n\nthe “snpAlignment_without_outgroup.log” file which contains the values sampled by the MCMC for various monodimensional parameters such as the clock rate, as well as other values that are a logged along the MCMC such as the posterior probability and the likelihood.\nthe “snpAlignment_without_outgroup.trees” file which contains the MCMC trees sampled by the MCMC\n\nWhile the analysis is running, you can start reading the next section\n\n\n15.2.4.2.2 Assessing BEAST2 results\n\n\n\n\n\n\nReminder\n\n\n\nWe are using an MCMC algorithm to sample the posterior distribution of parameters. If the MCMC has run long enough, we can use the sampled parameters to approximate the posterior distribution itself. Therefore, we have to check first that the MCMC chain has run long enough.\n\n\nWe can assess the MCMC sampling using the program Tracer. Tracer can read BEAST log files an generate statistics and plots for each of the sampled parameters. Most importantly, Tracer provides:\n\ntrace plots: show the sampled parameter values along the MCMC run. Trace plots are a very useful MCMC diagnostic tool.\n\n\nThe first thing that one needs to assess is wether the MCMC has passed the so called “burn-in” phase. The MCMC starts with a random set of parameters and will take some time to reach a zone of high posterior probability density. The parameter values that are sampled during this initial phase are usually considered as noise and discarded (by default, tracer discards the first 10% of samples). The burn-in phase can be visualize on trace plots as an initial phase during which the posterior probability of sampled parameters is constantly increasing before reaching a plateau:\n\nOnce the burn-in phase is passed, one can look at the trace plots to assess if the parameters have been sampled correctly and long enough. Usually, when this is the case, the trace should be quite dense and oscillating around a central value (nice trace plots should look like “hairy caterpillars”). In the figure below, the trace on the left doesn’t look good, the one on the right does:\n\n– ESS values: tracer also calculates effective sample sizes (ESS) for each of the sampled parameters. ESSs are estimates of the number of sampled parameter values after correcting for auto-correlation along the MCMC. As a rule of thumb, one usually considers that an MCMC as run long enough if all parameter’s ESS are &gt; 200. Note that if the trace looks like a hairy caterpillar, the corresponding ESS value should be high.\n\n– Parameter estimates: Tracer also provides statistics and plots to explore the posterior distribution of the parameters. These should be considered only if the trace plot and ESS values look fine. In the “Estimates” tab, after selecting the chosen parameter in the left panel, the upper-right panel shows point estimates (mean, median) and measures of uncertainty (95% HPD interval), and the bottom-right panel shows a histogram of the sampled value:\n\nLet’s now load the “snpAlignment_without_outgroup.log” file into Tracer. Open a new terminal tab, activate the conda environemnt with conda activate phylogenomics, open tracer with tracer &, and then “File” -&gt; “Import trace file” -&gt; select “snpAlignment_without_outgroup.log”. Note that one can load a BEAST2 log file into tracer even if the analysis is still running. This allows to assess if the MCMC is running correctly or has run long enough before it’s completed.\nQuestion:\nHas the MCMC run long enough?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nYou have probably let you analysis run for 10-20 mins before looking at the log file, and this is definitely not sufficient: the burnin phase has recently been passed, the trace plots do not look very dense and ESS values are low. It would probably take a few hours for the analysis to complete. Luckily we have run the analysis in advance and saved the log files for you in the “intermediateFiles” folder: “snpAlignment_without_outgroup.log” and “snpAlignment_without_outgroup.trees”\n\n\n\n\nYou can now load the “intermediateFiles/snpAlignment_without_outgroup.log” file into Tracer.\nQuestions:\nHas the MCMC run long enough?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nYes! The trace plots look good and all ESSs are &gt; 200 \n\n\n\nWhat is your mean estimate of the clock rate (ucld mean)?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n~7.10-6 substitution/site/year. Note, however, that this estimate is largely biased since we used a SNP alignment containing only variable positions. In order to get an unbiased estimate of the substitution rate, we should have used the full alignment or account for the number of constant sites by using a “filtered” alignment (see here). In general, this is good practice since not accounting for conserved positions in the alignment can sometimes affect the tree as well (although this should usually be minor, which is why we didn’t bother to do this here).\n\n\n\n\n\n\n15.2.4.2.3 MCC tree\nSince we are working in a Bayesian framework, we do not obtain a single phylogenetic tree as with Maximum likelihood, but a large set of trees which should be representative of the posterior distribution. In contrast with monodimensional parameters, a tree distribution cannot be easily summarized with mean or median estimates. Instead, we need to use specific tree-summarizing techniques. One of the most popular is the maximum clade credibility (MCC) tree, which works as follow:\n\n\nFor any node in any of the sampled trees, compute a posterior support: the proportion of trees in the sample which contain the node\n\n\nSelect the MCC tree: this is the tree in which the product of node posterior supports is the highest\n\n\nCalculate node/branch statistics on the MCC tree: typically, the mean/median estimates and HPD interval of node ages are calculated from the full tree sample and annotated on the MCC tree\n\n\n\nLet’s generate an MCC tree from our tree sample. We can do this using the TreeAnnotator software, which has both a commnadline and graphical interface. Let’s use the commandline here and run the following (using a burn-in of 10%):\n treeannotator -burnin 10 intermediateFiles/snpAlignment_without_outgroup.trees snpAlignment_without_outgroup.MCC.tree\nOnce this is completed, we can open the MCC tree with figtree. Let’s then add a few elements to the plot:\n\n\nTick the “Scale Axis” box, unfold the corresponding menu, and select “Reverse axis” (now the timescale is in years BP)\n\n\nTick the “Node Labels” box, unfold the corresponding menu, and select “Display: posterior”. The posterior support of each node is now displayed. Note that the support value is a proportion (1=100%)\n\n\nTick the “Node Bars” box, unfold the corresponding menu, and select “Display: height_95%_HPD”. The 95% HPD intervals of node ages are now displayed.\n\n\n\nQuestions:\nIs the root of the tree consistent with what we found previously?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nYes! The root is placed between our prehistoric strains and the rest of Y. pestis strains. Note that this time we didn’t have to use an outgroup because we estimated a time-tree: the root is identified as the oldest node in the tree.\n\n\n\nWhat is your estimate for the age of the most recent common ancestor of all Y. pestis strains?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n~5800 years BP (HPD 95%: ~8000-4500 years BP)\n\n\n\n\n\n\n15.2.4.3 Bonus: Temporal signal assessment\nIt is a good practice to assess if the genetic sequences that we analyse do indeed behave like molecular clocks before trying to estimate a time tree (i.e. we should have done this before the actual BEAST2 analysis). A classic way to assess the temporal signal of a dataset is the root-to-tip regression. The rationale of the root-to-tip regression is to verify that the oldest a sequence is, the closer it should be to the root in a (rooted) substitution tree because there was less time for substitution to accumulate. In other words, their should be a correlation between sample age and distance to the root, which we can assess using a linear regression (root-to-tip regression). This can be done using the program TempEst:\n\nopen TempEst by typing tempest & and load the rooted ML tree that we produced previously (you should have saved it as “ML_tree_rooted.tre”)\nclick on “Import Dates” in the “Sample Dates” tab, select the sample_age.txt file and click “OK”\nstill in the “Sample Dates” tab, change “Since some time in the past” to “Before present” (one might need to extand the TempEst window to see the pull down menu)\nlook at the “Root-to-tip tab”: is there a positive correlation between time and root-to-tip divergence as expected under the molecular clock hypothesis?"
  },
  {
    "objectID": "section-ancient-metagenomic-resources.html#accessing-ancient-metagenome-data",
    "href": "section-ancient-metagenomic-resources.html#accessing-ancient-metagenome-data",
    "title": "Ancient Metagenomic Resources",
    "section": "Accessing Ancient Metagenome Data",
    "text": "Accessing Ancient Metagenome Data\nFinding relevant comparative data for your ancient metagenomic analysis is not trivial. While palaeogenomicists are very good at uploading their raw sequencing data to large sequencing data repositories such as the EBI’s ENA or NCBI’s SRA archives in standardised file formats, these files often have limited metadata. This often makes it difficult for researchers to search for and download relevent published data they wish to use use to augment their own analysis.\nAncientMetagenomeDir is a community project from the SPAAM community to make ancient metagenomic data more accessible. We curate a list of standardised metadata of all published ancient metagenomic samples and libraries, hosted on GitHub. In this chapter we will go through how to use the AncientMetagenomeDir repository and associated tools to find and download data for your own analyses. We will also discuss important things to consider when publishing your own data to make it more accessible for other researchers."
  },
  {
    "objectID": "section-ancient-metagenomic-resources.html#ancient-metagenomic-pipelines",
    "href": "section-ancient-metagenomic-resources.html#ancient-metagenomic-pipelines",
    "title": "Ancient Metagenomic Resources",
    "section": "Ancient Metagenomic Pipelines",
    "text": "Ancient Metagenomic Pipelines\nAnalyses in the field of ancient DNA are growing, both in terms of the number of samples processed and in the diversity of our research questions and analytical methods. Computational pipelines are a solution to the challenges of big data, helping researchers to perform analyses efficiently and in a reproducible fashion. Today we will introduce nf-core/eager, one of several pipelines designed specifically for the preprocessing, analysis, and authentication of ancient next-generation sequencing data.\nIn this chapter we will learn how to practically perform basic analyses with nf-core/eager, starting from raw data and performing preprocessing, alignment, and genotyping of several Yersinia pestis-positive samples. We will gain an appreciation of the diversity of analyses that can be performed within nf-core eager, as well as where to find additional information for customizing your own nf-core/eager runs. Finally, we will learn how to use nf-core/eager to evaluate the quality and authenticity of our ancient samples. After this session, you will be ready to strike out into the world of nf-core/eager and build your own analyses from scratch!"
  },
  {
    "objectID": "accessing-ancientmetagenomic-data.html#lecture",
    "href": "accessing-ancientmetagenomic-data.html#lecture",
    "title": "16  Accessing Ancient Metagenomic Data",
    "section": "16.1 Lecture",
    "text": "16.1 Lecture\nLecture slides and video from the 2022 edition of the summer school.\n\n\nPDF version of these slides can be downloaded from here."
  },
  {
    "objectID": "accessing-ancientmetagenomic-data.html#introduction",
    "href": "accessing-ancientmetagenomic-data.html#introduction",
    "title": "16  Accessing Ancient Metagenomic Data",
    "section": "16.2 Introduction",
    "text": "16.2 Introduction\nIn most bioinformatic projects, we need to include publicly available comparative data to expand or compare our newly generated data with.\nIncluding public data can benefit ancient metagenomic studies in a variety of ways. It can help increase our sample sizes (a common problem when dealing with rare archaeological samples) - thus providing stronger statistical power. Comparison with a range of previously published data of different preservational levels can allow an estimate on the quality of the new samples. When considering solely (re)using public data, we can consider that this can also spawn new ideas, projects, and meta analyses to allow further deeper exploration of ancient metagenomic data (e.g., looking for correlations between various environmental factors and preservation).\nFortunately for us, geneticists and particularly palaeogenomicists have been very good at uploading raw sequencing data to well-established databases (Anagnostou et al. 2015).\nIn the vast majority of cases you will be able to find publically available sequencing data on the INSDC association of databases, namely the EBI’s European Nucleotide Archive (ENA), and NCBI or DDBJ’s Sequence Read Archives (SRA). However, you may in some cases find ancient metagenomic data on institutional FTP servers, domain specific databases (e.g. OAGR), Zenodo, Figshare, or GitHub.\nBut while the data is publicly available, we need to ask whether it is ‘FAIR’."
  },
  {
    "objectID": "accessing-ancientmetagenomic-data.html#finding-ancient-metagenomic-data",
    "href": "accessing-ancientmetagenomic-data.html#finding-ancient-metagenomic-data",
    "title": "16  Accessing Ancient Metagenomic Data",
    "section": "16.3 Finding Ancient Metagenomic Data",
    "text": "16.3 Finding Ancient Metagenomic Data\nFAIR principles were defined by researchers, librarians, and industry in 2016 to improve the quality of data uploads - primarily by making data uploads more ‘machine readable’. FAIR standards for:\n\nFindable\nAccessible\nInteroperable\nReproducible\n\nWhen we consider ancient (meta)genomic data, we are pretty close to this. Sequencing data is in most cases accessible (via the public databases like ENA, SRA), interoperable and reproducible because we use field standard formats such as FASTQ or BAM files. However findable remains an issue.\nThis is because the metadata about each data file is dispersed over many places, and very often not with the data files themselves.\nIn this case I am referring to metadata such as: What is the sample’s name? How old is it? Where is it from? Which enzymes were used for library construction? What sequencing machine was this library sequenced on?\nTo find this information about a given data file, you have to search many places (main text, supplementary information, the database itself), for different types of metadata (as authors report different things), and also in different formats (text, tables, figures.\nThis very heterogenous landscape makes it difficult for machines to index all this information (if at all), and thus means you cannot search for the data you want to use for your own research in online search engines."
  },
  {
    "objectID": "accessing-ancientmetagenomic-data.html#ancientmetagenomedir",
    "href": "accessing-ancientmetagenomic-data.html#ancientmetagenomedir",
    "title": "16  Accessing Ancient Metagenomic Data",
    "section": "16.4 AncientMetagenomeDir",
    "text": "16.4 AncientMetagenomeDir\nThis is where the SPAAM community project ‘AncientMetagenomeDir’ comes in (Fellows Yates, Andrades Valtueña, et al. 2021). AncientMetagenomeDir is a resource of lists of metadata of all publishing and publicly available ancient metagenomes and microbial genome-level enriched samples and their associated libraries.\nBy aggregating and standardising metadata and accession codes of ancient metagenomic samples and libraries, the project aims to make it easier for people to find comparative data for their own projects, appropriately re-analyse libraries, as well as help track the field over time and facilitate meta analyses.\nCurrently the project is split over three main tables: host-associated metagenomes (e.g. ancient microbiomes), host-associated single-genomes (e.g. ancient pathogens), and environmental metagenomes (e.g. lakebed cores or cave sediment sequences).\nThe repository already contains more than 2000 samples and 5000 libraries, spanning the entire globe and as far back as hundreds of thousands of years.\nTo make the lists of samples and their metadata as accessible and interoperable as possible, we utilise simple text (TSV - tab separate value) files - files that can be opened by pretty much all spreadsheet tools (e.g., Microsoft Office excel, LibreOffice Calc) and languages (R, Python etc.) (Figure 16.1).\n\n\n\nFigure 16.1: Example few columns and rows of an AncientMetagenomeDir table, including project name, publication year, site name, latitude, longitude, country and sample name.\n\n\nCritically, by standardising the recorded all metadata across all publications this makes it much easier for researchers to filter for particular time periods, geographical regions, or sample types of their interest - and then use the also recorded accession numbers to efficiently download the data.\nAt their core all different AncientMetagenomeDir tables must have at 6 minimum metadata sets at the sample level:\n\nPublication information (doi)\nSample name(s)\nGeographic location (e.g. country, coordinates)\nAge\nSample type (e.g. bone, sediment, etc.)\nData Archive and accessions\n\nEach table then has additional columns depending on the context (e.g. what time of microbiome is expected for host-associated metagenomes, or species name of the genome that was reconstructed).\nThe AncientMetagenomeDir project already has 9 major releases, and will continued to be regularly updated as the community continues to submit new metadata of samples of new publications as they come out."
  },
  {
    "objectID": "accessing-ancientmetagenomic-data.html#amdirt",
    "href": "accessing-ancientmetagenomic-data.html#amdirt",
    "title": "16  Accessing Ancient Metagenomic Data",
    "section": "16.5 AMDirT",
    "text": "16.5 AMDirT\nBut how does one explore such a large dataset of tables with thousands of rows? You could upload this into a spreadsheet tool or in a programming language like R, but you would still have to do a lot of manual filtering and parsing of the dataset to make it useful for downstream analyses.\nIn response to this The SPAAM Community have also developed a companion tool ‘AMDirT’ to facilitate this. Amongst other functionality, AMDirT allows you to load different releases of AncientMetagenomeDir, filter and explore to specific samples or libraries of interest, and then generate download scripts, configuration files for pipelines, and reference BibTeX files for you, both via a command-line (CLI) or graphical user interface (GUI)!\n\n16.5.1 Running AMDirT viewer\nWe will now demonstrate how to use the AMDirT graphical user interface to load a dataset, filter to samples of interest, and download some configuration input files for downstream ancient DNA pipelines.\n\n\n\nFigure 16.2: AMDirT logo: a cog with the SPAAM icon in the middle with the word AMDirT to the side\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThis tutorial will require a web-browser! Make sure to run on your local laptop/PC or, if on on a server, with X11 forwarding activated.\n\n\nFirst, we will need to activate a conda environment, and then install the latest development version of the tool for you.\nWhile in the accessing-ancientmetagenomic-data conda environment, run the following command to load the GUI into your web-browser. If the browser doesn’t automatically load, copy the IP address and paste it in your browser’s URL bar.\nAMDirT viewer\nYour web browser should now load, and you should see a two panel page.\nUnder Select a table use the dropdown menu to select ‘ancientsinglegenome-hostassociated’.\nYou should then see a table (Figure 16.3), pretty similar what you are familiar with with spreadsheet tools such as Microsoft Excel or LibreOffice calc.\n\n\n\nFigure 16.3: Main AMDirT Viewer page on load. A toolbar on the left displays the AMDirT version, and dropdown menus for the AncientMetagenomeDir release, table, and downloading tool to use. The rest of the page shows a tabular window containing rows and columns corresponding to sample metadata and rows of samples with metadata such as project name, publication year and site name.\n\n\nTo navigate, you can scroll down to see more rows, and press shift and scroll to see more columns, or use click on a cell and use your arrow keys (⬆,⬇,⬅,➡) to move around the table.\nYou can reorder columns by clicking on the column name, and also filter by pressing the little ‘burger’ icon that appears on the column header when you hover over a given column.\nAs an exercise, we will try filtering to a particular set of samples, then generate some download scripts, and download the files.\nFirst, filter the project_name column to ‘Kocher2021’ from (Kocher et al. 2021, Figure 16.4).\n\n\n\nFigure 16.4: The AMDirT viewer with a filter menu coming out of the project name column, with just the Kocher 2021 in the search bar.\n\n\nThen scroll to the right, and filter the geo_loc_name to ‘United Kingdom’ (Figure 16.5).\n\n\n\nFigure 16.5: The AMDirT viewer with a filter menu coming out of the geo location column, with just the United Kingdom written in the search bar and the entry ticked in the results.\n\n\nYou should be left with 4 rows.\nFinally, scroll back to the first column and tick the boxes of these four samples (Figure 16.6).\n\n\n\nFigure 16.6: The AMDirT viewer with just four rows with samples from Kocher2021 that are located in the United Kingdom being displayed, and the tickboxes next to each one selected\n\n\nOnce you’ve selected the samples you want, you can press Validate selection. You should then see a series loading-spinner, and new a lot of buttons should appear (Figure 16.7)!\n\n\n\nFigure 16.7: The AMDirT viewer after pressing the ‘validate selection’ button. A range of buttons are displayed at the bottom including a warning message, with the buttons offering download of a range of files such as download scripts, AncientMetagenomeDir library tables and input configuration sheets for a range of ancient DNA bioinformatics pipelines\n\n\nYou should have four categories of buttons:\n\nDownload AncientMetagenomeDir Library Table\nDownload Curl sample download script\nDownload &lt;tool/pipeline name&gt; input TSV\nDownload Citations as BibText\n\nThe first button is to download a table containing all the AncientMetagenomeDir metadata of the selected amples. The second is for generating a download script that will allow you to immediately download all sequencing data of the samples you selected. The third set of buttons generate (partially!) pre-configured input files for use in dedicated ancient DNA pipeline such as nf-core/eager (Fellows Yates, Lamnidis, et al. 2021), PALAEOMIX (Schubert et al. 2014), and/or and aMeta (Pochon et al. 2022). Finally, the fourth button generates a text file with (in most cases) all the citations of the data you downloaded, in a format accepted by most reference/citation managers. In this case the reference metadata for that particular publictcation isn’t publicly available so there is a warning.\nIt’s important to note you are not necessarily restricted to Curl for downloading the data. AMDirT aims to add support for whatever tools or pipelines requested by the community. For example, an already supported downloading tool alternative is the nf-core/fetchNGS pipeline. You can select these using the drop-down menus on the left hand-side.\nPress the AncientMetagenomeDir library, curl download, and nf-core/eager buttons to download two .tsv files, one *.sh file and one ’*bib’ file. Once this is done, you can close the tab of the web browser, and in the terminal you can press ctrl + c to shutdown the tool.\n\n\n16.5.2 Inspecting AMDirT viewer Output\nLets look at the files that AMDirT has generated for you.\nFirst you should cd into the directory that your web browser downloaded the files into (e.g. cd ~/Downloads/), then look inside the directory. You should see the following three files\n$ ls\nAncientMetagenomeDir_bibliography.bib\nAncientMetagenomeDir_curl_download_script.sh\nAncientMetagenomeDir_filtered_libraries.csv\nAncientMetagenomeDir_nf_core_eager_input_table.tsv\nWe can simple run cat on each file to look inside. If you run cat on the curl download script, you should see a series of curl commands with the correct ENA links for you for each of the samples you wish to download.\n$ cat AncientMetagenomeDir_curl_download_script.sh\n#!/usr/bin/env bash\ncurl -L ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR605/009/ERR6053619/ERR6053619.fastq.gz -o ERR6053619.fastq.gz\ncurl -L ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR605/008/ERR6053618/ERR6053618.fastq.gz -o ERR6053618.fastq.gz\ncurl -L ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR605/005/ERR6053675/ERR6053675.fastq.gz -o ERR6053675.fastq.gz\ncurl -L ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR605/006/ERR6053686/ERR6053686.fastq.gz -o ERR6053686.fastq.gz\nBy providing this script for you, AMDirT facilitates fast download of files of interest by replacing the one-by-one download commands for each sample with a single command!\n$ bash AncientMetagenomeDir_curl_download_script.sh\ncurl -L ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR605/009/ERR6053619/ERR6053619.fastq.gz -o ERR6053619.fastq.gz\ncurl -L ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR605/008/ERR6053618/ERR6053618.fastq.gz -o ERR6053618.fastq.gz\ncurl -L ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR605/005/ERR6053675/ERR6053675.fastq.gz -o ERR6053675.fastq.gz\ncurl -L ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR605/006/ERR6053686/ERR6053686.fastq.gz -o ERR6053686.fastq.gz\nRunning this command should result in progress logs of the downloading of the data of the four selected samples!\nOnce the four samples are downloaded, AMDirT then facilitates fast processing of the data, as the eager script can be given directly to nf-core/eager as input. Importantly by including the library metadata (mentioned above), researchers can leverage the complex automated processing that nf-core/eager can perform when given such relevant metadata.\n$ cat AncientMetagenomeDir_nf_core_eager_input_table.tsv\nSample_Name Library_ID  Lane    Colour_Chemistry    SeqType Organism    Strandedness    UDG_Treatment   R1  R2  BAM\nI0157   ERR6053618  0   4   SE  Homo sapiens    double  unknown ERX5692504_ERR6053618.fastq.gz  NA  NA\nI0161   ERR6053619  0   4   SE  Homo sapiens    double  unknown ERX5692505_ERR6053619.fastq.gz  NA  NA\nOAI017  ERR6053675  0   4   SE  Homo sapiens    double  half    ERX5692561_ERR6053675.fastq.gz  NA  NA\nSED009  ERR6053686  0   4   SE  Homo sapiens    double  half    ERX5692572_ERR6053686.fastq.gz  NA  NA\nFinally, we can look into the BibTeX citations file (*bib) which will provide you with the citation information of all the downloaded data and AncientMetagenomeDir itself.\n\n\n\n\n\n\nWarning\n\n\n\nThe contents of this file is reliant on indexing of publications on CrossRef. In some cases not all citations will be present (as per the warning), so this should be double checked!\n\n\n$ cat AncientMetagenomeDir_bibliography.bib\n@article{Fellows_Yates_2021,\n    doi = {10.1038/s41597-021-00816-y},\n    url = {https://doi.org/10.1038%2Fs41597-021-00816-y},\n    year = 2021,\n    month = {jan},\n    publisher = {Springer Science and Business Media {LLC}},\n    volume = {8},\n    number = {1},\n    author = {James A. Fellows Yates and Aida Andrades Valtue{\\~{n}}a and {\\AA}shild J. V{\\aa}gene and\n    Becky Cribdon and Irina M. Velsko and Maxime Borry and Miriam J. Bravo-Lopez and Antonio Fernandez-Guerra\n    and Eleanor J. Green and Shreya L. Ramachandran and Peter D. Heintzman and Maria A. Spyrou and Alexander\n    Hübner and Abigail S. Gancz and Jessica Hider and Aurora F. Allshouse and Valentina Zaro and Christina Warinner},\n    title = {Community-curated and standardised metadata of published ancient metagenomic samples with {AncientMetagenomeDir}},\n    journal = {Scientific Data}\n}\nThis file can be easily loaded into most reference managers and then have all the citations quickly added to your manuscripts.\n\n\n16.5.3 AMDirT convert\nIf you’re less of a GUI person and consider yourself a command-line wizard, you can also use the AMDirT convert command instead of the GUI version.\nIn this case you must supply your own filtered AncientMetagenomeDir samples table, and use command line options to specify which files to generate.\nFor example, lets say you used R to make the following filtered file (basically the same Kocher et al. 2021 samples from the UK, as filtered in the GUI part of this tutorial), you would supply this to AMDirT convert like so:\n$ AMDirT convert -o . --bibliography --librarymetadata --curl --eager ancientsinglegenome-hostassociated_samples_Kocher2021_UnitedKingdom.tsv ancientsinglegenome-hostassociated\nWhen running ls you should see the same resulting files as before with the GUI!\n$ ls\nAncientMetagenomeDir_bibliography.bib\nAncientMetagenomeDir_curl_download_script.sh\nAncientMetagenomeDir_filtered_libraries.tsv\nAncientMetagenomeDir_nf_core_eager_input_table.tsv\nancientsinglegenome-hostassociated_samples_Kocher2021_UnitedKingdom.tsv\nIn this case you say where to save the output files, then use different flags to specify which scripts, bib, and configuration files you want, and finally your filtered AncientMetagenomeDir TSV file and which table it’s derived from."
  },
  {
    "objectID": "accessing-ancientmetagenomic-data.html#git-practise",
    "href": "accessing-ancientmetagenomic-data.html#git-practise",
    "title": "16  Accessing Ancient Metagenomic Data",
    "section": "16.6 Git Practise",
    "text": "16.6 Git Practise\nA critical factor of AncientMetagenomeDir is that it is community-based. The community curates all new submissions to the repository, and this all occurs with Git and GitHub.\nThe data is hosted and maintained on GitHub - new publications are evaluated on issues, submissions created on branches, made by pull requests, and PRs reviewed by other members of the community.\nYou can see the workflow in the image below from the AncientMetagenomeDir publication, and read more about the workflow on the AncientMetagenomeDir wiki\n\n\n\nFigure 16.8: Overview of the AncientMetagenomeDir contribution workflow. Potential publications are added as a GitHub issue where they undergo relevance evaluation. Once approved, a contributor makes a branch on the AncientMetagenomeDir GitHub repository, adds the new lines of metadata for the relevant samples and libraries, and once ready opens a pull request against the main repository. The pull request undergoes an automated consistent check against a schema and then undergoes a human-based peer review for accuracy against AncientMetagenomeDir guidelines. Once approved, the pull request is merged, and periodically the dataset is released on GitHub and automatically archived on Zenodo.\n\n\nAs AncientMetagenomeDir is on GitHub, the means we can also use this repository to try out our Git skills we learnt in the chapter Introduction to Git(Hub)!\nYour task is to complete the following steps however with git terms removed (indicated by quotes). You should be able to complete the steps and also note down what the correct Git terminology:\n\nMake a ‘copy’ the jfy133/AncientMetagenomeDir repository to your account\n\nWe are forking a personal fork of the main repository to ensure you don’t accidentally edit the main dataset!\n\n‘Download’ the ‘copied’ repo to your local machine\n‘Change’ to the dev branch\nModify the file ancientsinglegenome-hostassociated_samples.tsv\n\nClick here to get some example data to copy in to the end of the TSV file\n\n‘Send’ back to Git(Hub)\nOpen a ‘request’ adding the changes to the original jfy133/AncientMetagenomeDir repo\n\nMake sure to put ‘Summer school’ in the title of the ‘Request’\n\n\n\n\n\n\n\n\nClick me to reveal the correct terminology\n\n\n\n\n\n\nFork the jfy133/AncientMetagenomeDir repository to your account\nClone the copied repo to your local machine\nSwitch to the dev branch\nModify ancientsinglegenome-hostassociated_samples.tsv\nCommit and Push back to your Fork on Git(Hub)\nOpen a Pull Request adding changes to the original jfy133/AncientMetagenomeDir repo\n\nMake sure to put ‘Summer school’ in the title of the pull request"
  },
  {
    "objectID": "accessing-ancientmetagenomic-data.html#summary",
    "href": "accessing-ancientmetagenomic-data.html#summary",
    "title": "16  Accessing Ancient Metagenomic Data",
    "section": "16.7 Summary",
    "text": "16.7 Summary\n\nReporting of metadata messy! Consider when publishing your own work!\n\nUse AncientMetagenomeDir as a template\n\nUse AncientMetagenomeDir and AMDirT (beta) to rapidly find public ancient metagenomic data\nContribute to AncientMetagenomeDir with git\n\nCommunity curated!"
  },
  {
    "objectID": "accessing-ancientmetagenomic-data.html#resources",
    "href": "accessing-ancientmetagenomic-data.html#resources",
    "title": "16  Accessing Ancient Metagenomic Data",
    "section": "16.8 Resources",
    "text": "16.8 Resources\n\nAncientMetagenomeDir paper\nAncientMetagenomeDir repository\nAMDirT web server\nAMDirT documentation\nAMDirT repository\n\n\n\n\n\nAnagnostou, Paolo, Marco Capocasa, Nicola Milia, Emanuele Sanna, Cinzia Battaggia, Daniela Luzi, and Giovanni Destro Bisol. 2015. “When Data Sharing Gets Close to 100%: What Human Paleogenetics Can Teach the Open Science Movement.” PloS One 10 (3): e0121409. https://doi.org/10.1371/journal.pone.0121409.\n\n\nFellows Yates, James A, Aida Andrades Valtueña, Åshild J Vågene, Becky Cribdon, Irina M Velsko, Maxime Borry, Miriam J Bravo-Lopez, et al. 2021. “Community-Curated and Standardised Metadata of Published Ancient Metagenomic Samples with AncientMetagenomeDir.” Scientific Data 8 (1): 31. https://doi.org/10.1038/s41597-021-00816-y.\n\n\nFellows Yates, James A, Thiseas C Lamnidis, Maxime Borry, Aida Andrades Valtueña, Zandra Fagernäs, Stephen Clayton, Maxime U Garcia, Judith Neukamm, and Alexander Peltzer. 2021. “Reproducible, Portable, and Efficient Ancient Genome Reconstruction with Nf-Core/Eager.” PeerJ 9 (March): e10947. https://doi.org/10.7717/peerj.10947.\n\n\nKocher, Arthur, Luka Papac, Rodrigo Barquera, Felix M Key, Maria A Spyrou, Ron Hübler, Adam B Rohrlach, et al. 2021. “Ten Millennia of Hepatitis B Virus Evolution.” Science 374 (6564): 182–88. https://doi.org/10.1126/science.abi5658.\n\n\nPochon, Zoé, Nora Bergfeldt, Emrah Kırdök, Mário Vicente, Thijessen Naidoo, Tom van der Valk, N Ezgi Altınışık, et al. 2022. “aMeta: An Accurate and Memory-Efficient Ancient Metagenomic Profiling Workflow.” bioRxiv. https://doi.org/10.1101/2022.10.03.510579.\n\n\nSchubert, Mikkel, Luca Ermini, Clio Der Sarkissian, Hákon Jónsson, Aurélien Ginolhac, Robert Schaefer, Michael D Martin, et al. 2014. “Characterization of Ancient and Modern Genomes by SNP Detection and Phylogenomic and Metagenomic Analysis Using PALEOMIX.” Nature Protocols 9 (5): 1056–82. https://doi.org/10.1038/nprot.2014.063."
  },
  {
    "objectID": "ancient-metagenomic-pipelines.html#lecture",
    "href": "ancient-metagenomic-pipelines.html#lecture",
    "title": "17  Ancient Metagenomic Pipelines",
    "section": "17.1 Lecture",
    "text": "17.1 Lecture\nLecture slides and video from the 2022 edition of the summer school.\n\n\nPDF version of these slides can be downloaded from here."
  },
  {
    "objectID": "ancient-metagenomic-pipelines.html#introduction",
    "href": "ancient-metagenomic-pipelines.html#introduction",
    "title": "17  Ancient Metagenomic Pipelines",
    "section": "17.2 Introduction",
    "text": "17.2 Introduction\nA pipeline is a series of linked computational steps, where the output of one process becomes the input of the next. Pipelines are critical for managing the huge quantities of data that are now being generated regularly as part of ancient DNA analyses. Today we will discuss one option for managing computational analyses of ancient next-generation sequencing datasets, nf-core/eager. Keep in mind that other tools, like the Paleomix pipeline, can also be used for similar applications."
  },
  {
    "objectID": "ancient-metagenomic-pipelines.html#what-is-nf-coreeager",
    "href": "ancient-metagenomic-pipelines.html#what-is-nf-coreeager",
    "title": "17  Ancient Metagenomic Pipelines",
    "section": "17.3 What is nf-core/eager?",
    "text": "17.3 What is nf-core/eager?\nnf-core/eager is a computational pipeline specifically designed for preprocessing and analysis of ancient DNA data. It is a reimplementation of the previously published EAGER (Efficient Ancient Genome Reconstruction) pipeline (Peltzer et al. 2016) using Nextflow. The nf-core/eager pipeline was designed with the following aims in mind:\n\nPortability- In order for our analyses to be reproducible, others should be able to easily implement our computational pipelines. nf-core/eager is highly portable, providing easy access to pipeline tools and facilitating use across multiple platforms. nf-core eager utilizes Docker, Conda, and Singularity for containerization, enabling distrubition of the pipeline in a self-contained bundle containing all the code, packages, and libraries needed to run it.\nReproducibility- nf-core/eager uses custom configuration profiles to specify both HPC-level parameters and analyses-specific options. These profiles can be shared alongside your publication, making it easier for others to reproduce your methodology!\nNew Tools- Finally, nf-core/eager includes additional, novel methods and tools for analysis of ancient DNA data that were not included in previous versions. This is especially good news for folks interested in microbial sciences, who can take advantage of new analytical pathways for metagenomic analysis and pathogen screening.\n\n\n17.3.1 Steps in the pipeline\n\nA detailed description of steps in the pipeline is available as part of nf-core/eager’s extensive documentation. For more information, check out the usage documentation here.\nBriefly, nf-core/eager takes standard input file types that are shared across the genomics field, including raw fastq files, aligned reads in bam format, and a reference fasta. nf-core/eager can perform preprocessing of this raw data, including adapter clipping, read merging, and quality control of adapter-trimmed data. Note that input files can be specified using wildcards OR a standardized tsv format file; the latter facilitates streamlined integration of multpile data types within a single EAGER run! More on this later.\nnf-core/eager facilitates mapping using a variety of field-standard alignment tools with configurable parameters. An exciting new addition in nf-core/eager also enables analysis of off-target host DNA for all of you metagenomics folks out there. Be sure to check out the functionality available for metagenomic profiling (blue route in the ‘tube map’ above).\nnf-core/eager incorporates field-standard quality control tools designed for use with ancient DNA so that you can easily evaluate the success of your experiments. Multiple genotyping approaches and additional analyses are available depending on your input datatype, organism, and research questions. Importantly, all of these processes generate data that we need to compile and analyze in a coherent way. nf-core eager uses MultiQC. to create an integrated html report that summarizes the output/results from each of the pipeline steps. Stay tuned for the practical portion of the walkthrough!\n\n\n17.3.2 How to build an nf-core/eager command: A practical introduction\nFor the practical portion of the walkthrough, we will utilize sequencing data from four aDNA libraries, which you should have already downloaded from NCBI. If not, please see the Preparation section above.\nThese four libraries come from from two ancient individuals, GLZ002 and KZL002. GLZ002 comes from the Neolithic Siberian site of Glazkovskoe predmestie adn was radiocarbon dated to 3081-2913 calBCE. KZL002 is an Iron Age individual from Kazakhstan, radiocarbon dated to 2736-2457 calBCE. Both individuals were infected with the so-called ‘Stone Age Plague’ of Yersinia pestis, and libraries from these individuals were processed using hybridization capture to increase the number of Y. pestis sequences available for analysis.\nOur aims in the following tutorial are to:\n\nPreprocess the fastq files by trimming adapters and merging paired-end reads\nAlign reads to the Y. pestis reference and compute the endogenous DNA percentage\nFilter the aligned reads to remove host DNA\nRemove duplicate reads for accurate coverage estimation and genotyping\nMerge data by sample and perform genotyping on the combined dataset\nReview quality control data to evaluate the success of the previous steps\n\nLet’s get started!\nFirst, activate the conda environment that we downloaded during setup:\nconda activate activate ancient-metagenomic-pipelines\nNext, download the latest version of the nf-core/eager repo (or check for updates if you have a previously-installed version):\nnextflow pull nf-core/eager\nFinally, we will build our eager command:\nnextflow run nf-core/eager \\ #Tells nextflow to execute the EAGER pipeline\n-r 2.4.5 -ds1l \\ #Specifies which pipeline and Nextflow versions to run for reproducibility\n-profile conda  \\ #Profiles configure your analysis for specific computing environments/analyses\n--fasta ../reference/GCF_001293415.1_ASM129341v1_genomic.fna \\ #Specify reference in fasta format\n--input ancientMetagenomeDir_eager_input.tsv \\ #Specify input in tsv format or wildcards\n--run_bam_filtering --bam_unmapped_type fastq \\ #Filter unmapped reads and save in fastq format\n--run_genotyping --genotyping_tool ug --gatk_ug_out_mode EMIT_ALL_SITES \\ #Run genotyping with the GATK UnifiedGenotyper\n--run_bcftools_stats #Generate variant calling statistics\nFor full parameter documentation, click here.\nAnd now we wait…\n\n\n17.3.3 Top Tips for nf-core/eager success\n\nScreen sessions\n\nDepending on your input data, infrastructre, and analyses, running nf-core/eager can take hours or even days. To avoid crashed due to loss of power or network connectivity, try running nf-core/eager in a screen or tmux session:\nscreen -R eager\n\nMultiple ways to supply input data\n\nIn this tutorial, a tsv file to specify our input data files and formats. This is a powerful approach that allows nf-core eager to intelligently apply analyses to certain files only (e.g. merging for paired-end but not single-end libraries). Check out the contents of our tsv input file using the following command:\ncat ancientMetagenomeDir_eager_input.tsv\nInputs can also be specified using wildcards, which can be useful for fast analyses with simple input data types (e.g. same sequencing configuration, file location, etc.).\nnextflow run nf-core/eager -r 2.4.5 -ds1l -profile conda --fasta ../reference/GCF_001293415.1_ASM129341v1_genomic.fna\n--input \"data/*fastq.gz\" &lt;...&gt;\nSee the online nf-core/eager documentation for more details.\n\nGet your MultiQC report via email\n\nIf you have GNU mail or sendmail set up on your system, you can add the following flag to send the MultiQC html to your email upon run completion:\n--email \"your_address@something.com\"\n\nCheck out the EAGER GUI\n\nFor folks who might be less comfortable with the command line, check out the nf-core/eager GUI! The GUI also provides a full list of options with short explanations for those interested in learning more about what the pipeline can do.\n\nWhen something fails, all is not lost!\n\nWhen individual jobs fail, nf-coreager will try to automatically resubmit that job with increased memory and CPUs (up to two times per job). When the whole pipeline crashes, you can save time and computational resources by resubmitting with the -resume flag. nf-core/eager will retrieve cached results from previous steps as long as the input is the same.\n\nMonitor your pipeline in real time with the Nextflow Tower\n\nRegular users may be interested in checking out the Nextflow Tower, a tool for monitoring the progress of Nextflow pipelines in real time. Check here for more information.\n\n\n\n\n\n\nTip\n\n\n\nFor this chapter’s exercises, if not already performed, you will need to create the conda environment from the yml file in the following archive, and activate the environment:\nconda activate aMeta"
  },
  {
    "objectID": "ancient-metagenomic-pipelines.html#what-is-ameta",
    "href": "ancient-metagenomic-pipelines.html#what-is-ameta",
    "title": "17  Ancient Metagenomic Pipelines",
    "section": "17.4 What is aMeta?",
    "text": "17.4 What is aMeta?\nIn this section, we will demonstrate an example of using aMeta, an accurate and memory-efficient ancient Metagenomic profiling workflow proposed in Pochon et al. 2023.\n\nIt can be cloned from NBISweden github repository and installed as follows:\ngit clone https://github.com/NBISweden/aMeta\ncd aMeta\nmamba env create -f workflow/envs/environment.yaml\nconda activate aMeta\nTo ensure that aMeta has been correctly installed, we can run a quick test:\ncd .test\n./runtest.sh -j 20\n\n17.4.1 Downloading data, databases and indexes\nFor demonstration purposes we will use 10 simulated with gargammel ancient metagenomic samples used for benchmarking aMeta. The simulated data can be accessed via https://doi.org/10.17044/scilifelab.21261405 and downloaded via terminal using following command lines:\ncd aMeta\nmkdir data && cd data\nwget https://figshare.scilifelab.se/ndownloader/articles/21261405/versions/1 \\\n&& export UNZIP_DISABLE_ZIPBOMB_DETECTION=true && unzip 1 && rm 1\nTo run aMeta, we willl need a small KrakenUniq database. Here we download a pre-built database based on complete microbial NCBI RefSeq reference genomes:\ncd aMeta/resources\nmkdir KrakenUniq_DB && cd KrakenUniq_DB\nwget https://figshare.scilifelab.se/ndownloader/articles/21299541/versions/1 \\\n&& export UNZIP_DISABLE_ZIPBOMB_DETECTION=true && unzip 1 && rm 1\nWe will also need a Bowtie2 index corresponding to the KrakenUniq reference database:\ncd aMeta/resources\nmkdir Bowtie2_index && cd Bowtie2_index\nwget https://figshare.scilifelab.se/ndownloader/articles/21185887/versions/1 \\\n&& export UNZIP_DISABLE_ZIPBOMB_DETECTION=true && unzip 1 && rm 1\nThe last thing we need to download are a few helping files with useful NCBI taxonomy information:\ncd aMeta/resources\nwget https://figshare.scilifelab.se/ndownloader/files/38201982 && \\\nmv 38201982 seqid2taxid.map.orig\nwget https://figshare.scilifelab.se/ndownloader/files/38201937 && \\\nmv 38201937 nucl_gb.accession2taxid\nwget https://figshare.scilifelab.se/ndownloader/files/37395181 && \\\nmv 37395181 library.fna.gz && gunzip library.fna.gz\n\n\n17.4.2 aMeta configuration\nNow we need to configure the workflow. First, we need to create a tab-delimited samples.tsv file inside aMeta/config and provide the names of the input fastq-files:\nsample  fastq\nsample1 data/sample1.fastq.gz\nsample2 data/sample2.fastq.gz\nsample3 data/sample3.fastq.gz\nsample4 data/sample4.fastq.gz\nsample5 data/sample5.fastq.gz\nsample6 data/sample6.fastq.gz\nsample7 data/sample7.fastq.gz\nsample8 data/sample8.fastq.gz\nsample9 data/sample9.fastq.gz\nsample10 data/sample10.fastq.gz\nFurther, we will put details about e.g. databases locations in the config.yaml file inside aMeta/config. A minimal example config.yaml files can look like this:\nsamplesheet: \"config/samples.tsv\"\n\nkrakenuniq_db: resources/KrakenUniq_DB\n\nbowtie2_db: resources/Bowtie2_index/library.pathogen.fna\nbowtie2_seqid2taxid_db: resources/Bowtie2_index/seqid2taxid.pathogen.map\npathogenomesFound: resources/Bowtie2_index/pathogensFound.very_inclusive.tab\n\nmalt_nt_fasta: resources/library.fna\nmalt_seqid2taxid_db: resources/seqid2taxid.map.orig\nmalt_accession2taxid: resources/nucl_gb.accession2taxid\n\nncbi_db: resources/ncbi\n\nn_unique_kmers: 1000\nn_tax_reads: 200\n\n\n17.4.3 Prepare and run aMeta\nNext, we need to create conda sub-environments of aMeta, then manually tune a few memory related parameters of tools (Krona and Malt) included in aMeta:\nsnakemake --snakefile workflow/Snakefile --use-conda --conda-create-envs-only -j 20\n\nenv=$(grep krona .snakemake/conda/*yaml | awk '{print $1}' | sed -e \"s/.yaml://g\" \\\n| head -1)\ncd $env/opt/krona/\n./updateTaxonomy.sh taxonomy\ncd -\n\ncd aMeta\nenv=$(grep hops .snakemake/conda/*yaml | awk '{print $1}' | sed -e \"s/.yaml://g\" \\\n| head -1)\nconda activate $env\nversion=$(conda list malt --json | grep version | sed -e \"s/\\\"//g\" | awk '{print $2}')\ncd $env/opt/malt-$version\nsed -i -e \"s/-Xmx64G/-Xmx1000G/\" malt-build.vmoptions\nsed -i -e \"s/-Xmx64G/-Xmx1000G/\" malt-run.vmoptions\ncd -\nconda deactivate\nAnd, finally, we are ready to run aMeta:\nsnakemake --snakefile workflow/Snakefile --use-conda -j 20\n\n\n17.4.4 aMeta output\nAll output files of the workflow are located in aMeta/results directory. To get a quick overview of ancient microbes present in your samples you should check a heatmap in results/overview_heatmap_scores.pdf.\n\nThe heatmap demonstrates microbial species (in rows) authenticated for each sample (in columns). The colors and the numbers in the heatmap represent authentications scores, i.e. numeric quantification of seven quality metrics that provide information about microbial presence and ancient status. The authentication scores can vary from 0 to 10, the higher is the score the more likely that a microbe is present in a sample and is ancient. Typically, scores from 8 to 10 (red color in the heatmap) provide good confidence of ancient microbial presence in a sample. Scores from 5 to 7 (yellow and orange colors in the heatmap) can imply that either: a) a microbe is present but not ancient, i.e. modern contaminant, or b) a microbe is ancient (the reads are damaged) but was perhaps aligned to a wrong reference, i.e. it is not the microbe you think about. The former is a more common case scenario. The latter often happens when an ancient microbe is correctly detected on a genus level but we are not confident about the exact species, and might be aligning the damaged reads to a non-optimal reference which leads to a lot of mismatches or poor evennes of coverage. Scores from 0 to 4 (blue color in the heatmap) typically mean that we have very little statistical evedence (very few reads) to claim presence of a microbe in a sample.\nTo visually examine the seven quality metrics\n\ndeamination profile,\nevenness of coverage,\nedit distance (amount of mismatches) for all reads,\nedit distance (amount of mismatches) for damaged reads,\nread length distribution,\nPMD scores distribution,\nnumber of assigned reads (depth of coverage),\n\ncorresponding to the numbers and colors of the heatmap, one can find them in results/AUTHENTICATION/sampleID/taxID/authentic_Sample_sampleID.trimmed.rma6_TaxID_taxID.pdf for each sample sampleID and each authenticated microbe taxID. An example of such quality metrics is shown below:"
  },
  {
    "objectID": "ancient-metagenomic-pipelines.html#questions-to-think-about",
    "href": "ancient-metagenomic-pipelines.html#questions-to-think-about",
    "title": "17  Ancient Metagenomic Pipelines",
    "section": "17.5 Questions to think about",
    "text": "17.5 Questions to think about\n\nWhy is it important to use a pipeline for genomic analysis of ancient data?\nHow can the design of the nf-core/eager pipeline help researchers comply with the FAIR principles for management of scientific data?\nWhat metrics do you use to evaluate the success/failure of ancient DNA sequencing experiments? How can these measures be evaluated when using nf-core/eager for data preprocessing and analysis?"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "resources.html#introduction-to-ngs-sequencing",
    "href": "resources.html#introduction-to-ngs-sequencing",
    "title": "18  Resources",
    "section": "18.1 Introduction to NGS Sequencing",
    "text": "18.1 Introduction to NGS Sequencing\n\nhttps://www.youtube.com/watch?v=fCd6B5HRaZ8\nhttps://emea.illumina.com/content/dam/illumina-marketing/documents/products/illumina_sequencing_introduction.pdf"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Anagnostou, Paolo, Marco Capocasa, Nicola Milia, Emanuele Sanna, Cinzia\nBattaggia, Daniela Luzi, and Giovanni Destro Bisol. 2015. “When\nData Sharing Gets Close to 100%: What Human Paleogenetics Can Teach the\nOpen Science Movement.” PloS One 10 (3): e0121409. https://doi.org/10.1371/journal.pone.0121409.\n\n\nDijk, Erwin L van, Hélène Auger, Yan Jaszczyszyn, and Claude Thermes.\n2014. “Ten Years of Next-Generation Sequencing Technology.”\nTrends in Genetics 30 (9): 418–26. https://doi.org/10.1016/j.tig.2014.07.001.\n\n\nFellows Yates, James A, Aida Andrades Valtueña, Åshild J Vågene, Becky\nCribdon, Irina M Velsko, Maxime Borry, Miriam J Bravo-Lopez, et al.\n2021. “Community-Curated and Standardised Metadata of Published\nAncient Metagenomic Samples with\nAncientMetagenomeDir.” Scientific Data 8\n(1): 31. https://doi.org/10.1038/s41597-021-00816-y.\n\n\nFellows Yates, James A, Thiseas C Lamnidis, Maxime Borry, Aida Andrades\nValtueña, Zandra Fagernäs, Stephen Clayton, Maxime U Garcia, Judith\nNeukamm, and Alexander Peltzer. 2021. “Reproducible, Portable, and\nEfficient Ancient Genome Reconstruction with Nf-Core/Eager.”\nPeerJ 9 (March): e10947. https://doi.org/10.7717/peerj.10947.\n\n\nKircher, Martin, Susanna Sawyer, and Matthias Meyer. 2012. “Double\nIndexing Overcomes Inaccuracies in Multiplex Sequencing on the Illumina\nPlatform.” Nucleic Acids Research 40 (1): e3. https://doi.org/10.1093/nar/gkr771.\n\n\nKocher, Arthur, Luka Papac, Rodrigo Barquera, Felix M Key, Maria A\nSpyrou, Ron Hübler, Adam B Rohrlach, et al. 2021. “Ten Millennia\nof Hepatitis B Virus Evolution.” Science\n374 (6564): 182–88. https://doi.org/10.1126/science.abi5658.\n\n\nMa, Xiaotu, Ying Shao, Liqing Tian, Diane A Flasch, Heather L Mulder,\nMichael N Edmonson, Yu Liu, et al. 2019. “Analysis of Error\nProfiles in Deep Next-Generation Sequencing Data.” Genome\nBiology 20 (1): 50. https://doi.org/10.1186/s13059-019-1659-6.\n\n\nMeyer, Matthias, and Martin Kircher. 2010. “Illumina Sequencing\nLibrary Preparation for Highly Multiplexed Target Capture and\nSequencing.” Cold Spring Harbor Protocols 2010 (6):\ndb.prot5448. https://doi.org/10.1101/pdb.prot5448.\n\n\nPochon, Zoé, Nora Bergfeldt, Emrah Kırdök, Mário Vicente, Thijessen\nNaidoo, Tom van der Valk, N Ezgi Altınışık, et al. 2022. “aMeta: An Accurate and Memory-Efficient Ancient\nMetagenomic Profiling Workflow.” bioRxiv. https://doi.org/10.1101/2022.10.03.510579.\n\n\nSchubert, Mikkel, Luca Ermini, Clio Der Sarkissian, Hákon Jónsson,\nAurélien Ginolhac, Robert Schaefer, Michael D Martin, et al. 2014.\n“Characterization of Ancient and Modern Genomes by\nSNP Detection and Phylogenomic and Metagenomic Analysis\nUsing PALEOMIX.” Nature Protocols 9 (5):\n1056–82. https://doi.org/10.1038/nprot.2014.063.\n\n\nSchuster, Stephan C. 2008. “Next-Generation Sequencing Transforms\nToday’s Biology.” Nature Methods 5 (1): 16–18. https://doi.org/10.1038/nmeth1156.\n\n\nShendure, Jay, and Hanlee Ji. 2008. “Next-Generation\nDNA Sequencing.” Nature Biotechnology 26\n(10): 1135–45. https://doi.org/10.1038/nbt1486.\n\n\nSinha, Rahul, Geoff Stanley, Gunsagar Singh Gulati, Camille Ezran, Kyle\nJoseph Travaglini, Eric Wei, Charles Kwok Fai Chan, et al. 2017.\n“Index Switching Causes ‘Spreading-of-Signal’ Among\nMultiplexed Samples in Illumina HiSeq 4000 DNA\nSequencing.” bioRxiv. https://doi.org/10.1101/125724.\n\n\nSlatko, Barton E, Andrew F Gardner, and Frederick M Ausubel. 2018.\n“Overview of Next-Generation Sequencing Technologies.”\nCurrent Protocols in Molecular Biology / Edited by Frederick M.\nAusubel ... [Et Al.] 122 (1): e59. https://doi.org/10.1002/cpmb.59.\n\n\nValk, Tom van der, Francesco Vezzi, Mattias Ormestad, Love Dalén, and\nKaterina Guschanski. 2019. “Index Hopping on the Illumina\nHiseqX Platform and Its Consequences for Ancient\nDNA Studies.” Molecular Ecology Resources,\nMarch. https://doi.org/10.1111/1755-0998.13009."
  },
  {
    "objectID": "tools.html#introduction-to-r-and-the-tidyverse",
    "href": "tools.html#introduction-to-r-and-the-tidyverse",
    "title": "19  Tools",
    "section": "19.1 Introduction to R and the Tidyverse",
    "text": "19.1 Introduction to R and the Tidyverse\n\nr\nr studio (desktop)\ntidyverse"
  },
  {
    "objectID": "tools.html#introduction-to-python-and-pandas",
    "href": "tools.html#introduction-to-python-and-pandas",
    "title": "19  Tools",
    "section": "19.2 Introduction to Python and Pandas",
    "text": "19.2 Introduction to Python and Pandas\n\npython\njupyter"
  },
  {
    "objectID": "tools.html#introduction-to-github",
    "href": "tools.html#introduction-to-github",
    "title": "19  Tools",
    "section": "19.3 Introduction to Git(Hub)",
    "text": "19.3 Introduction to Git(Hub)\n\ngit (normally installed by default on all UNIX based operating systems e.g. Linux, OSX)"
  },
  {
    "objectID": "tools.html#functional-profiling",
    "href": "tools.html#functional-profiling",
    "title": "19  Tools",
    "section": "19.4 Functional Profiling",
    "text": "19.4 Functional Profiling\n\nr\nr studio (desktop)\ntidyverse\nhumann3"
  },
  {
    "objectID": "tools.html#de-novo-assembly",
    "href": "tools.html#de-novo-assembly",
    "title": "19  Tools",
    "section": "19.5 De novo assembly",
    "text": "19.5 De novo assembly\n\nfastp\nmegahit\nbowtie2\nsamtools\nbioawk\ndiamond\nmetabat2\nmaxbin2\nconcoct\nmetawrap\ncheckm-genome\ngunc\npydamage\nprokka"
  },
  {
    "objectID": "tools.html#genome-mapping",
    "href": "tools.html#genome-mapping",
    "title": "19  Tools",
    "section": "19.6 Genome Mapping",
    "text": "19.6 Genome Mapping\n\nbwa\nigv\ngatk"
  },
  {
    "objectID": "tools.html#phylogenomics",
    "href": "tools.html#phylogenomics",
    "title": "19  Tools",
    "section": "19.7 Phylogenomics",
    "text": "19.7 Phylogenomics\n\nbeast2_\ntracer\ntempest\nmega"
  },
  {
    "objectID": "tools.html#ancient-metagenomic-pipelines",
    "href": "tools.html#ancient-metagenomic-pipelines",
    "title": "19  Tools",
    "section": "19.8 Ancient Metagenomic Pipelines",
    "text": "19.8 Ancient Metagenomic Pipelines\n\nnextflow\nnf-core tools\nnf-core/eager"
  },
  {
    "objectID": "python-pandas.html#reading-data-with-pandas",
    "href": "python-pandas.html#reading-data-with-pandas",
    "title": "8  Introduction to Python and Pandas",
    "section": "8.5 Reading data with Pandas",
    "text": "8.5 Reading data with Pandas\nPandas can read in csv (comma separated values) files, which are tables in text format.\nIt’s called csv becase each value is separated from the others via a comma, like this:\nA,B\n5,6\n8,4\nout -\n\n\n\n\n\n\nA\n\n\nB\n\n\n\n\n1\n\n\n2\n\n\n3\n\n\n\n\n2\n\n\n3\n\n\n4\n\n\n\n\nAnother common tabluar seperater are tsv, where each value is seperated by a tab \\t\nA\\tB\n5\\t6\n8\\t4\n\nOur dataset \"all_data.tsv\" is tab separated, which Pandas can handle using the sep argument.\n\n\n\n\n\n\n\nPandas function\n\n\n\npd.read_csv() is the pandas function to read in tabular tables. The sep= can be specified argument, sep=, is the default.\n\n\ndf = pd.read_csv(\"all_data.tsv\", sep=\"\\t\")\ndf\n’\n\n\n\n\n\n\n\n\n\n\n\nID\n\n\n\nYear_Birth\n\n\n\nEducation\n\n\n\nMarital_Status\n\n\n\nIncome\n\n\n\nKidhome\n\n\n\nTeenhome\n\n\n\nMntWines\n\n\n\nMntFruits\n\n\n\nMntMeatProducts\n\n\n\nMntFishProducts\n\n\n\nMntSweetProducts\n\n\n\nMntGoldProds\n\n\n\nNumWebPurchases\n\n\n\nNumCatalogPurchases\n\n\n\nNumStorePurchases\n\n\n\nNumWebVisitsMonth\n\n\n\nComplain\n\n\n\nZ_CostContact\n\n\n\nZ_Revenue\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n5524\n\n\n\n1957\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n58138.0\n\n\n\n0\n\n\n\n0\n\n\n\n635\n\n\n\n88\n\n\n\n546\n\n\n\n172\n\n\n\n88\n\n\n\n88\n\n\n\n8\n\n\n\n10\n\n\n\n4\n\n\n\n7\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1\n\n\n\n2174\n\n\n\n1954\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n46344.0\n\n\n\n1\n\n\n\n1\n\n\n\n11\n\n\n\n1\n\n\n\n6\n\n\n\n2\n\n\n\n1\n\n\n\n6\n\n\n\n1\n\n\n\n1\n\n\n\n2\n\n\n\n5\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n2\n\n\n\n4141\n\n\n\n1965\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n71613.0\n\n\n\n0\n\n\n\n0\n\n\n\n426\n\n\n\n49\n\n\n\n127\n\n\n\n111\n\n\n\n21\n\n\n\n42\n\n\n\n8\n\n\n\n2\n\n\n\n10\n\n\n\n4\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n3\n\n\n\n6182\n\n\n\n1984\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n26646.0\n\n\n\n1\n\n\n\n0\n\n\n\n11\n\n\n\n4\n\n\n\n20\n\n\n\n10\n\n\n\n3\n\n\n\n5\n\n\n\n2\n\n\n\n0\n\n\n\n4\n\n\n\n6\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n4\n\n\n\n7446\n\n\n\n1967\n\n\n\nMaster\n\n\n\nTogether\n\n\n\n62513.0\n\n\n\n0\n\n\n\n1\n\n\n\n520\n\n\n\n42\n\n\n\n98\n\n\n\n0\n\n\n\n42\n\n\n\n14\n\n\n\n6\n\n\n\n4\n\n\n\n10\n\n\n\n6\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n\n\n\n\n1749\n\n\n\n9432\n\n\n\n1977\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n666666.0\n\n\n\n1\n\n\n\n0\n\n\n\n9\n\n\n\n14\n\n\n\n18\n\n\n\n8\n\n\n\n1\n\n\n\n12\n\n\n\n3\n\n\n\n1\n\n\n\n3\n\n\n\n6\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1750\n\n\n\n8372\n\n\n\n1974\n\n\n\nGraduation\n\n\n\nMarried\n\n\n\n34421.0\n\n\n\n1\n\n\n\n0\n\n\n\n3\n\n\n\n3\n\n\n\n7\n\n\n\n6\n\n\n\n2\n\n\n\n9\n\n\n\n1\n\n\n\n0\n\n\n\n2\n\n\n\n7\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1751\n\n\n\n10870\n\n\n\n1967\n\n\n\nGraduation\n\n\n\nMarried\n\n\n\n61223.0\n\n\n\n0\n\n\n\n1\n\n\n\n709\n\n\n\n43\n\n\n\n182\n\n\n\n42\n\n\n\n118\n\n\n\n247\n\n\n\n9\n\n\n\n3\n\n\n\n4\n\n\n\n5\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1752\n\n\n\n7270\n\n\n\n1981\n\n\n\nGraduation\n\n\n\nDivorced\n\n\n\n56981.0\n\n\n\n0\n\n\n\n0\n\n\n\n908\n\n\n\n48\n\n\n\n217\n\n\n\n32\n\n\n\n12\n\n\n\n24\n\n\n\n2\n\n\n\n3\n\n\n\n13\n\n\n\n6\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1753\n\n\n\n8235\n\n\n\n1956\n\n\n\nMaster\n\n\n\nTogether\n\n\n\n69245.0\n\n\n\n0\n\n\n\n1\n\n\n\n428\n\n\n\n30\n\n\n\n214\n\n\n\n80\n\n\n\n30\n\n\n\n61\n\n\n\n6\n\n\n\n5\n\n\n\n10\n\n\n\n3\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n\n\n\n1754 rows × 20 columns\n\n’\n\n\n\n\n\n\nTip\n\n\n\nWhen you are unsure what arguments a function can take, it is possilbe to get a help documentation using help(pd.read_csv)"
  },
  {
    "objectID": "python-pandas.html#data-exploration",
    "href": "python-pandas.html#data-exploration",
    "title": "8  Introduction to Python and Pandas",
    "section": "8.6 Data exploration",
    "text": "8.6 Data exploration\nThe data is from a customer personality analysis of a company trying to better understand how to modify their product catalogue. Here is the link to the original source for more information.\n\n8.6.1 Columns\nThe command below prints all the column names.\ndf.columns\nIndex([‘ID’, ‘Year_Birth’, ‘Education’, ‘Marital_Status’, ‘Income’, ‘Kidhome’, ‘Teenhome’, ‘MntWines’, ‘MntFruits’, ‘MntMeatProducts’, ‘MntFishProducts’, ‘MntSweetProducts’, ‘MntGoldProds’, ‘NumWebPurchases’, ‘NumCatalogPurchases’, ‘NumStorePurchases’, ‘NumWebVisitsMonth’, ‘Complain’, ‘Z_CostContact’, ‘Z_Revenue’], dtype=‘object’)\nWe can also list their respective data types.\n\nint64 are integers\nfloat64 are floating point numbers, also called double in other languages\nobject are Python objects, which are strings in this case\n\ndf.dtypes\nID                       int64\nYear_Birth               int64\nEducation               object\nMarital_Status          object\nIncome                 float64\nKidhome                  int64\nTeenhome                 int64\nMntWines                 int64\nMntFruits                int64\nMntMeatProducts          int64\nMntFishProducts          int64\nMntSweetProducts         int64\nMntGoldProds             int64\nNumWebPurchases          int64\nNumCatalogPurchases      int64\nNumStorePurchases        int64\nNumWebVisitsMonth        int64\nComplain                 int64\nZ_CostContact            int64\nZ_Revenue                int64\ndtype: object\n\n\n8.6.2 Inspecting the DataFrame\nWhat is the size of our DataFrame\ndf.shape\n(1754, 20)\nIt has 1754 rows and 20 columns.\nLet’s look at the first 5 rows:\ndf.head()\n\n\n\n\n\n\n\n\n\n\n\nID\n\n\n\nYear_Birth\n\n\n\nEducation\n\n\n\nMarital_Status\n\n\n\nIncome\n\n\n\nKidhome\n\n\n\nTeenhome\n\n\n\nMntWines\n\n\n\nMntFruits\n\n\n\nMntMeatProducts\n\n\n\nMntFishProducts\n\n\n\nMntSweetProducts\n\n\n\nMntGoldProds\n\n\n\nNumWebPurchases\n\n\n\nNumCatalogPurchases\n\n\n\nNumStorePurchases\n\n\n\nNumWebVisitsMonth\n\n\n\nComplain\n\n\n\nZ_CostContact\n\n\n\nZ_Revenue\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n5524\n\n\n\n1957\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n58138.0\n\n\n\n0\n\n\n\n0\n\n\n\n635\n\n\n\n88\n\n\n\n546\n\n\n\n172\n\n\n\n88\n\n\n\n88\n\n\n\n8\n\n\n\n10\n\n\n\n4\n\n\n\n7\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1\n\n\n\n2174\n\n\n\n1954\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n46344.0\n\n\n\n1\n\n\n\n1\n\n\n\n11\n\n\n\n1\n\n\n\n6\n\n\n\n2\n\n\n\n1\n\n\n\n6\n\n\n\n1\n\n\n\n1\n\n\n\n2\n\n\n\n5\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n2\n\n\n\n4141\n\n\n\n1965\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n71613.0\n\n\n\n0\n\n\n\n0\n\n\n\n426\n\n\n\n49\n\n\n\n127\n\n\n\n111\n\n\n\n21\n\n\n\n42\n\n\n\n8\n\n\n\n2\n\n\n\n10\n\n\n\n4\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n3\n\n\n\n6182\n\n\n\n1984\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n26646.0\n\n\n\n1\n\n\n\n0\n\n\n\n11\n\n\n\n4\n\n\n\n20\n\n\n\n10\n\n\n\n3\n\n\n\n5\n\n\n\n2\n\n\n\n0\n\n\n\n4\n\n\n\n6\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n4\n\n\n\n7446\n\n\n\n1967\n\n\n\nMaster\n\n\n\nTogether\n\n\n\n62513.0\n\n\n\n0\n\n\n\n1\n\n\n\n520\n\n\n\n42\n\n\n\n98\n\n\n\n0\n\n\n\n42\n\n\n\n14\n\n\n\n6\n\n\n\n4\n\n\n\n10\n\n\n\n6\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n\nWhat we can see it that, unlike R, Python and in extension Pandas is 0-indexed instead of 1-indexed.\n\n\nQuestion: Can you show how to do the same using bash?\n\n! head all_data.tsv\n\n\n\n\n\n\n\n\n\n\n\nID\n\n\n\nYear_Birth\n\n\n\nEducation\n\n\n\nMarital_Status\n\n\n\nIncome\n\n\n\nKidhome\n\n\n\nTeenhome\n\n\n\nMntWines\n\n\n\nMntFruits\n\n\n\nMntMeatProducts\n\n\n\nMntFishProducts\n\n\n\nMntSweetProducts\n\n\n\nMntGoldProds\n\n\n\nNumWebPurchases\n\n\n\nNumCatalogPurchases\n\n\n\nNumStorePurchases\n\n\n\nNumWebVisitsMonth\n\n\n\nComplain\n\n\n\nZ_CostContact\n\n\n\nZ_Revenue\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n5524\n\n\n\n1957\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n58138.0\n\n\n\n0\n\n\n\n0\n\n\n\n635\n\n\n\n88\n\n\n\n546\n\n\n\n172\n\n\n\n88\n\n\n\n88\n\n\n\n8\n\n\n\n10\n\n\n\n4\n\n\n\n7\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1\n\n\n\n2174\n\n\n\n1954\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n46344.0\n\n\n\n1\n\n\n\n1\n\n\n\n11\n\n\n\n1\n\n\n\n6\n\n\n\n2\n\n\n\n1\n\n\n\n6\n\n\n\n1\n\n\n\n1\n\n\n\n2\n\n\n\n5\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n2\n\n\n\n4141\n\n\n\n1965\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n71613.0\n\n\n\n0\n\n\n\n0\n\n\n\n426\n\n\n\n49\n\n\n\n127\n\n\n\n111\n\n\n\n21\n\n\n\n42\n\n\n\n8\n\n\n\n2\n\n\n\n10\n\n\n\n4\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n3\n\n\n\n6182\n\n\n\n1984\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n26646.0\n\n\n\n1\n\n\n\n0\n\n\n\n11\n\n\n\n4\n\n\n\n20\n\n\n\n10\n\n\n\n3\n\n\n\n5\n\n\n\n2\n\n\n\n0\n\n\n\n4\n\n\n\n6\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n4\n\n\n\n7446\n\n\n\n1967\n\n\n\nMaster\n\n\n\nTogether\n\n\n\n62513.0\n\n\n\n0\n\n\n\n1\n\n\n\n520\n\n\n\n42\n\n\n\n98\n\n\n\n0\n\n\n\n42\n\n\n\n14\n\n\n\n6\n\n\n\n4\n\n\n\n10\n\n\n\n6\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n5\n\n\n\n965\n\n\n\n1971\n\n\n\nGraduation\n\n\n\nDivorced\n\n\n\n55635.0\n\n\n\n0\n\n\n\n1\n\n\n\n235\n\n\n\n65\n\n\n\n164\n\n\n\n50\n\n\n\n49\n\n\n\n27\n\n\n\n7\n\n\n\n3\n\n\n\n7\n\n\n\n6\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n6\n\n\n\n1994\n\n\n\n1983\n\n\n\nGraduation\n\n\n\nMarried\n\n\n\nNaN\n\n\n\n1\n\n\n\n0\n\n\n\n5\n\n\n\n5\n\n\n\n6\n\n\n\n0\n\n\n\n2\n\n\n\n1\n\n\n\n1\n\n\n\n0\n\n\n\n2\n\n\n\n7\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n7\n\n\n\n387\n\n\n\n1976\n\n\n\nBasic\n\n\n\nMarried\n\n\n\n7500.0\n\n\n\n0\n\n\n\n0\n\n\n\n6\n\n\n\n16\n\n\n\n11\n\n\n\n11\n\n\n\n1\n\n\n\n16\n\n\n\n2\n\n\n\n0\n\n\n\n3\n\n\n\n8\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n8\n\n\n\n2125\n\n\n\n1959\n\n\n\nGraduation\n\n\n\nDivorced\n\n\n\n63033.0\n\n\n\n0\n\n\n\n0\n\n\n\n194\n\n\n\n61\n\n\n\n480\n\n\n\n225\n\n\n\n112\n\n\n\n30\n\n\n\n3\n\n\n\n4\n\n\n\n8\n\n\n\n2\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n9\n\n\n\n8180\n\n\n\n1952\n\n\n\nMaster\n\n\n\nDivorced\n\n\n\n59354.0\n\n\n\n1\n\n\n\n1\n\n\n\n233\n\n\n\n2\n\n\n\n53\n\n\n\n3\n\n\n\n5\n\n\n\n14\n\n\n\n6\n\n\n\n1\n\n\n\n5\n\n\n\n6\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n\n\n\n\n8.6.3 Accessing rows and columns\nWe can access parts of the data in DataFrames in different ways.\nThe first method is subsetting the rows using the index.\nThis will take only the second row and all columns, producing a Series:\ndf.loc[1, :]\nID                           2174\nYear_Birth                   1954\nEducation              Graduation\nMarital_Status             Single\nIncome                    46344.0\nKidhome                         1\nTeenhome                        1\nMntWines                       11\nMntFruits                       1\nMntMeatProducts                 6\nMntFishProducts                 2\nMntSweetProducts                1\nMntGoldProds                    6\nNumWebPurchases                 1\nNumCatalogPurchases             1\nNumStorePurchases               2\nNumWebVisitsMonth               5\nComplain                        0\nZ_CostContact                   3\nZ_Revenue                      11\nName: 1, dtype: object\nAnd this will take the second and third row, producing another DataFrame:\ndf.loc[1:2, :]\n’\n\n\n\n\n\n\n\n\n\n\n\nID\n\n\n\nYear_Birth\n\n\n\nEducation\n\n\n\nMarital_Status\n\n\n\nIncome\n\n\n\nKidhome\n\n\n\nTeenhome\n\n\n\nMntWines\n\n\n\nMntFruits\n\n\n\nMntMeatProducts\n\n\n\nMntFishProducts\n\n\n\nMntSweetProducts\n\n\n\nMntGoldProds\n\n\n\nNumWebPurchases\n\n\n\nNumCatalogPurchases\n\n\n\nNumStorePurchases\n\n\n\nNumWebVisitsMonth\n\n\n\nComplain\n\n\n\nZ_CostContact\n\n\n\nZ_Revenue\n\n\n\n\n\n\n\n\n\n\n\n1\n\n\n\n2174\n\n\n\n1954\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n46344.0\n\n\n\n1\n\n\n\n1\n\n\n\n11\n\n\n\n1\n\n\n\n6\n\n\n\n2\n\n\n\n1\n\n\n\n6\n\n\n\n1\n\n\n\n1\n\n\n\n2\n\n\n\n5\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n2\n\n\n\n4141\n\n\n\n1965\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n71613.0\n\n\n\n0\n\n\n\n0\n\n\n\n426\n\n\n\n49\n\n\n\n127\n\n\n\n111\n\n\n\n21\n\n\n\n42\n\n\n\n8\n\n\n\n2\n\n\n\n10\n\n\n\n4\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n\n’\nIt’s important to understand that almost all operations on DataFrames are not in-place, meaning that we don’t modify the original object and would have to save the results to the same or a new variable to keep the changes.\nThis, for example will create a new DataFrame of only the “Education” and “Marital_Status” columns.\nnew_df = df.loc[:, [\"Education\", \"Marital_Status\"]]\nnew_df\n’\n\n\n\n\n\n\n\n\n\n\n\nEducation\n\n\n\nMarital_Status\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n\n\n\n\n1\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n\n\n\n\n2\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n\n\n\n\n3\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n\n\n\n\n4\n\n\n\nMaster\n\n\n\nTogether\n\n\n\n\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n\n\n\n\n1749\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n\n\n\n\n1750\n\n\n\nGraduation\n\n\n\nMarried\n\n\n\n\n\n\n\n1751\n\n\n\nGraduation\n\n\n\nMarried\n\n\n\n\n\n\n\n1752\n\n\n\nGraduation\n\n\n\nDivorced\n\n\n\n\n\n\n\n1753\n\n\n\nMaster\n\n\n\nTogether\n\n\n\n\n\n\n\n\n\n\n1754 rows × 2 columns\n\n’\nSelecting only one column by name:\ndf[\"Year_Birth\"]\n0       1957\n1       1954\n2       1965\n3       1984\n4       1967\n        ... \n1749    1977\n1750    1974\n1751    1967\n1752    1981\n1753    1956\nWe can also remove columns from the DataFrame.\nIn this case, we want to remove the columns “Z_CostContact” and “Z_Revenue” and keep those changes.\ndf = df.drop(\"Z_CostContact\", axis=1)\ndf = df.drop(\"Z_Revenue\", axis=1)\n\n\n8.6.4 Conditional subsetting\nWe can more specifically look at subsets of the data we might be interested in.\nThis subsetting is a bit weird in the syntax at first but hopefully makes more sense when we go through it step by step.\nWe can, for example, test each string in the column “Education” if it is equal to “PhD”:\neducation_is_grad = (df[\"Education\"] == \"Graduation\")\neducation_is_grad\n0        True\n1        True\n2        True\n3        True\n4       False\n        ...  \n1749     True\n1750     True\n1751     True\n1752     True\n1753    False\nName: Education, Length: 1754, dtype: bool\nWe can also check for multiple conditions at once:\ntwo_at_once = (df[\"Education\"] == \"Graduation\") & (df[\"Marital_Status\"] == \"Single\")\ntwo_at_once\n0        True\n1        True\n2       False\n3       False\n4       False\n        ...  \n1749    False\n1750    False\n1751    False\n1752    False\n1753    False\nLength: 1754, dtype: bool\nThis will create a Series of booleans, which can then be used to subset the data to rows where the condition(s) are True:\ndf[two_at_once]\n’\n\n\n\n\n\n\n\n\n\n\n\nID\n\n\n\nYear_Birth\n\n\n\nEducation\n\n\n\nMarital_Status\n\n\n\nIncome\n\n\n\nKidhome\n\n\n\nTeenhome\n\n\n\nMntWines\n\n\n\nMntFruits\n\n\n\nMntMeatProducts\n\n\n\nMntFishProducts\n\n\n\nMntSweetProducts\n\n\n\nMntGoldProds\n\n\n\nNumWebPurchases\n\n\n\nNumCatalogPurchases\n\n\n\nNumStorePurchases\n\n\n\nNumWebVisitsMonth\n\n\n\nComplain\n\n\n\nZ_CostContact\n\n\n\nZ_Revenue\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n5524\n\n\n\n1957\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n58138.0\n\n\n\n0\n\n\n\n0\n\n\n\n635\n\n\n\n88\n\n\n\n546\n\n\n\n172\n\n\n\n88\n\n\n\n88\n\n\n\n8\n\n\n\n10\n\n\n\n4\n\n\n\n7\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1\n\n\n\n2174\n\n\n\n1954\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n46344.0\n\n\n\n1\n\n\n\n1\n\n\n\n11\n\n\n\n1\n\n\n\n6\n\n\n\n2\n\n\n\n1\n\n\n\n6\n\n\n\n1\n\n\n\n1\n\n\n\n2\n\n\n\n5\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n18\n\n\n\n7892\n\n\n\n1969\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n18589.0\n\n\n\n0\n\n\n\n0\n\n\n\n6\n\n\n\n4\n\n\n\n25\n\n\n\n15\n\n\n\n12\n\n\n\n13\n\n\n\n2\n\n\n\n1\n\n\n\n3\n\n\n\n7\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n20\n\n\n\n5255\n\n\n\n1986\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\nNaN\n\n\n\n1\n\n\n\n0\n\n\n\n5\n\n\n\n1\n\n\n\n3\n\n\n\n3\n\n\n\n263\n\n\n\n362\n\n\n\n27\n\n\n\n0\n\n\n\n0\n\n\n\n1\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n33\n\n\n\n1371\n\n\n\n1976\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n79941.0\n\n\n\n0\n\n\n\n0\n\n\n\n123\n\n\n\n164\n\n\n\n266\n\n\n\n227\n\n\n\n30\n\n\n\n174\n\n\n\n2\n\n\n\n4\n\n\n\n9\n\n\n\n1\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n\n\n\n\n1720\n\n\n\n10968\n\n\n\n1969\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n57731.0\n\n\n\n0\n\n\n\n1\n\n\n\n266\n\n\n\n21\n\n\n\n300\n\n\n\n65\n\n\n\n8\n\n\n\n44\n\n\n\n8\n\n\n\n8\n\n\n\n6\n\n\n\n6\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1723\n\n\n\n5959\n\n\n\n1968\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n35893.0\n\n\n\n1\n\n\n\n1\n\n\n\n158\n\n\n\n0\n\n\n\n23\n\n\n\n0\n\n\n\n0\n\n\n\n18\n\n\n\n3\n\n\n\n1\n\n\n\n5\n\n\n\n8\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1743\n\n\n\n4201\n\n\n\n1962\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n57967.0\n\n\n\n0\n\n\n\n1\n\n\n\n229\n\n\n\n7\n\n\n\n137\n\n\n\n4\n\n\n\n0\n\n\n\n91\n\n\n\n4\n\n\n\n2\n\n\n\n8\n\n\n\n5\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1746\n\n\n\n7004\n\n\n\n1984\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n11012.0\n\n\n\n1\n\n\n\n0\n\n\n\n24\n\n\n\n3\n\n\n\n26\n\n\n\n7\n\n\n\n1\n\n\n\n23\n\n\n\n3\n\n\n\n1\n\n\n\n2\n\n\n\n9\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1748\n\n\n\n8080\n\n\n\n1986\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n26816.0\n\n\n\n0\n\n\n\n0\n\n\n\n5\n\n\n\n1\n\n\n\n6\n\n\n\n3\n\n\n\n4\n\n\n\n3\n\n\n\n0\n\n\n\n0\n\n\n\n3\n\n\n\n4\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n\n\n\n252 rows × 20 columns\n\n’\nThe syntax that seems more complicated and does it in one step without the extra Series is this:\ndf[(df[\"Education\"] == \"Master\") & (df[\"Marital_Status\"] == \"Single\")]\n\n\n\n\n\n\n\n\n\n\n\nID\n\n\n\nYear_Birth\n\n\n\nEducation\n\n\n\nMarital_Status\n\n\n\nIncome\n\n\n\nKidhome\n\n\n\nTeenhome\n\n\n\nMntWines\n\n\n\nMntFruits\n\n\n\nMntMeatProducts\n\n\n\nMntFishProducts\n\n\n\nMntSweetProducts\n\n\n\nMntGoldProds\n\n\n\nNumWebPurchases\n\n\n\nNumCatalogPurchases\n\n\n\nNumStorePurchases\n\n\n\nNumWebVisitsMonth\n\n\n\nComplain\n\n\n\nZ_CostContact\n\n\n\nZ_Revenue\n\n\n\n\n\n\n\n\n\n\n\n26\n\n\n\n10738\n\n\n\n1951\n\n\n\nMaster\n\n\n\nSingle\n\n\n\n49389.0\n\n\n\n1\n\n\n\n1\n\n\n\n40\n\n\n\n0\n\n\n\n19\n\n\n\n2\n\n\n\n1\n\n\n\n3\n\n\n\n2\n\n\n\n0\n\n\n\n3\n\n\n\n7\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n46\n\n\n\n6853\n\n\n\n1982\n\n\n\nMaster\n\n\n\nSingle\n\n\n\n75777.0\n\n\n\n0\n\n\n\n0\n\n\n\n712\n\n\n\n26\n\n\n\n538\n\n\n\n69\n\n\n\n13\n\n\n\n80\n\n\n\n3\n\n\n\n6\n\n\n\n11\n\n\n\n1\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n76\n\n\n\n11178\n\n\n\n1972\n\n\n\nMaster\n\n\n\nSingle\n\n\n\n42394.0\n\n\n\n1\n\n\n\n0\n\n\n\n15\n\n\n\n2\n\n\n\n10\n\n\n\n0\n\n\n\n1\n\n\n\n4\n\n\n\n1\n\n\n\n0\n\n\n\n3\n\n\n\n7\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n98\n\n\n\n6205\n\n\n\n1967\n\n\n\nMaster\n\n\n\nSingle\n\n\n\n32557.0\n\n\n\n1\n\n\n\n0\n\n\n\n34\n\n\n\n3\n\n\n\n29\n\n\n\n0\n\n\n\n4\n\n\n\n10\n\n\n\n2\n\n\n\n1\n\n\n\n3\n\n\n\n5\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n110\n\n\n\n821\n\n\n\n1992\n\n\n\nMaster\n\n\n\nSingle\n\n\n\n92859.0\n\n\n\n0\n\n\n\n0\n\n\n\n962\n\n\n\n61\n\n\n\n921\n\n\n\n52\n\n\n\n61\n\n\n\n20\n\n\n\n5\n\n\n\n4\n\n\n\n12\n\n\n\n2\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n\n\n\n\n1690\n\n\n\n3520\n\n\n\n1990\n\n\n\nMaster\n\n\n\nSingle\n\n\n\n91172.0\n\n\n\n0\n\n\n\n0\n\n\n\n162\n\n\n\n28\n\n\n\n818\n\n\n\n0\n\n\n\n28\n\n\n\n56\n\n\n\n4\n\n\n\n3\n\n\n\n7\n\n\n\n3\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1709\n\n\n\n4418\n\n\n\n1983\n\n\n\nMaster\n\n\n\nSingle\n\n\n\n89616.0\n\n\n\n0\n\n\n\n0\n\n\n\n671\n\n\n\n47\n\n\n\n655\n\n\n\n145\n\n\n\n111\n\n\n\n15\n\n\n\n7\n\n\n\n5\n\n\n\n12\n\n\n\n2\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1714\n\n\n\n2980\n\n\n\n1952\n\n\n\nMaster\n\n\n\nSingle\n\n\n\n8820.0\n\n\n\n1\n\n\n\n1\n\n\n\n12\n\n\n\n0\n\n\n\n13\n\n\n\n4\n\n\n\n2\n\n\n\n4\n\n\n\n3\n\n\n\n0\n\n\n\n3\n\n\n\n8\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1738\n\n\n\n7366\n\n\n\n1982\n\n\n\nMaster\n\n\n\nSingle\n\n\n\n75777.0\n\n\n\n0\n\n\n\n0\n\n\n\n712\n\n\n\n26\n\n\n\n538\n\n\n\n69\n\n\n\n13\n\n\n\n80\n\n\n\n3\n\n\n\n6\n\n\n\n11\n\n\n\n1\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1747\n\n\n\n9817\n\n\n\n1970\n\n\n\nMaster\n\n\n\nSingle\n\n\n\n44802.0\n\n\n\n0\n\n\n\n0\n\n\n\n853\n\n\n\n10\n\n\n\n143\n\n\n\n13\n\n\n\n10\n\n\n\n20\n\n\n\n9\n\n\n\n4\n\n\n\n12\n\n\n\n8\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n\n\n\n75 rows × 20 columns"
  },
  {
    "objectID": "python-pandas.html#describing-a-dataframe",
    "href": "python-pandas.html#describing-a-dataframe",
    "title": "8  Introduction to Python and Pandas",
    "section": "8.7 Describing a DataFrame",
    "text": "8.7 Describing a DataFrame\nPandas can easily create overview statistics for all numeric columns:\ndf.describe()\n\n\n\n\n\n\n\n\n\n\n\nID\n\n\n\nYear_Birth\n\n\n\nIncome\n\n\n\nKidhome\n\n\n\nTeenhome\n\n\n\nMntWines\n\n\n\nMntFruits\n\n\n\nMntMeatProducts\n\n\n\nMntFishProducts\n\n\n\nMntSweetProducts\n\n\n\nMntGoldProds\n\n\n\nNumWebPurchases\n\n\n\nNumCatalogPurchases\n\n\n\nNumStorePurchases\n\n\n\nNumWebVisitsMonth\n\n\n\nComplain\n\n\n\nZ_CostContact\n\n\n\nZ_Revenue\n\n\n\n\n\n\n\n\n\n\n\ncount\n\n\n\n1754.000000\n\n\n\n1754.000000\n\n\n\n1735.000000\n\n\n\n1754.000000\n\n\n\n1754.000000\n\n\n\n1754.000000\n\n\n\n1754.000000\n\n\n\n1754.000000\n\n\n\n1754.000000\n\n\n\n1754.000000\n\n\n\n1754.000000\n\n\n\n1754.000000\n\n\n\n1754.000000\n\n\n\n1754.000000\n\n\n\n1754.000000\n\n\n\n1754.000000\n\n\n\n1754.0\n\n\n\n1754.0\n\n\n\n\n\n\n\nmean\n\n\n\n5584.696123\n\n\n\n1969.571266\n\n\n\n51166.578098\n\n\n\n0.456100\n\n\n\n0.480616\n\n\n\n276.072406\n\n\n\n28.034778\n\n\n\n166.492018\n\n\n\n40.517104\n\n\n\n28.958381\n\n\n\n47.266819\n\n\n\n3.990878\n\n\n\n2.576967\n\n\n\n5.714937\n\n\n\n5.332383\n\n\n\n0.011403\n\n\n\n3.0\n\n\n\n11.0\n\n\n\n\n\n\n\nstd\n\n\n\n3254.655979\n\n\n\n11.876614\n\n\n\n26200.419179\n\n\n\n0.537854\n\n\n\n0.536112\n\n\n\n314.604735\n\n\n\n41.348883\n\n\n\n225.561694\n\n\n\n57.412986\n\n\n\n42.830660\n\n\n\n53.885647\n\n\n\n2.708278\n\n\n\n2.848335\n\n\n\n3.231465\n\n\n\n2.380183\n\n\n\n0.106202\n\n\n\n0.0\n\n\n\n0.0\n\n\n\n\n\n\n\nmin\n\n\n\n0.000000\n\n\n\n1893.000000\n\n\n\n1730.000000\n\n\n\n0.000000\n\n\n\n0.000000\n\n\n\n0.000000\n\n\n\n0.000000\n\n\n\n0.000000\n\n\n\n0.000000\n\n\n\n0.000000\n\n\n\n0.000000\n\n\n\n0.000000\n\n\n\n0.000000\n\n\n\n0.000000\n\n\n\n0.000000\n\n\n\n0.000000\n\n\n\n3.0\n\n\n\n11.0\n\n\n\n\n\n\n\n25%\n\n\n\n2802.500000\n\n\n\n1960.000000\n\n\n\n33574.500000\n\n\n\n0.000000\n\n\n\n0.000000\n\n\n\n19.000000\n\n\n\n2.000000\n\n\n\n15.000000\n\n\n\n3.000000\n\n\n\n2.000000\n\n\n\n10.000000\n\n\n\n2.000000\n\n\n\n0.000000\n\n\n\n3.000000\n\n\n\n3.000000\n\n\n\n0.000000\n\n\n\n3.0\n\n\n\n11.0\n\n\n\n\n\n\n\n50%\n\n\n\n5468.000000\n\n\n\n1971.000000\n\n\n\n49912.000000\n\n\n\n0.000000\n\n\n\n0.000000\n\n\n\n160.500000\n\n\n\n9.000000\n\n\n\n66.000000\n\n\n\n13.000000\n\n\n\n9.000000\n\n\n\n27.000000\n\n\n\n3.000000\n\n\n\n1.000000\n\n\n\n5.000000\n\n\n\n6.000000\n\n\n\n0.000000\n\n\n\n3.0\n\n\n\n11.0\n\n\n\n\n\n\n\n75%\n\n\n\n8441.250000\n\n\n\n1978.000000\n\n\n\n68130.000000\n\n\n\n1.000000\n\n\n\n1.000000\n\n\n\n454.000000\n\n\n\n35.000000\n\n\n\n232.000000\n\n\n\n53.500000\n\n\n\n35.000000\n\n\n\n63.000000\n\n\n\n6.000000\n\n\n\n4.000000\n\n\n\n8.000000\n\n\n\n7.000000\n\n\n\n0.000000\n\n\n\n3.0\n\n\n\n11.0\n\n\n\n\n\n\n\nmax\n\n\n\n11191.000000\n\n\n\n1996.000000\n\n\n\n666666.000000\n\n\n\n2.000000\n\n\n\n2.000000\n\n\n\n1492.000000\n\n\n\n199.000000\n\n\n\n1725.000000\n\n\n\n259.000000\n\n\n\n263.000000\n\n\n\n362.000000\n\n\n\n27.000000\n\n\n\n28.000000\n\n\n\n13.000000\n\n\n\n20.000000\n\n\n\n1.000000\n\n\n\n3.0\n\n\n\n11.0\n\n\n\n\n\n\n\n\n\n\n8 rows × 18 columns\n\nYou can also directly calculate the relevant statistics on columns you are interested in:\ndf[\"MntWines\"].max()\n1492\ndf[[\"Kidhome\", \"Teenhome\"]].mean()\nKidhome     0.456100\nTeenhome    0.480616\ndtype: float64\nFor non-numeric columns, you can get the represented values or their counts:\ndf[\"Education\"].unique()\narray([‘Graduation’, ‘Master’, ‘Basic’, ‘2n Cycle’], dtype=object)\ndf[\"Marital_Status\"].value_counts()\nMarital_Status\nMarried     672\nTogether    463\nSingle      382\nDivorced    180\nWidow        53\nAlone         2\nAbsurd        2\nName: count, dtype: int64\nTask\nSubset the DataFrame in two different ways:\n\n\n\n\n\n\nTip\n\n\n\nJust like with the “PhD” string before, you can subset using integers and \\(&lt;\\), \\(&gt;\\), \\(&lt;=\\) and \\(&gt;=\\).\n\n\n\nOne where everybody is born before 1970\n\n\nSolution\n\ndf_before = df[df[\"Year_Birth\"] &lt; 1970]\n\nOne where everybody is born in or after 1970\n\n\nSolution\n\ndf_before = df[df[\"Year_Birth\"] &gt;= 1970]\n\nHow many people are in the two DataFrames?\n\n\nSolution\n\nprint(\"n(before)   =\", df_before.shape[0])\nprint(\"n(after)   =\", df_before.shape[0])\nn(before)   = 804\nn(after)   = 950\n\nDo the total number of people sum up to the original DataFrame total?\n\n\nSolution\n\n df_before.shape[0] + df_after.shape[0] == df.shape[0]\nTrue\nprint(\"n(sum)      =\", df_before.shape[0] + df_after.shape[0])\nprint(\"n(expected) =\", df.shape[0])\nn(sum)      = 1754\nn(expected) = 1754\n\n\n\nHow does the mean income of the two groups differ?\n\n\nSolution\n\nprint(\"income(before) =\", df_before[\"Income\"].mean())\nprint(\"income(after)  =\", df_after[\"Income\"].mean())\nincome(before) = 55513.38113207547 income(after) = 47490.29255319149\n\n\nExtra task - Can you find something else that differs a lot between the two groups?"
  },
  {
    "objectID": "python-pandas.html#dealing-with-missing-data",
    "href": "python-pandas.html#dealing-with-missing-data",
    "title": "8  Introduction to Python and Pandas",
    "section": "8.8 Dealing with missing data",
    "text": "8.8 Dealing with missing data\nWe can check for missing data for each cell like this:\ndf.isna()\n\n\n\n\n\n\n\n\n\n\n\nID\n\n\n\nYear_Birth\n\n\n\nEducation\n\n\n\nMarital_Status\n\n\n\nIncome\n\n\n\nKidhome\n\n\n\nTeenhome\n\n\n\nMntWines\n\n\n\nMntFruits\n\n\n\nMntMeatProducts\n\n\n\nMntFishProducts\n\n\n\nMntSweetProducts\n\n\n\nMntGoldProds\n\n\n\nNumWebPurchases\n\n\n\nNumCatalogPurchases\n\n\n\nNumStorePurchases\n\n\n\nNumWebVisitsMonth\n\n\n\nComplain\n\n\n\nZ_CostContact\n\n\n\nZ_Revenue\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\n\n\n\n\n1\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\n\n\n\n\n2\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\n\n\n\n\n3\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\n\n\n\n\n4\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\n\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n\n\n\n\n1749\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\n\n\n\n\n1750\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\n\n\n\n\n1751\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\n\n\n\n\n1752\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\n\n\n\n\n1753\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\nFalse\n\n\n\n\n\n\n\n\n\n\n1754 rows × 20 columns\n\nBy summing over each row, we see how many missing values are in each column.\nTrue is treated as 1 and False as 0.\ndf.isna().sum()\nID                      0\nYear_Birth              0\nEducation               0\nMarital_Status          0\nIncome                 19\nKidhome                 0\nTeenhome                0\nMntWines                0\nMntFruits               0\nMntMeatProducts         0\nMntFishProducts         0\nMntSweetProducts        0\nMntGoldProds            0\nNumWebPurchases         0\nNumCatalogPurchases     0\nNumStorePurchases       0\nNumWebVisitsMonth       0\nComplain                0\ndtype: int64\nWe don’t really know what a missing value means so we are just going to keep them in the data.\nHowever, we could remove them using df.dropna()\n\n8.8.1 Grouping data\nWe can group a DataFrame using a categorical column (for example “Education” or “Marital_Status”).\nThis allows us to do perform operations on each group individually.\nFor example, we could group by “Education” and calculate the mean “Income”:\ndf.groupby(by=\"Education\")[\"Income\"].mean()\nEducation\n2n Cycle      47633.190000\nBasic         20306.259259\nGraduation    52720.373656\nMaster        52917.534247\nName: Income, dtype: float6"
  },
  {
    "objectID": "python-pandas.html#combining-data",
    "href": "python-pandas.html#combining-data",
    "title": "8  Introduction to Python and Pandas",
    "section": "8.9 Combining data",
    "text": "8.9 Combining data\n\n8.9.0.1 Concatenation\nOne way to combine multiple datasets is through concatenation, which either combines all columns or rows of multiple DataFrames.\nThe command to combine two DataFrames by appending all rows is pd.concat([first_dataframe, second_dataframe])\nTask\n\nRead the tsv “phd_data.tsv” as a new DataFrame and name the variable df2\n\n\nSolution\n\ndf2 = pd.read_csv(\"phd_data.tsv\", sep=\"\\t\")\n\nConcatenate the “old” DataFrame df and the new df2 and name the concatenated one concat_df\n\n\nSolution\n\nconcat_df = pd.concat([df, df2])\nconcat_df\n\n\n\n\n\n\n\n\n\n\n\nID\n\n\n\nYear_Birth\n\n\n\nEducation\n\n\n\nMarital_Status\n\n\n\nIncome\n\n\n\nKidhome\n\n\n\nTeenhome\n\n\n\nMntWines\n\n\n\nMntFruits\n\n\n\nMntMeatProducts\n\n\n\nMntFishProducts\n\n\n\nMntSweetProducts\n\n\n\nMntGoldProds\n\n\n\nNumWebPurchases\n\n\n\nNumCatalogPurchases\n\n\n\nNumStorePurchases\n\n\n\nNumWebVisitsMonth\n\n\n\nComplain\n\n\n\nZ_CostContact\n\n\n\nZ_Revenue\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n5524\n\n\n\n1957\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n58138.0\n\n\n\n0\n\n\n\n0\n\n\n\n635\n\n\n\n88\n\n\n\n546\n\n\n\n172\n\n\n\n88\n\n\n\n88\n\n\n\n8\n\n\n\n10\n\n\n\n4\n\n\n\n7\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n1\n\n\n\n2174\n\n\n\n1954\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n46344.0\n\n\n\n1\n\n\n\n1\n\n\n\n11\n\n\n\n1\n\n\n\n6\n\n\n\n2\n\n\n\n1\n\n\n\n6\n\n\n\n1\n\n\n\n1\n\n\n\n2\n\n\n\n5\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n2\n\n\n\n4141\n\n\n\n1965\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n71613.0\n\n\n\n0\n\n\n\n0\n\n\n\n426\n\n\n\n49\n\n\n\n127\n\n\n\n111\n\n\n\n21\n\n\n\n42\n\n\n\n8\n\n\n\n2\n\n\n\n10\n\n\n\n4\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n3\n\n\n\n6182\n\n\n\n1984\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n26646.0\n\n\n\n1\n\n\n\n0\n\n\n\n11\n\n\n\n4\n\n\n\n20\n\n\n\n10\n\n\n\n3\n\n\n\n5\n\n\n\n2\n\n\n\n0\n\n\n\n4\n\n\n\n6\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n4\n\n\n\n7446\n\n\n\n1967\n\n\n\nMaster\n\n\n\nTogether\n\n\n\n62513.0\n\n\n\n0\n\n\n\n1\n\n\n\n520\n\n\n\n42\n\n\n\n98\n\n\n\n0\n\n\n\n42\n\n\n\n14\n\n\n\n6\n\n\n\n4\n\n\n\n10\n\n\n\n6\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n\n\n\n\n481\n\n\n\n11133\n\n\n\n1973\n\n\n\nPhD\n\n\n\nYOLO\n\n\n\n48432.0\n\n\n\n0\n\n\n\n1\n\n\n\n322\n\n\n\n3\n\n\n\n50\n\n\n\n4\n\n\n\n3\n\n\n\n42\n\n\n\n7\n\n\n\n1\n\n\n\n6\n\n\n\n8\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n482\n\n\n\n9589\n\n\n\n1948\n\n\n\nPhD\n\n\n\nWidow\n\n\n\n82032.0\n\n\n\n0\n\n\n\n0\n\n\n\n332\n\n\n\n194\n\n\n\n377\n\n\n\n149\n\n\n\n125\n\n\n\n57\n\n\n\n4\n\n\n\n6\n\n\n\n7\n\n\n\n1\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n483\n\n\n\n4286\n\n\n\n1970\n\n\n\nPhD\n\n\n\nSingle\n\n\n\n57642.0\n\n\n\n0\n\n\n\n1\n\n\n\n580\n\n\n\n6\n\n\n\n58\n\n\n\n8\n\n\n\n0\n\n\n\n27\n\n\n\n7\n\n\n\n6\n\n\n\n6\n\n\n\n4\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n484\n\n\n\n4001\n\n\n\n1946\n\n\n\nPhD\n\n\n\nTogether\n\n\n\n64014.0\n\n\n\n2\n\n\n\n1\n\n\n\n406\n\n\n\n0\n\n\n\n30\n\n\n\n0\n\n\n\n0\n\n\n\n8\n\n\n\n8\n\n\n\n2\n\n\n\n5\n\n\n\n7\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n485\n\n\n\n9405\n\n\n\n1954\n\n\n\nPhD\n\n\n\nMarried\n\n\n\n52869.0\n\n\n\n1\n\n\n\n1\n\n\n\n84\n\n\n\n3\n\n\n\n61\n\n\n\n2\n\n\n\n1\n\n\n\n21\n\n\n\n3\n\n\n\n1\n\n\n\n4\n\n\n\n7\n\n\n\n0\n\n\n\n3\n\n\n\n11\n\n\n\n\n\n\n\n\n\n\n2240 rows × 20 columns\n\n\n\n\nIs there anything weird about the new DataFrame and can you fix that?\n\n\nSolution\n\nWe previously removed the columns “Z_CostContact” and “Z_Revenue” but they are in the new data again.\nWe can remove them like before:\nconcat_df = concat_df.drop(\"Z_CostContact\", axis=1)\nconcat_df = concat_df.drop(\"Z_Revenue\", axis=1)\nconcat_df\n\n\n\n\n\n\n\n\n\n\n\nID\n\n\n\nYear_Birth\n\n\n\nEducation\n\n\n\nMarital_Status\n\n\n\nIncome\n\n\n\nKidhome\n\n\n\nTeenhome\n\n\n\nMntWines\n\n\n\nMntFruits\n\n\n\nMntMeatProducts\n\n\n\nMntFishProducts\n\n\n\nMntSweetProducts\n\n\n\nMntGoldProds\n\n\n\nNumWebPurchases\n\n\n\nNumCatalogPurchases\n\n\n\nNumStorePurchases\n\n\n\nNumWebVisitsMonth\n\n\n\nComplain\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n5524\n\n\n\n1957\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n58138.0\n\n\n\n0\n\n\n\n0\n\n\n\n635\n\n\n\n88\n\n\n\n546\n\n\n\n172\n\n\n\n88\n\n\n\n88\n\n\n\n8\n\n\n\n10\n\n\n\n4\n\n\n\n7\n\n\n\n0\n\n\n\n\n\n\n\n1\n\n\n\n2174\n\n\n\n1954\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n46344.0\n\n\n\n1\n\n\n\n1\n\n\n\n11\n\n\n\n1\n\n\n\n6\n\n\n\n2\n\n\n\n1\n\n\n\n6\n\n\n\n1\n\n\n\n1\n\n\n\n2\n\n\n\n5\n\n\n\n0\n\n\n\n\n\n\n\n2\n\n\n\n4141\n\n\n\n1965\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n71613.0\n\n\n\n0\n\n\n\n0\n\n\n\n426\n\n\n\n49\n\n\n\n127\n\n\n\n111\n\n\n\n21\n\n\n\n42\n\n\n\n8\n\n\n\n2\n\n\n\n10\n\n\n\n4\n\n\n\n0\n\n\n\n\n\n\n\n3\n\n\n\n6182\n\n\n\n1984\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n26646.0\n\n\n\n1\n\n\n\n0\n\n\n\n11\n\n\n\n4\n\n\n\n20\n\n\n\n10\n\n\n\n3\n\n\n\n5\n\n\n\n2\n\n\n\n0\n\n\n\n4\n\n\n\n6\n\n\n\n0\n\n\n\n\n\n\n\n4\n\n\n\n7446\n\n\n\n1967\n\n\n\nMaster\n\n\n\nTogether\n\n\n\n62513.0\n\n\n\n0\n\n\n\n1\n\n\n\n520\n\n\n\n42\n\n\n\n98\n\n\n\n0\n\n\n\n42\n\n\n\n14\n\n\n\n6\n\n\n\n4\n\n\n\n10\n\n\n\n6\n\n\n\n0\n\n\n\n\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n\n\n\n\n481\n\n\n\n11133\n\n\n\n1973\n\n\n\nPhD\n\n\n\nYOLO\n\n\n\n48432.0\n\n\n\n0\n\n\n\n1\n\n\n\n322\n\n\n\n3\n\n\n\n50\n\n\n\n4\n\n\n\n3\n\n\n\n42\n\n\n\n7\n\n\n\n1\n\n\n\n6\n\n\n\n8\n\n\n\n0\n\n\n\n\n\n\n\n482\n\n\n\n9589\n\n\n\n1948\n\n\n\nPhD\n\n\n\nWidow\n\n\n\n82032.0\n\n\n\n0\n\n\n\n0\n\n\n\n332\n\n\n\n194\n\n\n\n377\n\n\n\n149\n\n\n\n125\n\n\n\n57\n\n\n\n4\n\n\n\n6\n\n\n\n7\n\n\n\n1\n\n\n\n0\n\n\n\n\n\n\n\n483\n\n\n\n4286\n\n\n\n1970\n\n\n\nPhD\n\n\n\nSingle\n\n\n\n57642.0\n\n\n\n0\n\n\n\n1\n\n\n\n580\n\n\n\n6\n\n\n\n58\n\n\n\n8\n\n\n\n0\n\n\n\n27\n\n\n\n7\n\n\n\n6\n\n\n\n6\n\n\n\n4\n\n\n\n0\n\n\n\n\n\n\n\n484\n\n\n\n4001\n\n\n\n1946\n\n\n\nPhD\n\n\n\nTogether\n\n\n\n64014.0\n\n\n\n2\n\n\n\n1\n\n\n\n406\n\n\n\n0\n\n\n\n30\n\n\n\n0\n\n\n\n0\n\n\n\n8\n\n\n\n8\n\n\n\n2\n\n\n\n5\n\n\n\n7\n\n\n\n0\n\n\n\n\n\n\n\n485\n\n\n\n9405\n\n\n\n1954\n\n\n\nPhD\n\n\n\nMarried\n\n\n\n52869.0\n\n\n\n1\n\n\n\n1\n\n\n\n84\n\n\n\n3\n\n\n\n61\n\n\n\n2\n\n\n\n1\n\n\n\n21\n\n\n\n3\n\n\n\n1\n\n\n\n4\n\n\n\n7\n\n\n\n0\n\n\n\n\n\n\n\n\n\n\n2240 rows × 18 columns\n\n\nIs there something interesting about the marital status of some people that have a PhD?\n\n\nSolution\n\nconcat_df[concat_df[\"Education\"]==\"PhD\"][\"Marital_Status\"].value_counts()\nMarital_Status\nMarried     192\nTogether    117\nSingle       98\nDivorced     52\nWidow        24\nYOLO          2\nAlone         1\nName: count, dtype: int64\nThere’s two people that have “YOLO” as their Marital Status …\n\n\n\n\n8.9.1 Merging\nAnalyzing numbers can be easier than analyzing categorial values, like “PhD” and “Master”.\nTo make our like easier, we might want to have a new column when the Education level is replaced with a number that “ranks” the Education levels by how long it takes.\nThis information could be stored in a Python Dictionary (Also called Hash Map in other languages), which stores key and value pairs.\nWe could store the Education information like this:\neducation_dictionary = {\n    \"Basic\": 1,\n    \"2n Cycle\": 2,\n    \"Graduation\": 3,\n    \"Master\": 4,\n    \"PhD\": 5\n}\nWe can now convert this Dictionary to a DataFrame:\neducation_df = pd.DataFrame.from_dict(education_dictionary, orient=\"index\")\neducation_df\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\nBasic\n\n\n\n1\n\n\n\n\n\n\n\n2n Cycle\n\n\n\n2\n\n\n\n\n\n\n\nGraduation\n\n\n\n3\n\n\n\n\n\n\n\nMaster\n\n\n\n4\n\n\n\n\n\n\n\nPhD\n\n\n\n5\n\n\n\n\n\n\n\n\nThe resulting DataFrame has the Education level as index and the column 0 has the level information.\nWe can rename the column to “Level”.\neducation_df = education_df.rename(columns={0: \"Level\"})\neducation_df\n\n\n\n\n\n\n\n\n\n\n\nLevel\n\n\n\n\n\n\n\n\n\n\n\nBasic\n\n\n\n1\n\n\n\n\n\n\n\n2n Cycle\n\n\n\n2\n\n\n\n\n\n\n\nGraduation\n\n\n\n3\n\n\n\n\n\n\n\nMaster\n\n\n\n4\n\n\n\n\n\n\n\nPhD\n\n\n\n5\n\n\n\n\n\n\n\n\nWe can now merge this new education_df with our previous concat_df.\nThe left DataFrame is concat_df and we merge on “Education” because that’s where the Eduction information is.\nThe right one is education_df and the information is in the index.\nmerged_df = pd.merge(left=concat_df, right=education_df, left_on=\"Education\", right_index=True)\nmerged_df\n\n\n\n\n\n\n\n\n\n\n\nID\n\n\n\nYear_Birth\n\n\n\nEducation\n\n\n\nMarital_Status\n\n\n\nIncome\n\n\n\nKidhome\n\n\n\nTeenhome\n\n\n\nMntWines\n\n\n\nMntFruits\n\n\n\nMntMeatProducts\n\n\n\nMntFishProducts\n\n\n\nMntSweetProducts\n\n\n\nMntGoldProds\n\n\n\nNumWebPurchases\n\n\n\nNumCatalogPurchases\n\n\n\nNumStorePurchases\n\n\n\nNumWebVisitsMonth\n\n\n\nComplain\n\n\n\nLevel\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n5524\n\n\n\n1957\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n58138.0\n\n\n\n0\n\n\n\n0\n\n\n\n635\n\n\n\n88\n\n\n\n546\n\n\n\n172\n\n\n\n88\n\n\n\n88\n\n\n\n8\n\n\n\n10\n\n\n\n4\n\n\n\n7\n\n\n\n0\n\n\n\n3\n\n\n\n\n\n\n\n1\n\n\n\n2174\n\n\n\n1954\n\n\n\nGraduation\n\n\n\nSingle\n\n\n\n46344.0\n\n\n\n1\n\n\n\n1\n\n\n\n11\n\n\n\n1\n\n\n\n6\n\n\n\n2\n\n\n\n1\n\n\n\n6\n\n\n\n1\n\n\n\n1\n\n\n\n2\n\n\n\n5\n\n\n\n0\n\n\n\n3\n\n\n\n\n\n\n\n2\n\n\n\n4141\n\n\n\n1965\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n71613.0\n\n\n\n0\n\n\n\n0\n\n\n\n426\n\n\n\n49\n\n\n\n127\n\n\n\n111\n\n\n\n21\n\n\n\n42\n\n\n\n8\n\n\n\n2\n\n\n\n10\n\n\n\n4\n\n\n\n0\n\n\n\n3\n\n\n\n\n\n\n\n3\n\n\n\n6182\n\n\n\n1984\n\n\n\nGraduation\n\n\n\nTogether\n\n\n\n26646.0\n\n\n\n1\n\n\n\n0\n\n\n\n11\n\n\n\n4\n\n\n\n20\n\n\n\n10\n\n\n\n3\n\n\n\n5\n\n\n\n2\n\n\n\n0\n\n\n\n4\n\n\n\n6\n\n\n\n0\n\n\n\n3\n\n\n\n\n\n\n\n5\n\n\n\n965\n\n\n\n1971\n\n\n\nGraduation\n\n\n\nDivorced\n\n\n\n55635.0\n\n\n\n0\n\n\n\n1\n\n\n\n235\n\n\n\n65\n\n\n\n164\n\n\n\n50\n\n\n\n49\n\n\n\n27\n\n\n\n7\n\n\n\n3\n\n\n\n7\n\n\n\n6\n\n\n\n0\n\n\n\n3\n\n\n\n\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n…\n\n\n\n\n\n\n\n481\n\n\n\n11133\n\n\n\n1973\n\n\n\nPhD\n\n\n\nYOLO\n\n\n\n48432.0\n\n\n\n0\n\n\n\n1\n\n\n\n322\n\n\n\n3\n\n\n\n50\n\n\n\n4\n\n\n\n3\n\n\n\n42\n\n\n\n7\n\n\n\n1\n\n\n\n6\n\n\n\n8\n\n\n\n0\n\n\n\n5\n\n\n\n\n\n\n\n482\n\n\n\n9589\n\n\n\n1948\n\n\n\nPhD\n\n\n\nWidow\n\n\n\n82032.0\n\n\n\n0\n\n\n\n0\n\n\n\n332\n\n\n\n194\n\n\n\n377\n\n\n\n149\n\n\n\n125\n\n\n\n57\n\n\n\n4\n\n\n\n6\n\n\n\n7\n\n\n\n1\n\n\n\n0\n\n\n\n5\n\n\n\n\n\n\n\n483\n\n\n\n4286\n\n\n\n1970\n\n\n\nPhD\n\n\n\nSingle\n\n\n\n57642.0\n\n\n\n0\n\n\n\n1\n\n\n\n580\n\n\n\n6\n\n\n\n58\n\n\n\n8\n\n\n\n0\n\n\n\n27\n\n\n\n7\n\n\n\n6\n\n\n\n6\n\n\n\n4\n\n\n\n0\n\n\n\n5\n\n\n\n\n\n\n\n484\n\n\n\n4001\n\n\n\n1946\n\n\n\nPhD\n\n\n\nTogether\n\n\n\n64014.0\n\n\n\n2\n\n\n\n1\n\n\n\n406\n\n\n\n0\n\n\n\n30\n\n\n\n0\n\n\n\n0\n\n\n\n8\n\n\n\n8\n\n\n\n2\n\n\n\n5\n\n\n\n7\n\n\n\n0\n\n\n\n5\n\n\n\n\n\n\n\n485\n\n\n\n9405\n\n\n\n1954\n\n\n\nPhD\n\n\n\nMarried\n\n\n\n52869.0\n\n\n\n1\n\n\n\n1\n\n\n\n84\n\n\n\n3\n\n\n\n61\n\n\n\n2\n\n\n\n1\n\n\n\n21\n\n\n\n3\n\n\n\n1\n\n\n\n4\n\n\n\n7\n\n\n\n0\n\n\n\n5\n\n\n\n\n\n\n\n\n\n\n2240 rows × 19 columns"
  },
  {
    "objectID": "python-pandas.html#data-visualization",
    "href": "python-pandas.html#data-visualization",
    "title": "8  Introduction to Python and Pandas",
    "section": "8.10 Data visualization",
    "text": "8.10 Data visualization\nWe can easily create simple graphs using DataFrame.plot().\nThis uses the package matplotlib in the background, which is a very powerful and popular plotting library but is not the most user friendly.\nUsing this Pandas method is very easy and can be a good way to do some initial exploratory plots and later refine them using either pure matplobib or another library.\n\n8.10.1 Histogram\nWe can plot the data from a DataFrame like this:\nkind specifies the kind of plot (for example hist for histogram, bar for bar graph or scatter for scatter plot).\nWe usually specify the columns from which the x and y components should be taken, but for a histogram we only need to specify one.\nax = merged_df.plot(kind=\"hist\", y=\"Income\")\nax.set_xlabel(\"Income\")\nax.set_title(\"Histogram of income\")\nText(0.5, 1.0, ‘Histogram of income’)\n\n\n\npng\n\n\nTask\nThis doesn’t look very good because the x-axis extends so much!\n\nLooking at the data, can you figure out what might cause this?\n\n\nSolution\n\n\nWhen we look at the highest earners, we see that somebody put 666666 as their income.\nWe can assume that this was put as a joke or is an outlier.\nIn either way, we can redo the plot with that datapoint removed.\n\n\nCan you “fix” the plot?\n\n\nSolution\n\n\nax = merged_df[merged_df[\"Income\"] != 666666].plot(kind=\"hist\",y=\"Income\")\nax.set_xlabel(\"Income\")\nax.set_title(\"Fixed Histogram of income\")\nText(0.5, 1.0, ‘Fixed Histogram of income’)\n\n\n\npng\n\n\n\n\n\n8.10.2 Bar plot\nAnother visualization we could do is a bar plot.\nUsing the groupby and mean methods, we can calculate the mean Income like we’ve learned before.\ngrouped_by_education = merged_df.groupby(by=\"Education\")[\"Income\"].mean()\ngrouped_by_education\nEducation\n2n Cycle      47633.190000\nBasic         20306.259259\nGraduation    52720.373656\nMaster        52917.534247\nPhD           56145.313929\nName: Income, dtype: float64\nNow, this data can be shown:\nax = grouped_by_education.plot(kind=\"bar\")\nax.set_ylabel(\"Mean income\")\nax.set_title(\"Mean income for each education level\")\nText(0.5, 1.0, ‘Mean income for each education level’)\n\n\n\npng\n\n\n\n\n8.10.3 Scatter plot\nAnother kind of plot is the scatter plot, which needs two columns for the x and y axis.\nax = df.plot(kind=\"scatter\", x=\"MntWines\", y=\"MntFruits\")\nax.set_title(\"Wine purchases and Fruit purchases\")\nText(0.5, 1.0, ‘Wine purchases and Fruit purchases’)\n\n\n\npng\n\n\nYou can also specify whether the axes should be on the log scale or not.\nax = df.plot(kind=\"scatter\", x=\"MntWines\", y=\"MntFruits\", logy=True, logx=True)\nax.set_title(\"Wine purchases and Fruit purchases, on log scale\")\nText(0.5, 1.0, ‘Wine purchases and Fruit purchases, on log scale’)\n\n\n\npng"
  },
  {
    "objectID": "python-pandas.html#plotnine",
    "href": "python-pandas.html#plotnine",
    "title": "8  Introduction to Python and Pandas",
    "section": "8.11 Plotnine",
    "text": "8.11 Plotnine\nPlotnine is the Python clone of ggplot2, which is very powerful and is great if you are already familiar with the ggplot2 syntax!\nfrom plotnine import *\n(ggplot(merged_df, aes(\"Education\", \"MntWines\", fill=\"Education\"))\n + geom_boxplot(alpha=0.8))\n\n\n\npng\n\n\n(ggplot(merged_df[(merged_df[\"Year_Birth\"]&gt;1900) & (merged_df[\"Income\"]!=666666)],\n        aes(\"Year_Birth\", \"Income\", fill=\"Education\"))\n + geom_point(alpha=0.5, stroke=0)\n + facet_wrap(\"Marital_Status\"))\n\n\n\npng\n\n\ntask\nNow that you are familiar with python, pandas, and plotting. There are two data.tables from AncientMetagenomeDir which contains metadata from metagenomes. You should, by using the code in the tutorial be able to explore the datasets and make some fancy plots.\nfile names:\nsample_table_url\nlibrary_table_url"
  }
]