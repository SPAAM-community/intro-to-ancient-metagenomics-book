---
title: Introduction to Phylogenomics
author: Arthur Kocher
---

::: {.callout-tip}
For this chapter's exercises, if not already performed, you will need to create the [conda environment](before-you-start.qmd#creating-a-conda-environment) from the `yml` file in the following [link](https://github.com/SPAAM-community/intro-to-ancient-metagenomics-book/raw/main/assets/envs/phylogenomics.yml) (right click and save as to download), and once created, activate the environment with:

```bash
conda activate phylogenomics
```
:::


## Lecture

<iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSexn0hc-7Qt2o5jarBzZ3WMLZ4jcjj0fd_QgLYpm5y0tNC_KLnMT00pA6uvpOomQ/embed?start=false&loop=true&delayms=10000" frameborder="0" width="100%" height="400px" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>

PDF version of these slides can be downloaded from [here](assets/images/chapters/phylogenomics/SPAAM%20Summer%20School%202022%20-%205B%20-%20Phylogenomics.pdf).

<iframe width="100%" height="400px" src="https://www.youtube.com/embed/eg-0S5S7EpM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## Practical

### Preparation

The data and conda environment `.yaml` file for this practical session can be downloaded from here: [https://doi.org/10.5281/zenodo.6983184](https://doi.org/10.5281/zenodo.6983184). See instructions on page.

Change into the session directory

```bash
cd phylogenomics/
```

The data in this folder should contain an alignment (snpAlignment_session5.fasta) and a txt file with the ages of the samples that we are going to be working with in this session (`samples.ages.txt`)

Load the conda environment.

```bash
conda activate phylogenomics
```

### Visualize the sequence alignment

In this practical session, we will be working with an alignment produced as you learned in the practical _Genome mapping_.

::: {.callout-note title="What is in the data?"}
- the alignment is a SNP alignment (it contains only the variable genomic positions, not the full genomes)
- it contains 32 _Yersinia pestis_ sequences and 1 _Yersinia pseudotuberculosis_ sequence which can be used as an outgroup
- in this practical, we will investigate the phylogenetic position of four prehistorical _Y. pestis_ strains that we have recently discovered: KZL002, GZL002, CHC004 and VLI092
:::

We start by exploring the alignment in _MEGA_. Open the _MEGA_ desktop application and load the alignment by clicking on File -> Open A File/Session -> Select the _snpAligment_session5.fasta_.

![](assets/images/chapters/phylogenomics/3.png)

It will you ask what you want to do with the alignment. In _MEGA_ you can also produce an alignment, however, since our sequences are already aligned we will press on _Analyze_.

Then we will select _Nucleotide Sequences_ since we are working with a DNA alignment. Note that _MEGA_ can also work with Protein Sequences as well as Pairwise Distance Matrix (which we will cover shortly). In the same window, we will change the character for _Missing Data_ to **N** and click in _OK_.

![](assets/images/chapters/phylogenomics/4.png)

A window would open up asking if our alignment contains protein encoding sequences, and we will select _No_.

::: {.callout-tip}
If you had protein encoding sequences, you would have selected Yes. This will allow you to treat different positions with different evolutionary modes depending on their codon position. One can do this to take in account that the third codon position can change to different nucleotides without resulting in a different amino acid, while position one and two of the codon are more restricted.
:::

To explore the alignment, you will then click on the box with _TA_

![](assets/images/chapters/phylogenomics/5.png)

You will see an alignment containing sequences from the bacterial pathogen _Yersinia pestis_. Within the alignment, we have four sequences of interest (KZL002, GZL002, CHC004 and VLI092) that date between 5000-2000 years Before Present (BP), and we want to know how they relate to the rest of the _Yersinia pestis_ genomes in the alignment.

![](assets/images/chapters/phylogenomics/6.png)

**Questions:**

How many sequences are we analysing?

::: {.callout-note title="Answer" collapse="true"}
We are analysing 33 sequences.
:::

What are the Ns in the sequences?

::: {.callout-note title="Answer" collapse="true"}
They represent positions where we have missing data. We told _MEGA_ to encode missing positions as _N_
:::

What do you think the dots represent?

::: {.callout-tip}
The first line is a **consensus** sequence: it indicates the nucleotide supported by the majority of the sequences in the alignment (90% of the sequences should agree, otherwise an N is displayed)
:::

::: {.callout-note title="Answer" collapse="true"}
They represent positions that are same as the consensus
:::

Once you know this, can you already tell by looking at the alignment which sequence is the most singular (scroll down)

::: {.callout-note title="Answer" collapse="true"}
We can easily see that the last sequence in the alignment (Y. pseudotuberculosis) contains more disagreements to the consensus. This is normal since this is the only genome not belonging to the _Y. pestis_ species: we will use it as an outgroup
:::

### Distance-based phylogeny: Neighbour Joining

The Neighbour Joining (NJ) method is an agglomerative algorithm which can be used to derive a phylogenetic tree from a pairwise distance matrix. In essence, this method will be grouping taxa that have the shortest distance together first, and will be doing this iteratively until all the taxa/sequences included in your alignment have been placed in a tree.

Here are the details of the calculations for a small NJ tree example with 6 taxa:

![](assets/images/chapters/phylogenomics/NJ_algorithm.png)

Luckily, you won't have to do this by hand since _MEGA_ allows you to build a NJ tree. For that go back to _MEGA_ and click on the _Phylogeny_ symbol and then select _Construct Neighbour Joining Tree_. In the window that would pop up, you will then chance the _Model/Method_ to _p-distance_. Then press _OK_ and a window with the calculated phylogenetic tree will pop up.

::: {.callout-note title="p-distances?"}
A NJ tree can be built from any type of distances. This includes:

- p-distances (also called raw distances): these are simply the proportion of differences between sequences
- corrected distances: these are based on an underlying substitution model (JC69, K80, GTR...) and account for multiple mutations at the same sites (which would result in only one visible difference)
- p-distances and corrected distances should be similar when the number of mutations is low compared to the genome length
:::

![](assets/images/chapters/phylogenomics/9.png)

Since the tree is not easily visualised in _MEGA_, we will export it in newick format (an "standarised" format to write a tree in a computer-readable form) and explore our tree in _FigTree_. This tool has a better interface for visually manipulating trees and allows us to interact with the phylogenetic tree.

![](assets/images/chapters/phylogenomics/10.png)

To do that you will click on _File_, then _Export current tree (Newick)_ and click on _Branch Lengths_ to include those in the newick annotation. When you press _OK_, a new window with the tree in newick format will pop up and you will then press _File_ -> _Save_ and saved it as _NJ_tree.nwk_ (If you are doing this for your own project, please give your files informative names).

As said above, we will explore own NJ tree in _FigTree_. Open the software and then open the NJ tree by clicking on _File_ -> _Open_ and selecting the file with the NJ tree _NJ_tree.nwk_

![](assets/images/chapters/phylogenomics/11.png)


Note that even though a root is displayed by default in _FigTree_, NJ trees are actually **unrooted**. We know that _Yersinia pseudotuberculosis_ (labelled here as _Y. pseudotuberculosis_) is an outgroup to _Yersinia pestis_. You can reroot the tree by selecting _Y.pseudotuberculosis_ and pressing _Reroot_.

![](assets/images/chapters/phylogenomics/14.png)

Now we have a rooted tree.

**Questions:**

How much time did the NJ-tree calculation take?

::: {.callout-note title="Answer" collapse="true"}
~1 second
:::

How many leaves/tips has our tree?

::: {.callout-note title="Answer" collapse="true"}
33, i.e. the number of sequences in our SNP alignment.
:::

Where are our taxa of interest? (KZL002, GZL002, CHC004 and VLI092)

::: {.callout-note title="Answer" collapse="true"}
They all fall ancestral to the rest of _Yersinia pestis_ in this tree.
:::

Do they form a monophyletic group (a clade)?

::: {.callout-note title="Answer" collapse="true"}
Yes, they form a monophyletic group. We can also say that this group of prehistoric strains form their own lineage.
:::

### Character-based phylogenetic methods: maximum parsimony and probabilistic approaches

Character-based methods are not based on pairwise distances but rather model the complete evolution of each character (e.g. DNA nucleotides at each position) along the phylogenetic tree.

One of these methods is maximum parsimony and it consists in choosing the tree that underlies an evolutionary history with the least number of character changes.

![](assets/images/chapters/phylogenomics/17.png)

![](assets/images/chapters/phylogenomics/18.png)

Other types of character-based methods which are more commonly used today are probabilistic methods. In general, these are statistical techniques that are based on probabilistic models under which the data that we observe is generated following a probability distribution depending on a set of parameters which we want to estimate. The probability of the data given the model parameters is called the likelihood.

![](assets/images/chapters/phylogenomics/19.png)

**Question:**

In a phylogenetic probabilistic model, what are the data and what are the parameters?

::: {.callout-note title="Answer" collapse="true"}
In a phylogenetic probabilistic model, the data is the sequence alignment and the parameters, are:

- the parameters of the chosen substitution model (substitution rates and base frequencies)
- the phylogenetic tree

![](assets/images/chapters/phylogenomics/20.png)
:::

#### Maximum likelihood estimation and bootstrapping

One way we can make inferences from a probabilistic model is by finding the combination of parameters which maximises the likelihood. These parameter values are called maximum likelihood (ML) estimates. We are usually not able to compute the likelihood value for all possible combinations of parameters and have to rely on heuristic algorithms to find the maximum likelihood estimates.

![](assets/images/chapters/phylogenomics/21.png)

The Maximum likelihood estimates are point estimates, i.e. single parameter values (for example, a tree), which does not allow to measure uncertainty. A classic method to measure the uncertainty in ML trees is bootstrapping, which consists in repeatedly "disturbing" the alignment by masking sites randomly and estimating a tree from each of these bootstrap alignments.

![](assets/images/chapters/phylogenomics/22.png)

For each clade in the ML tree, a bootstrap support value is computed which corresponds to the proportion of bootstrap trees containing the clade. This gives an indication of how robustly the clade is supported by the data (i.e. whether it holds even after disturbing the dataset). Bootstrapping can be used to measure the topology uncertainty of trees estimated with any inference method.

::: {.callout-note}
Bootstrapping can be used to measure incertainty with any type of inference method, including distance methods
:::

**Let's make our own ML tree!**

Here is a command to estimate an ML phylogenetic tree together with bootstraps using _RAxML_ (you may find the list of parameters in the _RAxML_ manual):

```bash
raxmlHPC-PTHREADS -m GTRGAMMA -T 3 -f a -x 12345 -p 12345 -N autoMRE -s snpAlignment_session5.fasta -n full_dataset.tre
```

Here is the meaning of the chosen parameters:

![](assets/images/chapters/phylogenomics/raxml_cmdline.png)

Once the analysis has been completed, you can open the tree using _Figtree_ (RAxML_bipartitions… file, change “label” to “bootstrap support” at the prompt).

![](assets/images/chapters/phylogenomics/figtree_prompt.png)

The tree estimated using this model is a substitution tree (branch lengths represent genetic distances in subst./site). As for the NJ tree,it is not oriented in time: this is an unrooted tree (displayed with a random root in Figtree). You can reroot the tree in _Figtree_ using _Y. pseudotuberculosis_ as an outgroup, as previously.

**Questions:**

Can you confirm the position of our genomes of interest (KZL002, GZL002, CHC004 and VLI092)?

::: {.callout-note title="Answer" collapse="true"}
Yes. Just as in the NJ tree, they form a clade which is basal to the rest of the _Y. pestis_ diversity.
:::

Is that placement well-supported? (look at the bootstrap support value: click on the “Node Labels” box and open the drop-down menu, change “Node ages” to “bootstrap support”)

::: {.callout-note title="Answer" collapse="true"}
The placement is strongly supported as indicated by a bootstrap support of 100% for this clade (it is not very easy to see, you probably need to zoom in a bit)

![](assets/images/chapters/phylogenomics/bootstrap_support.png)
:::

You can notice that the phylogeny is difficult to visualize due to the long branch leading to _Y. pseudotuberculosis_. Having a very distant outgroup can also have deleterious effects on the estimated phylogeny (due to the so-called "long branch attraction" effect). We can construct a new phylogeny after removing the outgroup:

- go back to the alignment in mega, unclick _Y.pseudotuberculosis_, and export in fasta format ("Data" -> "Export Data" -> change "Format" to "Fasta" and click "Ok"; you can save it as: "snpAlignment_without_Ypseudo.fas")
- run raxml on this new alignment (change input to "snpAlignment_without_Ypseudo.fas" and output prefix to "without_Ypseudo" in the commandline)
- open the bipartition... file in figtree and reroot the tree based on the knowledge we have gained previously: place the root on the branch leading to the prehistoric Y. pestis strains (KZL002, GZL002, CHC004 and VLI092).

![](assets/images/chapters/phylogenomics/raxml_tree_woOutgroup.png)

Lastly, we will export the rooted tree from figtree: File -> Export trees -> select the "save as currently displayed" box and save as "ML_tree_rooted.tre"

![](assets/images/chapters/phylogenomics/export_tree.png)

#### Estimating a time-tree using Bayesian phylogenetics (_BEAST2_)

Now, we will try to use reconstruct a phylogeny in which the branch lengths do not represent a number of mutations but instead represent the time of evolution. To do so, we will use the ages of ancient genomes (C14 dates) to calibrate the tree in time. This assumes a molecular clock hypothesis in which substitutions occur at a rate that is relatively constant in time so that the time of evolution can be estimated based on the number of substitutions.

::: {.callout-note}
A great advantage of ancient pathogen genomes is that they provide key calibration points to estimate molecular clocks and dated phylogenies. This is much more difficult to do with modern data alone.
:::

We will estimate a time tree from our alignment using Bayesian inference as implemented in the _BEAST2_ software. Bayesian inference is based on a probability distribution that is different from the likelihood: the posterior probability. The posterior probability is the probability of the parameters given the data. It is easier to interpret than the likelihood because it directly contains all the information about the parameters: point estimates such as the median or the mean can be directly estimated from it, but also percentile intervals which can be used to measure uncertainty.

![](assets/images/chapters/phylogenomics/23.png)

The Bayes theorem tells us that is proportional to the product of the likelihood and the "prior" probability of the data:

![](assets/images/chapters/phylogenomics/equation.png)

Therefore, for Bayesian inference, we need to complement our probabilistic model with prior distributions for all the parameters. Because we want to estimate a time tree, we also add another parameter: the molecular clock (average substitution rate in time units).

![](assets/images/chapters/phylogenomics/24.png)

To characterize the full posterior distribution of each parameter, we would need in theory to compute the posterior probability for each possible combination of parameters. This is impossible, and we will instead use an algorithm called Markov chain Monte Carlo (MCMC) to approximate the posterior distribution. The MCMC is an algorithm which iteratively samples values of the parameters from the posterior distribution. Therefore, if the MCMC has run long enough, the (marginal) posterior distribution of the parameters can be approximated by a histogram of the sampled values.

![](assets/images/chapters/phylogenomics/25.png)

**Let's estimate a time tree using _BEAST2_**:

::: {.callout-tip}
The ["taming the beast" website](https://taming-the-beast.org/tutorials/) has great tutorials to learn setting a _BEAST2_ analysis. In particular, the "Introduction to BEAST2", "Prior selection" and "Time-stamped data" are good starts.
:::

The different components of the _BEAST2_ analysis can be set up in the program _BEAUti_:

![](assets/images/chapters/phylogenomics/26.png)

Open BEAUTi and set up an analysis as followed:

- load the alignment without Y. pseudotuberculosis in the "Partitions" tab ("File" -> "Import alignment"; select "nucleotide")

![](assets/images/chapters/phylogenomics/beauti_import_data.png)

- set the sampling dates in the "Tip dates" tab:
    - select "Use tip dates"
    - click on "Auto-configure" -> "read from file" and select the sample_dates.txt file
    - change "Since some time in the past" to "Before present"

![](assets/images/chapters/phylogenomics/beauti_tip_dates.png)

- select the substitution model in the "Site model" tab:
    - chose a GTR model
    - use 4 Gamma categories for the Gamma site model: this is to account for variations of the substitution rate accross sites (site=nucleotide position)

![](assets/images/chapters/phylogenomics/beauti_substitution_model.png)

- choose the molecular clock model in the "Clock model" tab:
    - use a relaxed clock lognormal model (this is to allow for some variation of the clock rate accross branches)
    - change the initial value of the clock rate to 10<sup>-4</sup> substitution/site/year (**10<sup>-4</sup> can be written 1E-4**)

![](assets/images/chapters/phylogenomics/beauti_clock_model.png)

- choose the prior distribution of parameters in the "Priors" tab:
    - use a Bayesian Skyline Coalescent tree prior
    - change the mean clock prior to a uniform distribution between 1E-6 and 1E-3 subst/site/year
    - leave everything else to default

![](assets/images/chapters/phylogenomics/beauti_priors.png)

- set up the MCMC in the "MCMC" tab:
    - use a chain length of 300M
    - sample the monodimensional parameters and trees every 10,000 iterations ("tracelog/treelog" -> "log every") 

![](assets/images/chapters/phylogenomics/beauti_MCMC.png)

- save the analysis setup as an xml file: "File" -> "Save as"; you can name the file "beast_analysis_Y_pestis.xml"

Now that the analysis is setup, we can run it using BEAST:

```bash
beast beast_analysis_Y_pestis.xml
```

Once the analysis is completed, assess the posterior distribution sampling and parameter estimates by loading the obtained log file into _Tracer_

First, look at the trace of the posterior to check if the MCMC has passed the burn-in phase, and if you have remove all burn-in iterations

![](assets/images/chapters/phylogenomics/32.png)

If so you can look at the trace and effective sample size (ESS) value of all parameters, to check that the MCMC has run long enough. The traces should look (more or less) like a "hairy caterpillar", and a rule of thumb is that all ESS values should be above 200. If this is not the case, you should run the MCMC longer (BEAST2 has a -resume option that you can use to extend the MCMC sampling without starting everything from the beginning).

![](assets/images/chapters/phylogenomics/33.png)

You can then look at the estimates of your parameter in the top-right panel (mean, median, 95% HPD interval, ...). Note that these are marginal estimates, i.e. integrated over all other parameters.

![](assets/images/chapters/phylogenomics/34.png)

What is your estimate of the substitution (mean clock) rate?

You can then generate a maximum clade credibility (MCC) tree using _treeAnnotator_.

![](assets/images/chapters/phylogenomics/MCC.png)

What is your mean estimate for the age of the common ancestor of all _Yersinia pestis_ strains? To which parameter (displayed in beauti) does this corresponds?

#### Bonus: Temporal signal testing

It is a good practice to assess if the genetic sequences that we analyse do indeed behave like molecular clocks before trying to estimate a time tree. A classic test to do this is called root-to-tip regression, which consists in verifying that the oldest a sequence is, the closer it should be to the root because there was less time for mutations to accumulate before this sequence was sampled. The correlation between sample age and distance to the root (root-to-tip regression) can be assessed using a rooted substitution tree and the program _tempest_:

- open tempest and load the re-rooted ML tree that we produced previously
- click on "import dates" in the "sample dates" tab, select the sample_age.txt file, and then change to "dates specified as years before the present"
- look at the root-to-tip regression: is there a positive correlation?

![](assets/images/chapters/phylogenomics/Tempest.png)